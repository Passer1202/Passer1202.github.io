<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>图形学复习</title>
    <link href="/2025/06/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2025/06/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1id="计算机图形学期末预习复习">计算机图形学期末<del>预习</del>复习</h1><!-- > 复习资料已上传至[njubox](https://box.nju.edu.cn/d/7bbbcbb2bef8413c9f5b/). --><blockquote><p>这是一份由lhj和fjz共同整理的计算机图形学复习文档.</p></blockquote><h2 id="样卷分析">样卷分析</h2><p>2021——2022年样卷围绕各个算法展开，涉及直线中点画线算法、直线裁剪算法、多边形扫描转换方法、旋转变换矩阵以及Hermite形式的参数三次多项式曲线.</p><h2 id="线画图元生成算法">线画图元生成算法</h2><h3 id="画线算法">画线算法</h3><p>画线，即将线段数字化为一组离散整数位置的过程。场景中的直线段通常由其两<strong>端点</strong>的坐标位置来定义，通过特定算法计算得到中间各点的位置并将颜色值存放到帧缓存的相应坐标位置，待视频控制器从帧缓存读出写入的颜色值并绘制于屏幕。</p><h4 id="dda算法">DDA算法</h4><p>从一个端点出发，以 <span class="math inline">\(\delta_x\)</span>（或<spanclass="math inline">\(\delta_y\)</span>）为步长，逐个计算各点坐标，对于<span class="math inline">\(y=mx+b\)</span>:</p><ul><li><span class="math inline">\(|m|&lt;1\)</span>: 以单位 <spanclass="math inline">\(x\)</span> 间隔取样.若从左端点出发，设置 <spanclass="math inline">\(\delta_x=1\)</span> ，则 <spanclass="math inline">\(y_{k+1}=y_k+m\)</span> ;若从右端点出发，设置 <spanclass="math inline">\(\delta_x=-1\)</span> ,则 <spanclass="math inline">\(y_{k+1}=y_k-m\)</span>.</li><li><span class="math inline">\(|m|&gt;1\)</span>: 以单位 <spanclass="math inline">\(y\)</span> 间隔取样.若从下端点出发，设置 <spanclass="math inline">\(\delta_y=1\)</span>，则 <spanclass="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>;若从上端点出发，设置 <spanclass="math inline">\(\delta_y=-1\)</span>,则 <spanclass="math inline">\(x_{k+1}=x_k-\frac{1}{m}\)</span>.</li></ul><h4 id="bresenham画线算法">Bresenham画线算法</h4><p>通俗来讲，Bresenham画线算法每次生成两个可能的像素位置，并从中选择一个更接近线路径的，相较于DDA中大量的浮点数运算，Bresenham算法使用整数增量，win！</p><p>以正斜率小于1的直线扫描转换过程为例，我们来思考Bresenham算法做了什么.假如在第k步我们已经确定了要显示的像素在<span class="math inline">\((x_k,y_k)\)</span> ，那么 <spanclass="math inline">\(y_{k+1} \in \{y_k,y_{k+1}\}\)</span> .我们需要衡量<span class="math inline">\(y_k,y_{k+1}\)</span>谁距离目标直线更近，于是我们计算 <spanclass="math inline">\(d_l,d_u\)</span>, 考虑到在 <spanclass="math inline">\(x_k+1\)</span> 处直线上 <spanclass="math inline">\(y\)</span> 坐标实为 <spanclass="math display">\[y=m(x_k+1)+b\]</span> , 那么我们有 <spanclass="math display">\[d_l=y-y_k=m(x_k+1)+b-y_k\]</span> 以及 <spanclass="math display">\[d_u=y_k+1-m(x_k+1)-b\]</span>,只需作差并判断正负我们就可知哪个像素点距离目标直线更近了：<spanclass="math display">\[d_l-d_u=2m(x_k+1)-2y_k+2b-1\]</span>. 又由于<span class="math inline">\(m=\frac{\Delta y}{\Delta x}\in(0,1)\)</span> ，我们希望避免浮点数运算，将上式乘上 <spanclass="math inline">\(\Delta x\)</span> ,于是我们就发明了决策变量：<span class="math display">\[p_k=\Deltax(d_l-d_u)=2\Delta y x_k -2 \Delta x y_k +c \]</span> ，其中 <spanclass="math inline">\(c=2\Delta y+(2b-1)\Delta x\)</span>. 同样的，在第<span class="math inline">\(k+1\)</span> 步，我们也有 <spanclass="math display">\[p_{k+1} = 2\Delta y x_{k+1} -2 \Delta x y_{k+1}+c \]</span>, 作差得 <span class="math display">\[p_{k+1}-p_k = 2\Deltay (x_{k+1}-x_k) -2 \Delta x (y_{k+1}-y_k) = 2\Delta y -2 \Delta x(y_{k+1}-y_k) \]</span>. 当 <spanclass="math inline">\(p_k&gt;0\)</span>,我们有 <spanclass="math inline">\(d_l&gt;d_u\)</span>, <spanclass="math inline">\(y_{k+1}=y_k+1\)</span> ， 有 <spanclass="math display">\[p_{k+1}-p_k = 2\Delta y -2 \Delta x \]</span>,否则有 <span class="math display">\[p_{k+1}-p_k = 2\Delta y\]</span> .直接计算 <span class="math display">\[p_0=\Delta x (d_l-d_u)=2\Deltay-\Delta x\]</span>. 至此我们发明了Bresenham画线算法!</p><blockquote><p><span class="math inline">\(0&lt;m&lt;1\)</span> 时的 Bresenham画线算法：</p><ol type="1"><li>输入线段的两个端点，并将左端点存储在 <spanclass="math inline">\((x_0, y_0)\)</span> 中；</li><li>将 <span class="math inline">\((x_0, y_0)\)</span>装入帧缓存，画出第一个点；</li><li>计算常量 <span class="math inline">\(\Delta x, \Delta y, 2\Deltay\)</span> 和$ 2y - 2x$，并得到决策参数的第一个值: <spanclass="math display">\[p_0 = 2\Delta y - \Delta x \]</span></li><li>从 <span class="math inline">\(k=0\)</span> 开始，在沿线路径的每个<span class="math inline">\(x_k\)</span> 处，进行下列检测：</li></ol><ul><li>如果 <span class="math inline">\(p_k &lt;0\)</span>，下一个要绘制的点是 <span class="math inline">\((x_k+1,y_k)\)</span>，并且 <span class="math display">\[p_{k+1} = p_k + 2\Deltay \]</span></li><li>否则，下一个要绘制的点是 <span class="math inline">\((x_k+1,y_k+1)\)</span>，并且<span class="math display">\[p_{k+1} = p_k +2\Delta y - 2\Delta x \]</span></li></ul><ol start="5" type="1"><li>重复步骤 4，共 <span class="math inline">\(\Delta x-1\)</span>次。</li></ol></blockquote><p>下面我们考虑一般的Bresenham画线算法.注意到xy平面各种八分和四分区域间的对称性:</p><figure><img src="/image/cg/bresenham_line.png"alt="各区域的Bresenham画线算法" /><figcaption aria-hidden="true">各区域的Bresenham画线算法</figcaption></figure><ul><li>斜率绝对值决定取样方向.<ul><li>大于1：<span class="math inline">\(y\)</span> 轴方向取样.</li><li>小于1：<span class="math inline">\(x\)</span> 轴方向取样.</li></ul></li><li>起始端点决定直线生成方向（也即相应坐标值增量的正负）.<ul><li>生成方向与坐标轴相同则增量为坐标值增量为正.</li><li>否则为反.</li></ul></li></ul><h3 id="圆生成算法">圆生成算法</h3><p>下面我们延续Bresenham画线算法的思想，尝试画圆.</p><p>如同画线算法，我们在每一步中以<strong>单位间隔</strong>取样,从两候选像素中找出距离目标圆更近的一个.对于圆心在<span class="math inline">\((x_c,y_c)\)</span> 半径为 <spanclass="math inline">\(r\)</span> 的圆来说，我们可以使用算法计算圆心在<span class="math inline">\((0,0)\)</span> 且半径同为 <spanclass="math inline">\(r\)</span>的圆的像素坐标，再经过简单的平移变换得到目标圆的像素坐标.因此，方便起见，算法只考虑圆心位于原点的圆.考虑到圆的对称性，我们只需要考虑第一象限中从<span class="math inline">\(x=0\)</span> 到 <spanclass="math inline">\(x=y\)</span> 的圆弧段（八分圆），在正 <spanclass="math inline">\(x\)</span>方向取单位步长，其他七个根据对称性求得.</p><p>首先定义圆函数 <span class="math display">\[f_c(x,y) = x^2+y^2-r^2\]</span>, 则任何点 <span class="math inline">\((x,y)\)</span>和圆的位置关系都可根据 <span class="math inline">\(f_c(x,y)\)</span>大于、小于或等于0来判断.下面定义决策参数 <spanclass="math display">\[p_k=f_c(x_k+1 , y_k - \frac{1}{2} )=(x_k+1)^2+(y_k-\frac{1}{2})^2-r^2\]</span>.</p><figure><img src="/image/cg/circ1.png"alt="沿圆路径取样位置xk+1上候选像素间的中点" /><figcaptionaria-hidden="true">沿圆路径取样位置xk+1上候选像素间的中点</figcaption></figure><p>如图所示，若 <span class="math inline">\(p_k&lt;0\)</span>则中点位于圆内，显然扫描线 <span class="math inline">\(y_k\)</span>上的像素更接近与目标圆，我们没理由不选择它；否则我们将选择位于 <spanclass="math inline">\(y_k-1\)</span> 的像素点.</p><p>惊喜的是，依靠增量运算，我们并不需要每次都进行讨厌的平方运算，考虑<spanclass="math display">\[p_{k+1}=f_c(x_{k+1}+1,y_{k+1}-\frac{1}{2})\]</span>，与<span class="math inline">\(p_k\)</span> 作差得 <spanclass="math display">\[p_{k+1}-p_k=2(x_k+1)+(y_{k+1}^2-y_k^2)-(y_{k+1}-y_k)+1\]</span>.</p><p>当 <span class="math inline">\(p_k&lt;0\)</span>，我们有 <spanclass="math inline">\(y_{k+1}=y_k\)</span> , <spanclass="math display">\[p_{k+1}-p_k = 2(x_k +1)+1=2x_{k+1}+1\]</span>; 当<span class="math inline">\(p_k&gt;0\)</span>，我们有 <spanclass="math inline">\(y_{k+1}=y_k-1\)</span>, <spanclass="math display">\[p_{k+1}-p_k =2x_{k+1}+1 - 2y_k -2=2x_{k+1}+1 -2y_{k+1} \]</span>, 而 <span class="math inline">\(2x_{k+1}\)</span> 和<span class="math inline">\(2y_{k+1}\)</span>的求值也可以通过增量的方式得到 <spanclass="math display">\[2x_{k+1}=2x_k+2,2y_{k+1}=2y_k-2\]</span>.对圆函数在起始位置<span class="math inline">\((x_0,y_0)=(0,r)\)</span>求值，就得到了初始决策参数 <spanclass="math display">\[p_0=f_c(1,r-\frac{1}{2}) =\frac{5}{4} -r\]</span> .</p><p>至此，我们发明了中点圆算法！</p><blockquote><p>中点圆算法： 1. 输入圆的半径 $ r $ 和圆心 <spanclass="math inline">\((x_c,y_c)\)</span>，并得到圆周（圆心在原点）上的第一个点：<br /><span class="math display">\[  (x_0, y_0) = (0, r)  \]</span></p><ol start="2" type="1"><li><p>计算决策参数的初始值：<br /><span class="math display">\[  p_0 = \frac{5}{4} - r  \]</span></p></li><li><p>从 $ k = 0 $ 开始，在每个 $ x_k $ 位置进行以下检测：<br /></p></li></ol><ul><li>如果 $ p_k &lt; 0 $，则下一个点为 <spanclass="math inline">\((x_{k+1}, y_k)\)</span>，并更新决策参数：<br /><span class="math display">\[p_{k+1} = p_k + 2x_{k+1} + 1\]</span><br /></li><li>否则，下一个点为 <span class="math inline">\((x_{k+1}, y_k -1)\)</span>，并更新决策参数：<br /><span class="math display">\[p_{k+1} = p_k + 2x_{k+1} + 1 - 2y_{k+1}\]</span><br />其中，$ 2x_{k+1} = 2x_k + 2 $ 且 $ 2y_{k+1} = 2y_k - 2 $。</li></ul><ol start="4" type="1"><li><p>确定在其他七个八分圆中的对称点。</p></li><li><p>将每个计算出的像素位置 <span class="math inline">\((x,y)\)</span> 平移到圆心 <span class="math inline">\((x_c, y_c)\)</span>的圆路径上：<br />$ x = x + x_c, y = y + y_c $</p></li><li><p>重复步骤 3 到步骤 5，直到 $ x y $。</p></li></ol></blockquote><h3 id="椭圆生成算法">椭圆生成算法</h3><p>还是依靠Bresenham算法的思想，我们现在开始尝试画椭圆.</p><p>类似中点圆算法，给定参数 <span class="math inline">\(r_x,r_y\)</span>和 <span class="math inline">\((x_c,y_c)\)</span>，首先确定以原点为中心的标准椭圆上的点 <spanclass="math inline">\((x,y)\)</span> ， 然后将这些点平移到以 <spanclass="math inline">\((x_c,y_c)\)</span> 为中心的椭圆上.如果希望显示不在标准位置的椭圆，只需要饶中心坐标旋转并对长轴和短轴重新定向.</p><p>考虑到椭圆的对称性，我们只需要在第一象限确定各像素点的位置.具体的，中心椭圆算法将以斜率为-1为界限，分成两部分应用于第一象限，如下图所示.在斜率绝对值小于1的区域在 <span class="math inline">\(x\)</span>方向取单位步长，在斜率绝对值大于1的区域在 <spanclass="math inline">\(y\)</span> 方向取单位步长来处理这个象限.</p><figure><img src="/image/cg/ellipse1.png" alt="椭圆处理的区域" /><figcaption aria-hidden="true">椭圆处理的区域</figcaption></figure><p>定义椭圆函数 <spanclass="math display">\[f_e(x,y)=r_y^2x^2+r_x^2y^2-r_x^2r_y^2\]</span> ,我们令椭圆函数作为中点算法的决策参数，帮我们在两候选像素位置之间做决定.</p><p>具体的，从 <span class="math inline">\((0,r_y)\)</span> 开始，在<span class="math inline">\(x\)</span>方向上取单位步长直到区域1和区域2的分界处，然后转换成 <spanclass="math inline">\(y\)</span>方向的单位步长，从而覆盖第一象限中的剩余曲线段.为了判定我们在哪个区域，每一步都需要检测曲线的（切线）斜率值，椭圆的斜率可由曲线方程求导得到<span class="math display">\[\frac{dy}{dx}=-\frac{2r_y^2x}{2r_x^2y}\]</span> ， 而交界区域位置有 <spanclass="math inline">\(dy/dx=-1\)</span> ,从而有<spanclass="math display">\[2r_y^2x=2r_x^2y\]</span> ,也即当 <spanclass="math inline">\(2r_y^2x \geq 2r_x^2y\)</span>的时候，移出区域1进入区域2.</p><p>考虑区域1，如下图所示. 我们有 <spanclass="math display">\[p1_k=f_e(x_k+1,y_k-\frac{1}{2})=r_y^2(x_k+1)^2+r_x^2(y_k-\frac{1}{2})^2-r_x^2r_y^2\]</span>.当 <span class="math inline">\(p_1k&lt;0\)</span> 中点位于椭圆内，选择<span class="math inline">\(y_k\)</span> 上的像素更接近椭圆，否则选择<span class="math inline">\(y_k-1\)</span> 上的像素.</p><figure><img src="/image/cg/ellipse2.png"alt="椭圆轨迹上取样位置xk+1处候选像素中点" /><figcaptionaria-hidden="true">椭圆轨迹上取样位置xk+1处候选像素中点</figcaption></figure><p>计算下一取样位置的决策参数，<span class="math display">\[p1_{k+1}=f_e(x_{k+1}+1,y_{k+1}-\frac{1}{2})=r_y^2[(x_k+1)+1]^2+r_x^2(y_{k+1}-\frac{1}{2})^2-r_x^2r_y^2\]</span> 从而 <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2(x_k+1)+r_y^2+r_x^2[(y_{k+1}-\frac{1}{2})^2-(y_k-\frac{1}{2})^2]\]</span>.</p><p>当 <span class="math inline">\(p1_k&lt;0\)</span> , <spanclass="math inline">\(y_{k+1}=y_k\)</span> , 有 <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2x_{k+1}+r_y^2\]</span> .当<span class="math inline">\(p1_k \geq 0\)</span> ， <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2x_{k+1}+r_y^2-2r_x^2y_{k+1}\]</span>.</p><p>事实上，计算增量只需要我们进行加减运算，这是因为 <spanclass="math inline">\(2r_y^2x\)</span> 和 <spanclass="math inline">\(2r_x^2y\)</span> 的值也可以通过增量得到.</p><p>在起始位置处，我们有 <spanclass="math display">\[2r_yx^2=0,2r_x^2y=2r_x^2r_y\]</span>， 决策参数<spanclass="math display">\[p1_0=r_y^2-r_x^2r_y+\frac{1}{4}r_x^2\]</span>.</p><p>对于区域二的分析和区域一类似，不同的是<strong>取样方向</strong>.</p><blockquote><p>中点椭圆绘制算法</p><ol type="1"><li><strong>输入参数</strong>：输入 <spanclass="math inline">\(r_x\)</span>、<spanclass="math inline">\(r_y\)</span> 和 <span class="math inline">\((x_c,y_c)\)</span>，得到中心在原点的椭圆的第一个点：</li></ol><p><span class="math display">\[  (x_0, y_0) = (0, r_y)  \]</span></p><ol start="2" type="1"><li><strong>区域1决策参数初值</strong>：</li></ol><p><span class="math display">\[  p1_0 = r_y^2 - r_x^2 r_y + \frac{1}{4} r_x^2  \]</span></p><ol start="3" type="1"><li><strong>区域1每个 <span class="math inline">\(x_k\)</span>位置处，<span class="math inline">\(k = 0\)</span>开始循环测试</strong>：</li></ol><ul><li><p>若 <span class="math inline">\(p1_k &lt;0\)</span>，选择像素：<span class="math inline">\((x_k+1, y_k)\)</span>且：</p><p><span class="math display">\[p1_{k+1} = p1_k + 2r_y^2 x_k + r_y^2\]</span></p></li><li><p>若 <span class="math inline">\(p1_k &gt;0\)</span>，选择像素：<span class="math inline">\((x_k+1,y_k-1)\)</span> 且：</p><p><span class="math display">\[p1_{k+1} = p1_k + 2r_y^2 x_k + 2r_y^2 - 2r_x^2 y_k + r_y^2\]</span></p></li><li><p>其中：</p><p><span class="math display">\[2r_y^2 x_{k+1} = 2r_y^2 x_k + 2r_y^2  \]</span></p><p><span class="math display">\[2r_x^2 y_{k+1} = 2r_x^2 y_k - 2r_x^2\]</span></p></li><li><p><strong>循环终止条件</strong>：<span class="math inline">\(2r_y^2x \geq 2r_x^2 y\)</span></p></li></ul><ol start="4" type="1"><li><strong>区域1最后点 <span class="math inline">\((x_l, y_l)\)</span>计算区域2参数初值</strong>：</li></ol><p><span class="math display">\[  p2_0 = r_y^2 (x_l + 1/2)^2 + r_x^2 (y_l - 1)^2 - r_x^2 r_y^2  \]</span></p><ol start="5" type="1"><li><strong>区域2每个 <span class="math inline">\(y_k\)</span>位置处，<span class="math inline">\(k = 0\)</span>开始循环测试</strong>：</li></ol><ul><li><p>若 <span class="math inline">\(p2_k &gt;0\)</span>，选择像素：<span class="math inline">\((x_k, y_k -1)\)</span> 且：</p><p><span class="math display">\[p2_{k+1} = p2_k - 2r_x^2 y_k + r_x^2\]</span></p></li><li><p>否则，选择像素：<span class="math inline">\((x_k + 1, y_k -1)\)</span> 且：</p><p><span class="math display">\[p2_{k+1} = p2_k + 2r_y^2 x_k + 2r_y^2 - 2r_x^2 y_k + r_x^2\]</span></p></li><li><p>与区域1相同的 x 和 y 增量计算。</p></li><li><p><strong>循环终止条件</strong>：至 <span class="math inline">\(r_y= 0\)</span></p></li></ul><ol start="6" type="1"><li><p><strong>对称</strong>：确定其它三个像素对称点。</p></li><li><p><strong>平移</strong>：将每个像素位置 <spanclass="math inline">\((x, y)\)</span> 平移到中心在 <spanclass="math inline">\((x_c, y_c)\)</span>的椭圆轨迹上，并按坐标值画点：</p></li></ol><p><span class="math display">\[  x = x + x_c, \quad y = y + y_c  \]</span></p></blockquote><h3 id="线画图元生成小结">线画图元生成小结</h3><figure><img src="/image/cg/summary1.png" alt="线画图元生成小结" /><figcaption aria-hidden="true">线画图元生成小结</figcaption></figure><h2 id="填充图元生成算法">填充图元生成算法</h2><p>除点、直线段和曲线外，另一种描述图形组成部分的有用结构是使用某种颜色或图案进行填充的区域.</p><p>填充图元的表示方式分为顶点表示和点阵表示.顶点表示用多边形的顶点坐标来描述图形.例如，一个三角形可以通过三个顶点的坐标来定义.而点阵表示用位于多边形内部的像素集合来描述图形，即实际显示的图像.</p><blockquote><p>ds: 填充的核心任务是将多边形的顶点表示转换为点阵表示.</p></blockquote><p>填充图元（区域）可以根据填充内容分为以下三种基本模式：</p><ol type="1"><li>颜色边界的空心区域<ul><li>特点：仅显示区域的边界轮廓（如多边形边线），内部保持与背景色一致（不填充）。</li><li>应用：适用于需要突出形状轮廓的场景，如线框模型、示意图。</li></ul></li><li>实颜色填充的实心区域<ul><li>特点：用单一颜色填充区域内部，边界可以包含在内（边界与内部同色）或单独指定颜色。</li><li>应用：常见于纯色图形（如按钮、色块）。</li></ul></li><li>指定图案或设计图形填充的图案区域<ul><li>特点：用自定义图案（如纹理、渐变、图像）填充区域内部。</li><li>应用：适用于需要复杂视觉效果的对象（如游戏贴图、艺术设计）。</li></ul></li></ol><blockquote><p><strong>实颜色</strong>（SolidColor）是指用单一、均匀的颜色值填充一个区域，没有任何渐变、纹理或透明度变化。它是与“图案填充”或“渐变填充”相对的概念。</p></blockquote><h3 id="扫描转换填充算法">扫描转换填充算法</h3><p>输入多边形顶点信息，以扫描线与多边形边界的交点为界限，求出内部各个像素，输出多边形点阵表示.</p><figure><img src="/image/cg/scantrans.png" alt="处理扫描线" /><figcaption aria-hidden="true">处理扫描线</figcaption></figure><p>依次处理每条扫描线，计算其与多边形边的交点，将交点沿扫描线按横坐标值升序排列，自左到右对交点配对，并对交点坐标取整处理，给每对交点间扫描线区段的像素点设置填充颜色，核心问题是<strong>扫描线与多边形边界求交</strong>以及<strong>边界及交点的存储管理</strong>.</p><h4 id="扫描线与区域边界求交">扫描线与区域边界求交</h4><p><strong>直线的连贯性</strong>是指直线穿越两条相邻扫描线时斜率不变.我们将利用连贯性来进行交点的增量计算.</p><p>考虑边界 <span class="math inline">\(y=mx+b\)</span>. 扫描线间 <spanclass="math inline">\(y\)</span> 坐标变化为 <spanclass="math inline">\(y_{k+1}-y_k\)</span> ， 则当前扫描线和边界交点的值<span class="math inline">\(x_{k+1}\)</span>可由前一条扫描线上和边界的交点值来计算,即 <spanclass="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>.</p><p>可是这还不够，<span class="math inline">\(\frac{1}{m}\)</span>是浮点数，我们讨厌浮点数运算，我们希望增量计算是整数计算.</p><p>于是我们将斜率 <span class="math inline">\(m\)</span> 转化成两整数比<span class="math inline">\(\frac{\Delta y}{\Deltax}\)</span>，则我们可以把增量 <span class="math inline">\(1/m\)</span>的计算变成整数运算.</p><p>一种方法是<strong>直接舍入取整</strong>，我们维护一个计数器 <spanclass="math inline">\(k\)</span>，初始化计数器为0，对于每条新的扫描线，计数器增加<span class="math inline">\(\Delta x\)</span> , 若 <spanclass="math inline">\(k\geq \Delta y\)</span>, 交点 <spanclass="math inline">\(x\)</span> 值增加1，<spanclass="math inline">\(k-=\Delta y\)</span>.</p><p><strong>例子：</strong> 假设有一条边从(1,1)到(6,4)： - Δx = 5 (6-1) -Δy = 3 (4-1) - 初始交点x=1</p><table><thead><tr><th>扫描线y</th><th>计数器操作</th><th>计数器值</th><th>是否产生新交点</th><th>交点x</th></tr></thead><tbody><tr><td>1</td><td>初始</td><td>0</td><td>否</td><td>1</td></tr><tr><td>2</td><td>+5</td><td>5</td><td>5≥3: 是</td><td>2</td></tr><tr><td></td><td>-3</td><td>2</td><td></td><td></td></tr><tr><td>3</td><td>+5</td><td>7</td><td>7≥3: 是</td><td>3</td></tr><tr><td></td><td>-3</td><td>4</td><td>4≥3: 是</td><td>4</td></tr><tr><td></td><td>-3</td><td>1</td><td></td><td></td></tr><tr><td>4</td><td>+5</td><td>6</td><td>6≥3: 是</td><td>5</td></tr><tr><td></td><td>-3</td><td>3</td><td>3≥3: 是</td><td>6</td></tr><tr><td></td><td>-3</td><td>0</td><td></td><td></td></tr></tbody></table><p>另一种方法是<strong>细化取整法</strong>，依旧维护一个计数器 <spanclass="math inline">\(k\)</span>，将其初始化为0，对于每条扫描线，计数器增加 <spanclass="math inline">\(2\Delta x\)</span> ，若 <spanclass="math inline">\(k\geq \Delta y\)</span> ,令交点 <spanclass="math inline">\(x\)</span> 值加一，<spanclass="math inline">\(k-=2\Delta y\)</span>.</p><p><strong>例子：</strong> 同样以(1,1)到(6,4)为例：</p><table><thead><tr><th>扫描线y</th><th>计数器操作</th><th>计数器值</th><th>是否产生新交点</th><th>交点x</th></tr></thead><tbody><tr><td>1</td><td>初始</td><td>0</td><td>否</td><td>1</td></tr><tr><td>2</td><td>+10</td><td>10</td><td>10≥3: 是</td><td>2</td></tr><tr><td></td><td>-6</td><td>4</td><td>4≥3: 是</td><td>3</td></tr><tr><td></td><td>-6</td><td>-2</td><td></td><td></td></tr><tr><td>3</td><td>+10</td><td>8</td><td>8≥3: 是</td><td>4</td></tr><tr><td></td><td>-6</td><td>2</td><td>2≥3: 否</td><td></td></tr><tr><td>4</td><td>+10</td><td>12</td><td>12≥3: 是</td><td>5</td></tr><tr><td></td><td>-6</td><td>6</td><td>6≥3: 是</td><td>6</td></tr><tr><td></td><td>-6</td><td>0</td><td></td><td></td></tr></tbody></table><h4 id="区域边界顶点的求交处理">区域边界顶点的求交处理</h4><p>如下图所示，扫描线 <span class="math inline">\(y1\)</span>穿过一个顶点(共享顶点的两条边位于扫描线的同侧)，它与偶数条边相交，沿扫描线<span class="math inline">\(y1\)</span>的相交点正确地分辨出了内部像素分布；扫描线y穿过一个顶点(顶点的两条相交边位于扫描线的异侧)，与五条多边形边相交.因此，必须要作一些额外的处理才能确定正确的内部点（偶数次变换才正确）.</p><figure><img src="/image/cg/jiaodian.png" alt="区域边界顶点的求交处理" /><figcaption aria-hidden="true">区域边界顶点的求交处理</figcaption></figure><p>一个方法是计算相关边与扫描线的相对位置或拓扑关系.我们顺（逆）时针跟踪多边形边界，观察从一条边经顶点移到另一条边时端点<span class="math inline">\(y\)</span> 坐标的变化. + 若 <spanclass="math inline">\(y\)</span>坐标单调增加或减小，穿过该顶点的扫描线与多边形边界的交点数计为1 +否则，交点数计为2</p><p>另一个方法是将特殊顶点分离处理.如下图所示，我们缩短多边形某些边，以分离应计为1个交点的顶点.具体的，以顺（逆）时针方向处理整个多边形边界上的非水平边。在处理每条边时检测<strong>该边与下一条非水平边是否有单调递增或单调递减的端点y值</strong>.假如有，可将较低一条边缩短，以保证对通过连接两条边公共顶点的扫描线仅有一个交点生成：+ 当两条边的端点 <span class="math inline">\(y\)</span>值增加时，<strong>当前边</strong>较高端点 <spanclass="math inline">\(y\)</span> 值减去1. + 当端点 <spanclass="math inline">\(y\)</span>值单调递减时，<strong>紧随边</strong>较高端点的 <spanclass="math inline">\(y\)</span> 值减去1 .</p><figure><img src="/image/cg/fenli.png" alt="特殊顶点分离处理" /><figcaption aria-hidden="true">特殊顶点分离处理</figcaption></figure><h4 id="数据结构">数据结构</h4><p>我们使用<strong>有序边表</strong>和<strong>活化边表</strong>两个数据结构.</p><p>如下图所示，有序边表是按边下端点 <spanclass="math inline">\(y\)</span>坐标对非水平边进行分类的指针数族，旨在排除一些不必要的求交测试.对每条边按最小 <span class="math inline">\(y\)</span>值排序，存储在一个相应编号的扫描线位置（Y桶）,对某条特定扫描线，以从左到右的次序对边排序.在处理边时，可以缩短某些边以解决共享顶点问题.表中每个节点包括该边最大y值，下端点x值以及边斜率的倒数.</p><figure><img src="/image/cg/youxu.png" alt="有序边表" /><figcaption aria-hidden="true">有序边表</figcaption></figure><p>而活化边表由与当前扫描线相交的多边形边组成，它记录多边形<strong>边沿扫描线的交点序列</strong>.对于第 <span class="math inline">\(k\)</span>条扫描线，活化边表可从有序边表中生成： + 将Y桶中对应于当前扫描线以下的类<span class="math inline">\(c (c=1,2,…,k-1)\)</span>的所有边插入活化边表，删除满足 <spanclass="math inline">\(y_{max}&lt;y_k\)</span> 的边，其它边的x域根据<span class="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>确定交点.活化边表中的每个节点包含该边最大 <spanclass="math inline">\(y\)</span> 值、与扫描线交点的 <spanclass="math inline">\(x\)</span> 坐标值和边斜率倒数.</p><blockquote><p>ppt上写的是“其它边的x域根据 <spanclass="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>确定交点”我感觉不太对...如果有问题请向我反馈.</p></blockquote><h3 id="区域填充算法">区域填充算法</h3><p>区域填充从区域的一个内点（称为“种子点”）开始，赋予指定的颜色，然后将该颜色扩展到整个区域，是对区域重新着色的过程（改变区域的颜色或者以图像填充），对内点表示的区域进行填充为泛滥填充，而对边界表示的区域进行填充为边界填充.</p><p>区域填充算法要求区域是连通的.这个要求是自然的，因为只有在连通区域内，才有可能将种子点的颜色扩展到区域内的其它点.</p><p>区域连通性可分为4连通、8连通和16连通.</p><p>一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的4连通区域或4-邻域 <span class="math inline">\(N_4(p)\)</span>定义为(下图中标 <span class="math inline">\(r\)</span> 的像素)： <spanclass="math display">\[N4(p)={r|d_4(p,r)=1} \]</span>,即任取区域内两点，在该区域内，通过上、下、左右四个方向的运动，这两点相互可达。区域内像素距离定义为曼哈顿距离<span class="math display">\[d_4(p,r)=|x_p-x_r|+|y_p-y_r|\]</span>.</p><figure><img src="/image/cg/n4.png" alt="4-邻域" /><figcaption aria-hidden="true">4-邻域</figcaption></figure><p>一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的8连通区域或8-邻域 <span class="math inline">\(N_8(p)\)</span>定义为(图中标 <span class="math inline">\(r\)</span> 的像素)：<spanclass="math display">\[N_8(p)={r|d_8(p,r)=1}\]</span>,即任取区域内两点，通过水平、垂直、两个对角线八个方向的运动，这两点相互可达。区域内像素距离定义为棋盘距离<span class="math display">\[d8(p,r)=max(|xp-xr|, |yp-yr|)\]</span>.</p><figure><img src="/image/cg/n8.png" alt="8-邻域" /><figcaption aria-hidden="true">8-邻域</figcaption></figure><p>显然，一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的8-邻域 <span class="math inline">\(N_8(p)\)</span> 是它的4-邻域 <spanclass="math inline">\(N_4(p)\)</span> 和它的对角邻域 <spanclass="math inline">\(N_D(p)\)</span> 的并集.</p><p>一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的16连通区域或16-邻域 <span class="math inline">\(N_{16}(p)\)</span>定义为 <span class="math display">\[N_{16}(p)= N_8(p)\cup N_k(p)\]</span> 即任取区域内两点，通过十六个方向的运动相互可达.其中，马步(或骑士Knight)邻域 <span class="math inline">\(N_k(p)\)</span>定义为 <span class="math display">\[N_k(p)={r|d_k(p,r)=1}\]</span>.马步距离是国际象棋棋盘上马从一格运动到另一格所需步数计算，也是网格上两点间最短k-通路的长度.</p><figure><img src="/image/cg/n16.png" alt="16-邻域" /><figcaption aria-hidden="true">16-邻域</figcaption></figure><p>一个4连通区域也可以看作是8连通区域，但它作为4连通区域和8连通区域的边界是不同的(4连通比8连通约束紧).</p><ul><li>8连通区域中，由于区域内的两个像素可以通过对角线相通，因此区域边界上的像素不能通过对角线相连，否则填充会溢出到区域外（欠约束）.所以8连通区域的边界必须是4连通.</li><li>4连通区域，其边界像素为4连通或8连通都可以.</li><li>8连通区域能用来填充更复杂的图形.</li></ul><p>考虑了连通性，我们来思考内外点测试.</p><p>区域填充必须从一个内点开始，因此需要区分区域的内点和外点.简单多边形的内点是容易区分的，但复杂多边形较困难.关于内外点测试我们有<strong>奇偶规则</strong>和<strong>非零环绕数规则</strong>.对于标准多边形和其它简单形状，非零环绕数规则和奇偶规则给出相同的结果.但对于复杂形状，两种方法会产生不同的内部和外部区域,非零环绕数规则比奇偶规则更通用.</p><p>奇偶规则又称射线法，做法是从位置p到对象坐标范围以外远距离画一射线（不与顶点相交），并统计沿该射线与区域各边的交点数目：</p><ul><li>假如与这条射线相交的多边形边数为奇数，则p是内部点；</li><li>否则，p是外部点.</li></ul><p>环绕数是指多边形边以逆时针方向环绕某一特定点的次数，而二维物体的内部点具有环绕数为非零值.</p><p>非零环绕数规则:</p><ul><li>将环绕数初始化为零，再假想从任意位置P画一射线(不与多边形任何顶点相交)</li><li>当从P点沿射线方向移动时，对在每个方向上穿过射线的边计数：<ul><li>当多边形从右到左穿过射线时，环绕数加1</li><li>当多边形从左到右穿过射线时，环绕数减1</li><li>所有穿过的边都计数后的环绕数值决定P的相对位置</li></ul></li></ul><p>那我们怎么计算环绕数呢？</p><p>叉乘法：将从 <span class="math inline">\(P\)</span> 点出发的射线向量<span class="math inline">\(u\)</span> 与穿过射线的每条边的边向量 <spanclass="math inline">\(e\)</span> 叉乘</p><ul><li>假如对某一特定边，积 <span class="math inline">\(u×e\)</span> 的元素<span class="math inline">\(z\)</span>为正，那么，该边从右到左穿过射线，环绕数加1</li><li>否则，该边从左到右穿越射线，环绕数减1</li></ul><p>点积法：建立一个垂直于 <span class="math inline">\(u\)</span> 且从<span class="math inline">\(P\)</span> 沿 <spanclass="math inline">\(u\)</span> 方向看是从右到左指向的向量.</p><ul><li>假如垂直向量与边向量的点积 <span class="math inline">\(v •e\)</span> 为正，那么，该边从右向左穿越射线，环绕数加1</li><li>否则，该边从左至右穿越射线，环绕数则减1</li></ul><p><strong>递归边界填充</strong>：从区域种子点开始，根据内部像素连通性检测相邻位置与边界颜色不同的像素，用填充颜色涂色；递归扩展到整个区域，直到检测完区域边界内的所有像素.</p><p><strong>扫描边界填充</strong>：通过沿扫描线填充水平像素段来代替处理4连通或8-连通相邻点.从种子点开始，首先填该像素所在扫描行的连续像素段,然后将相邻扫描线上（上下扫描线）各段的起始/末尾位置进栈，这些水平段分别被用区域边界颜色显示的像素包围.从栈顶逐步取出开始点/末点(先进后出)，填充该水平段像素并重复上述过程.</p><p><strong>泛滥填充</strong>：区域内部用单一颜色定义的区域填充. +递归填充：种子点开始，按像素颜色及连通性，递归检测和扩展区域内部像素，将填充颜色赋给这些像素，直到所有内部点均着色.+ 扫描转换填充：从每个水平区间的第一个位置开始，按扫描线逐步将区域内扫描线上像素颜色替换为填充颜色，直到所有内部点均被着色.</p><h3 id="扫描转换vs区域填充">扫描转换vs区域填充</h3><figure><img src="/image/cg/scanvstc.png" alt="扫描转换对比区域填充" /><figcaption aria-hidden="true">扫描转换对比区域填充</figcaption></figure><h3 id="图像填充算法">图像填充算法</h3><p>填充图元有两大类方式：</p><ul><li>均匀着色区域<ul><li>扫描填充图元</li><li>区域填充图元</li></ul></li><li>图形填充区域<ul><li>位图不透明方式</li><li>位图透明方式</li><li>像素图填充方式</li></ul></li></ul><p>图像填充区域与均匀着色区域的差异在于：每个像素的颜色如何确定.</p><ul><li>均匀着色区域：像素的颜色由用户指定.</li><li>图像填充区域：像素的颜色从图像种获得.<ul><li>区域内某像素：首先查询它对应位图或像素图中的像素单元，再根据填充方式以合适的像素颜色值显示该像素单元.</li></ul></li></ul><p>我们将图像分为<strong>位图</strong>和<strong>像素图</strong>两大类.位图是只有0/1两种值的二值图像，有两种填充方式：透明方式和不透明方式.<strong>透明方式</strong>只覆盖1对应的像素（前景色），0对应的像素保持原样.<strong>不透明方式</strong>1用前景色，0用背景色，全部覆盖.而像素图是多值图像（如RGB彩色图像），只有不透明方式,也即直接使用图像本身的颜色值覆盖. 但是我们可以用像素图模拟位图行为：</p><ul><li>可以按位图的两种方式来解释像素图：<ul><li>不透明方式：把像素值视为0/1，1-&gt;前景色，0-&gt;背景色</li><li>透明方式：把像素值视为0/1，1-&gt;前景色，0-&gt;保持原样</li></ul></li><li>或者直接按像素图本身的颜色值显示</li></ul><p>通常来说，用来填充区域的图像较小，不足以填充整个区域，于是我们有了铺瓦式填充.我们使图像在水平和垂直方向上周期性排列，直到所定义的区域全被不重叠的图像所覆盖.</p><p>关于图像填充效果，ppt讲了两类，个人感觉还算清楚，此处直接放图.</p><figure><img src="/image/cg/xiaoguo.png" alt="填充效果" /><figcaption aria-hidden="true">填充效果</figcaption></figure><h2 id="基本几何变换">基本几何变换</h2><h3 id="二维几何变换">二维几何变换</h3><h4 id="平移与旋转">平移与旋转</h4><p>将物体沿直线路径从一个坐标位置到另一个坐标位置重定位，原始位置 <spanclass="math inline">\((x,y)\)</span> 加上平移距离 <spanclass="math inline">\(t_x,t_y\)</span> 即可得到一个新的坐标位置 <spanclass="math inline">\((x&#39;,y&#39;)\)</span>，有 <spanclass="math display">\[P&#39;=P+T\]</span>.</p><ul><li>直线段：平移两端点然后重画端点间线段.</li><li>多边形：平移各顶点坐标，生成新的多边形.</li><li>圆或椭圆：平移中心坐标并在新位置重画图形.</li><li>曲线：平移定义曲线的坐标位置，用新的坐标位置重构曲线.</li></ul><p>物体沿着 <span class="math inline">\(xy\)</span>平面内圆弧路径重定位，指定旋转基准点 <spanclass="math inline">\((x_r,y_r)\)</span> 和 旋转角 <spanclass="math inline">\(\theta\)</span> , 逆时针旋转为正,绕通过基准点且垂直于 <span class="math inline">\(xy\)</span>平面的旋转轴旋转.</p><p>首先考虑基准点为坐标原点时的转换方程，有 <spanclass="math inline">\(x&#39;=x cos\theta - y sin\theta,y&#39;=xsin\theta + ycos\theta\)</span>. 旋转矩阵为 <spanclass="math display">\[\begin{bmatrix}cos \theta &amp;-sin\theta\\sin \theta &amp; cos\theta\\\end{bmatrix}\]</span></p><p>而围绕任意基准点，有 <span class="math display">\[x&#39;=x_r+(x-x_r)cos\theta -(y-y_r)sin\theta\\y&#39;=y_r+(x-x_r)sin\theta +(y-y_r)cos\theta\]</span></p><p>依旧是刚体变换.</p><h4 id="缩放与错切">缩放与错切</h4><p>相对于原点的缩放：</p><p><span class="math display">\[x&#39;=x \cdot s_x, y&#39;=y\cdot s_y\]</span></p><p>也即</p><span class="math display">\[P&#39;= SP\]</span> ,其中$ S=<span class="math display">\[\begin{bmatrix}s_x&amp;0\\0&amp;s_y\end{bmatrix}\]</span><p>$.</p><p>相对于固定点 <span class="math inline">\((x_f,y_f)\)</span> 的缩放，<span class="math display">\[x&#39;-x_f = (x-x_f)s_x\\y&#39;-y_f = (y-y_f)s_y\]</span> 有 <span class="math display">\[x&#39; = xs_x+x_f(1-s_x)\\y&#39; = ys_y+y_f(1-s_y)\]</span>.</p><p>错切变换会使物体形状发生变化，错切过的物体由相对滑动的内部夹层组成.</p><figure><img src="/image/cg/cuoqie.png" alt="相对x方向的错切" /><figcaption aria-hidden="true">相对x方向的错切</figcaption></figure><p>相对于 <span class="math inline">\(x\)</span> 轴 <spanclass="math inline">\(x\)</span> 方向的错切: <spanclass="math display">\[x&#39;=x+sh_x \cdot y, y&#39;=y\]</span></p><p>相对于 <span class="math inline">\(y=y_{ref}\)</span> 轴 <spanclass="math inline">\(x\)</span> 方向的错切: <spanclass="math display">\[x&#39;=x+sh_x \cdot (y-y_{ref}), y&#39;=y\]</span></p><p>相对于 <span class="math inline">\(x=x_{ref}\)</span> 轴 <spanclass="math inline">\(u\)</span> 方向的错切: <spanclass="math display">\[x&#39;=x, y&#39;=y+sh_y \cdot (x-x_{ref})\]</span>.</p><h4 id="齐次坐标">齐次坐标</h4><p>用 <span class="math inline">\(n+1\)</span> 维表示 <spanclass="math inline">\(n\)</span> 维, 用 <spanclass="math inline">\((x_h,y_h,h)\)</span> 表示 <spanclass="math inline">\((x,y)\)</span> ,这能帮我们把所有的几何变换方程表示为矩阵乘法，通过左乘变换矩阵实现复合变换.</p><figure><img src="/image/cg/qici.png" alt="变换的齐次坐标表示" /><figcaption aria-hidden="true">变换的齐次坐标表示</figcaption></figure><h4 id="对称反射变换">对称/反射变换</h4><ul><li>关于 <span class="math inline">\(x\)</span> 轴 、 <spanclass="math inline">\(y\)</span> 轴 、 原点的反射.</li><li>ppt提了嘴关于 <span class="math inline">\(xy\)</span>平面任意直线，但没给出变换矩阵.</li></ul><h4 id="仿射变换">仿射变换</h4><p>二维仿射变换允许图形在两个方向上任意伸缩，但仍保持平直性和平行性.</p><p>变换公式 <span class="math display">\[x&#39;=a_{xx} x+a_{xy} y+b_x\\y&#39;=a_{yx}x+a_{yy}y+b_y\]</span>.</p><p>上述变换都是仿射变换的特例,任何常用的仿射变换都可表示成上述五种变换的组合.</p><h3 id="三维几何变换">三维几何变换</h3><h4 id="平移与缩放">平移与缩放</h4><p>在二维层次加上 <span class="math inline">\(z\)</span>坐标就很自然得到了三维变换.</p><figure><img src="/image/cg/3dts.png" alt="三维平移与缩放" /><figcaption aria-hidden="true">三维平移与缩放</figcaption></figure><h4 id="旋转">旋转</h4><p>旋转的扩展就没有那么简单了，这是因为二维旋转只需要考虑沿垂直于 <spanclass="math inline">\(xy\)</span>平面的旋转轴而三维空间中可选择空间任意方向作为旋转轴，大多数软件将三维旋转作为绕三个坐标轴的二维旋转的复合变换来处理.</p><p>绕 <span class="math inline">\(z\)</span> 轴旋转变换矩阵 <spanclass="math display">\[\begin{bmatrix}cos \theta &amp;-sin\theta&amp;0&amp;0\\sin \theta &amp;cos\theta&amp;0&amp;0\\0 &amp;0&amp;1&amp;0\\0 &amp;0&amp;0&amp;1\\\end{bmatrix}\]</span></p><p>绕 <span class="math inline">\(x\)</span> 轴旋转变换矩阵 <spanclass="math display">\[\begin{bmatrix}1 &amp;0&amp;0&amp;0\\0&amp;cos\theta&amp;-sin\theta&amp;0\\0 &amp;sin\theta&amp;cos \theta&amp;0\\0 &amp;0&amp;0&amp;1\\\end{bmatrix}\]</span></p><p>绕 <span class="math inline">\(y\)</span> 轴旋转变换矩阵 <spanclass="math display">\[\begin{bmatrix}cos \theta &amp;0&amp;sin\theta&amp;0\\0 &amp;1&amp;0&amp;0\\-sin\theta &amp;0&amp;cos \theta&amp;0\\0 &amp;0&amp;0&amp;1\\\end{bmatrix}\]</span></p><p>绕任意三维轴的变换矩阵通过复合变换得到 + 平移旋转轴至穿过坐标原点 +旋转轴绕某坐标轴旋转使其于另一坐标轴重合 +根据指定旋转角求出绕坐标轴的旋转矩阵 +将旋转轴变回原位置，得到逆矩阵序列.</p><figure><img src="/image/cg/any3dr.png" alt="绕任意三维轴旋转一般步骤" /><figcaption aria-hidden="true">绕任意三维轴旋转一般步骤</figcaption></figure><blockquote><p>计算机图形学（第三版）有详细介绍</p></blockquote><hr /><p><mark>以下内容作者为fjz，感谢jzgg的辛苦付出</mark></p><h2 id="二维裁剪">二维裁剪</h2><h3 id="图形裁剪的概念">图形裁剪的概念</h3><ul><li><strong>裁剪</strong>：识别图形在指定区域的内、外部分的过程。</li><li><strong>指定区域</strong>：裁剪窗口，用来裁剪对象的区域。</li></ul><h3 id="裁剪窗口类型">裁剪窗口类型</h3><ul><li>裁剪窗口可以是直线边界的多边形，也可以是曲线边界。</li></ul><h3 id="裁剪策略">裁剪策略</h3><ul><li><strong>窗口边界裁剪</strong>：在世界坐标系中对图形进行裁剪。<ul><li>通常裁剪窗口等同于观察窗口，只有观察窗口内的部分会被映射到设备空间中。</li></ul></li><li><strong>视区边界裁剪</strong>：图形先从世界坐标系映射到规格化坐标系或设备坐标系，再进行裁剪。<ul><li>裁剪窗口等同于设备视区，需要将所有对象（包括观察窗口外的部分）变换到设备坐标系。</li></ul></li></ul><h3 id="裁剪优化">裁剪优化</h3><ul><li>合并观察变换和几何变换可以减少计算量。</li><li>在光栅系统中，裁剪算法可与扫描转换过程结合，提高效率。</li></ul><h3 id="点裁剪">点裁剪</h3><p>点裁剪非常简单，只需判断点 $ P(x, y) $ 是否在裁剪矩形内：</p><ul><li>$ x_{min} x x_{max} $</li><li>$ y_{min} y y_{max} $</li></ul><p>满足上述条件的点予以保留。</p><hr /><h3 id="线段裁剪">线段裁剪</h3><p>线段裁剪通常包括两个步骤：</p><ol type="1"><li><p><strong>关系测试</strong>：判断线段与裁剪窗口的关系</p><ul><li>完全在窗口内</li><li>完全在窗口外</li><li>部分在窗口内（需进一步处理）</li></ul></li><li><p><strong>交点计算</strong>：对于部分在窗口内的线段，计算其与裁剪边界的交点。</p></li></ol><h4 id="cohen-sutherland-算法">Cohen-Sutherland 算法</h4><p><strong>核心思想：</strong> 通过对端点编码，减少计算交点的次数。</p><ul><li>区域码采用四位二进制（a4a3a2a1）：<ul><li>a4：上边界</li><li>a3：下边界</li><li>a2：右边界</li><li>a1：左边界</li><li>若某位为1，表示端点落在对应区域之外。</li></ul></li></ul><p><strong>步骤：</strong></p><ol type="1"><li><p>计算两个端点的区域码：</p><ul><li>$ x &lt; x_{min} $ 则 a1 = 1</li><li>$ x &gt; x_{max} $ 则 a2 = 1</li><li>$ y &lt; y_{min} $ 则 a3 = 1</li><li>$ y &gt; y_{max} $ 则 a4 = 1</li></ul></li><li><p>分类处理：</p><ol type="1"><li>两个端点区域码均为 0000，线段完全在窗口内，无需裁剪。</li><li>两个区域码按位与后不为 0000，线段完全在窗口外，全部裁剪。</li><li>其他情况，依次按左右上下的顺序求出交点，每次舍弃外部线段，保留可能的内部线段，直到不能继续为止。<ul><li>求交点时可用参数方程： $ x = x_1 + u(x_2 - x_1) $ $ y = y_1 + u(y_2- y_1) $ 其中参数 $ u $ 在 0 到 1 之间时交点</li></ul></li></ol></li></ol><h4 id="梁友栋-barsky-参数裁剪算法">梁友栋-Barsky 参数裁剪算法</h4><p><strong>核心思想：</strong>利用参数方程，将线段与裁剪窗口的关系转化为一维参数区间的求交问题（降维），从而高效地计算裁剪结果。</p><ul><li>将线段表示为参数方程：<ul><li>$ x = x_1 + u(x_2 - x_1) $</li><li>$ y = y_1 + u(y_2 - y_1) $</li><li>其中 $ u $ 的取值范围为 [0, 1]，分别对应线段的起点和终点。</li></ul></li></ul><p><strong>步骤：</strong>（直观理解：根据参数方程不断更新参数，最终利用参数得到裁剪后线段）</p><ol type="1"><li><p>初始化<spanclass="math inline">\(u_{in}=0,u_{out}=1\)</span></p></li><li><p>对于每一条边界，计算参数 $ p $ 和 $ q $：</p><ul><li>$ p_1 = -(x_2 - x_1) <span class="math inline">\(，\)</span> q_1 =x_1 - x_{min} $（左边界）</li><li>$ p_2 = x_2 - x_1 <span class="math inline">\(，\)</span> q_2 =x_{max} - x_1 $（右边界）</li><li>$ p_3 = -(y_2 - y_1) <span class="math inline">\(，\)</span> q_3 =y_1 - y_{min} $（下边界）</li><li>$ p_4 = y_2 - y_1 <span class="math inline">\(，\)</span> q_4 =y_{max} - y_1 $（上边界）</li></ul></li><li><p>对每个边界，判断：</p><ul><li>若 $ p_i = 0 $ 且 $ q_i &lt; 0$，线段平行且在边界外，直接舍弃。</li><li>若 $ p_i $，计算 $ r = q_i / p_i $：<ul><li>若 $ p_i &lt; 0 $，更新 $ u_{in} = (u_{in}, r) $</li><li>若 $ p_i &gt; 0 $，更新 $ u_{out} = (u_{out}, r) $</li></ul></li></ul></li><li><p>最终判断：</p><ul><li>若 $ u_{in} &gt; u_{out} $，线段完全在窗口外，舍弃。</li><li>否则，取 $ u_{in} $ 和 $ u_{out} $ 之间的部分作为裁剪后的线段。</li></ul></li></ol><p><strong>优点：</strong></p><ul><li>求交次数减少（更新参数只需一次除法，最后的交点仅需一次计算，而之前的即使对完全落在窗口外的一条线段也需要反复求交点，且每次求交点都需要除法和乘法）</li></ul><h4 id="其他">其他</h4><ol type="1"><li><p><strong>Nicholl-Lee-Nicholl 算法</strong></p><p><strong>核心思想：</strong><br />通过对线段与裁剪窗口的空间关系进行分类，减少不必要的交点计算，提高裁剪效率。</p><ul><li>首先测试一个端点所在区域，然后以窗口的四个角点为基准射出四条射线，将空间划分为更多小区域。利用这些小区域，根据两个端点的相对位置可以直接判断线段与窗口的相交关系，无需多次求交。</li><li>适用于端点分布较为分散的情况，能显著减少与窗口边界的交点计算次数。</li></ul><p><strong>特点：</strong></p><ul><li>相比 Liang-Barsky 算法比较和除法次数减少，效率更高。</li><li>仅仅适用于二维（前两个可以拓展到三维）</li></ul></li><li><p><strong>非矩形裁剪窗口的相关算法</strong></p><p><strong>核心思想：</strong><br />针对非矩形（如多边形或曲线边界）裁剪窗口，采用相应的扩展算法进行处理。</p><ul><li>对于<strong>凸多边形</strong>窗口，可扩展 Liang-Barsky算法，按多边形的各边坐标范围处理线段。</li><li>对于<strong>凹多边形</strong>窗口，通常先将其分解为一组凸多边形，再分别进行裁剪。</li><li>对于<strong>曲线边界</strong>（如圆形窗口），求交点涉及非线性方程，计算速度较慢。可先用外接矩形进行初步裁剪，再进一步判断与曲线边界的精确关系（如计算圆心到线段的距离等）。</li></ul><p><strong>优点：</strong></p><ul><li>能处理任意形状的裁剪窗口，适用范围广。</li><li>支持复杂图形与窗口的裁剪需求。</li></ul></li></ol><h3 id="多边形裁剪">多边形裁剪</h3><p>多边形由线段构成，基本思想与线段裁剪一致。但由于多边形是封闭的二维区域，裁剪时会遇到以下问题：</p><ul><li>对于<strong>凸多边形</strong>，裁剪后边界可能显示为一系列不连接的直线段，需要用窗口边界的一些部分将其封闭。</li><li>对于<strong>凹多边形</strong>，裁剪后可能被分割成多个小多边形，需确定这些小多边形的边界。</li></ul><hr /><h4 id="sutherland-hodgman-算法">Sutherland-Hodgman 算法</h4><ul><li><p><strong>核心思想：</strong><br />逐边裁剪。将多边形的所有顶点依次与每一条窗口边界进行裁剪，输出新的顶点序列，最终得到裁剪后的多边形。</p><p>直观地说，就是记录端点序列，按照顺时针或逆时针顺序，逐边裁剪，裁剪后得到新的端点序列按相同顺序连接即可。</p></li><li><p><strong>适用范围：</strong><br />适用于凸多边形窗口的裁剪，算法简单高效。<br />对于凹多边形，裁剪后可能会出现多余的线段。</p></li></ul><hr /><h4 id="weiler-atherton-算法">Weiler-Atherton 算法</h4><ul><li><p><strong>核心思想：</strong><br />适用于凹多边形或复杂多边形的裁剪。通过记录多边形与窗口的交点，沿多边形和窗口边界交替遍历，构建裁剪后的多边形或多边形集合。</p><p>直观理解：算法根据交点处多边形顶点穿越边界的方式（由内到外或由外到内）来区分多个小多边形。</p></li><li><p><strong>优点：</strong><br />能正确处理裁剪后出现的多个多边形区域，适合复杂情况。</p></li></ul><hr /><h4 id="其他-1">其他</h4><p>多边形裁剪的其它相关问题包括：</p><ul><li>多边形窗口的裁剪</li><li>文字的裁剪</li><li>曲线边界的裁剪</li><li>外部裁剪</li></ul><hr /><h2 id="曲线与曲面">曲线与曲面</h2><h3 id="基本概念">基本概念</h3><ul><li><strong>曲线/曲面</strong>：空间中点的连续集合。曲线可看作参数区间到空间的映射，曲面是二维参数域到空间的映射。</li><li><strong>参数化表示</strong>：用参数方程描述曲线/曲面，便于建模和计算。</li></ul><hr /><h3 id="样条曲线与样条曲面">样条曲线与样条曲面</h3><ul><li><strong>样条曲线</strong>：由分段多项式拼接而成，常用三次多项式，连接处满足一定的连续性（如C1、C2）。</li><li><strong>控制点</strong>：决定曲线形状，移动控制点可调整曲线。</li><li><strong>插值样条</strong>：曲线通过所有控制点，整体性强但局部性差。</li><li><strong>逼近样条</strong>：曲线不必通过所有控制点，便于局部调整。</li></ul><hr /><h4 id="曲线曲面连接的连续性类型">曲线曲面连接的连续性类型</h4><ul><li><p><strong>参数连续性</strong>：通过在曲线段公共部分匹配参数导数来建立。</p><ul><li><strong>0阶参数连续性（C0连续）</strong>：曲线相连，两个曲线段在连接点处的坐标值相等。</li><li><strong>一阶参数连续性（C1连续）</strong>：两个相邻曲线段在连接点处有相同的一阶导数（切线）。</li><li><strong>二阶参数连续性（C2连续）</strong>：两个曲线段在连接点处有相同的一阶和二阶导数。</li><li><strong>高阶参数连续性</strong>：可类似定义。</li></ul></li><li><p><strong>几何连续性</strong>：两曲线段在相交处的参数导数成比例，而不是相等。</p><ul><li><strong>0阶几何连续性（G0）</strong>：与C0相同，即两个曲线段在公共点处有相同的坐标。</li><li><strong>一阶几何连续性（G1）</strong>：一阶导数在两个相邻段的交点处成比例，切向量大小不一定相等。</li><li><strong>二阶几何连续性（G2）</strong>：一次和二次导数均成比例，简称曲率连续，两个曲线段在交点处的曲率相等。</li></ul></li></ul><hr /><h4 id="曲线曲面的基函数表示">曲线曲面的基函数表示</h4><ul><li><p>曲线曲面可由一组基函数及其相联系的系数矢量给出： <spanclass="math display">\[p(\cdot) = \sum_{i=0}^n a_i \phi_i(\cdot)\]</span></p><ul><li><span class="math inline">\(a_i\)</span>：系数矢量；</li><li><span class="math inline">\(p(\cdot)\)</span> 与 <spanclass="math inline">\(\phi_i(\cdot)\)</span> 根据曲线和曲面而有所不同：<ul><li><strong>曲线</strong>：<span class="math inline">\(p(\cdot)\)</span>与 <span class="math inline">\(\phi_i(\cdot)\)</span>分别为单参数的矢量函数及以该参数为变量的基函数；</li><li><strong>曲面</strong>：<span class="math inline">\(p(\cdot)\)</span>与 <span class="math inline">\(\phi_i(\cdot)\)</span>分别为双参数的矢量函数及以双参数为变量的基函数。</li></ul></li></ul></li><li><p>表示曲线、曲面的数学方法不同，主要体现在所采用的基函数不同。</p></li><li><p>基函数一旦确定，系数矢量也就完全定义了曲线或曲面。</p></li></ul><hr /><h3 id="常见插值样条曲线类型">常见插值样条曲线类型</h3><h4 id="三次自然插值样条">三次自然插值样条</h4><p>假设有 $ n+1 $ 个控制点，坐标分别为 $ P_k = (x_k, y_k,z_k), k=0,1,2,,n $。用下列方程组描述拟合每对控制点的参数三次多项式：</p><ul><li>$ x(u) = a_x u^3 + b_x u^2 + c_x u + d_x $</li><li>$ y(u) = a_y u^3 + b_y u^2 + c_y u + d_y $</li><li>$ z(u) = a_z u^3 + b_z u^2 + c_z u + d_z $</li></ul><p>每段曲线都需确定 4 个多项式系数，所以一共需要 $ 4n $个方程来确定系数。</p><ul><li>考虑 C2连续性（公共边界处有相同的一阶与二阶导数），每一个内控制点上都需要考虑两侧的曲线段连续，从而有$ 2n-2 $ 个方程。</li><li>又因为每个内控制点两侧的曲线段都需要通过该点，又有 $ 2n-2 $个方程。</li><li>端点 $ P_0 $ 和 $ P_n $ 处各有两个方程，并且这两个地方的二阶导数为0，从而得到最后 4 个方程。</li></ul><p>或者可以直接添加两个虚拟控制点 $ P_{-1} $ 和 $ P_{n+1}$，这样所有的控制点都是内控制点。</p><p><strong>缺点：</strong>控制点上任何一个改动都会影响整个曲线（不允许局部控制，不给出完整的新的控制点，不可能部分构造曲线</p><h4 id="hermite-曲线">Hermite 曲线</h4><ul><li>Hermite 样条是分段三次多项式，并且在每个控制点有给定切线。</li><li>每个曲线段仅依赖于端点约束，可局部调整。</li></ul><p>在控制点 $ P_k $ 和 $ P_{k+1} $ 间的曲线段是参数三次函数 $ p(u)$，Hermite 曲线段的边界条件为：</p><ul><li>$ P(0) = P_k $</li><li>$ P'(0) = DP_k $</li><li>$ P(1) = P_{k+1} $</li><li>$ P'(1) = DP_{k+1} $</li></ul><p>其中 $ DP_k $ 和 $ DP_{k+1} $ 是在控制点 $ P_k $ 和 $ P_{k+1} $处相应的导数值（曲线的斜率）。</p><p>Hermite 曲线段的向量方程为：</p><p><span class="math display">\[P(u) = a u^3 + b u^2 + c u + d,\quad 0 \leq u \leq 1\]</span></p><ul><li>$ P $ 的分量 $ x $ 为：$ x(u) = a_x u^3 + b_x u^2 + c_x u + d_x$</li><li>对分量 $ y $ 和 $ z $ 具有同样形式。</li></ul><p>将 $ u = 0 $ 和 $ u = 1 $ 代入 Hermite 曲线段矩阵方程，可将 Hermite边界条件表示为矩阵形式。</p><p><span class="math display">\[\begin{bmatrix}P_k \\P_{k+1} \\DP_k \\DP_{k+1} \\\end{bmatrix}=\begin{bmatrix}0 &amp; 0 &amp; 0 &amp; 1 \\1 &amp; 1 &amp; 1 &amp; 1 \\0 &amp; 0 &amp; 1 &amp; 0 \\3 &amp; 2 &amp; 1 &amp; 0 \\\end{bmatrix}\begin{bmatrix}a \\b \\c \\d \\\end{bmatrix}\]</span></p><p>$ M_H $ 是 Hermite 矩阵，是边界约束矩阵的逆矩阵。使用边界条件，矩阵方程可以写成：</p><p><span class="math display">\[P(u) = [u^3\ u^2\ u\ 1] \cdot M_H^{-1} \cdot\begin{bmatrix}P_k \\ P_{k+1} \\ DP_k \\ DP_{k+1}\end{bmatrix}\]</span></p><p>算出上述方程中的矩阵乘积且合并满足边界约束的函数，得到多项式形式（混合函数表达式）：</p><p><span class="math display">\[P(u) = P_k (2u^3 - 3u^2 + 1) + P_{k+1} (-2u^3 + 3u^2) + DP_k (u^3 - 2u^2+ u) + DP_{k+1} (u^3 - u^2)\]</span></p><p>或</p><p><span class="math display">\[P(u) = P_k H_0(u) + P_{k+1} H_1(u) + DP_k H_2(u) + DP_{k+1} H_3(u)\]</span></p><ul><li>多项式 $ H_k(u) <span class="math inline">\(（\)</span> k=0,1,2,3$）称为<strong>混合函数</strong>。</li><li>它们混合了边界约束值（终点坐标和斜率）来得到曲线上每个坐标点位置。</li><li>Hermite 多项式是通过估算曲线斜率来插值的。</li><li>对于计算机图形学的大部分问题而言，除了控制点坐标外，更好的做法是<strong>不输入曲线斜率值或其它几何信息就生成样条曲线</strong>。</li><li>Cardinal 样条和 Kochanek-Bartels 样条这两种 Hermite样条的变形，仅由控制点的坐标位置计算出导数。</li></ul><h4 id="cardinal-样条">Cardinal 样条</h4><ul><li><strong>定义</strong>：不需手动指定切线，斜率由相邻控制点自动计算，带张力参数t控制曲线松紧。</li></ul><p>Cardinal 样条由四个连续控制点给出：</p><ul><li>中间两个控制点作为曲线段的端点；</li><li>另外两个点用于计算端点的斜率。</li></ul><p>设 $ P(u) $ 是两控制点 $ P_k $ 和 $ P_{k+1} $间的参数三次函数式，则从 $ P_{k-1} $ 到 $ P_{k+2} $ 的四个控制点用于建立Cardinal 样条段的边界条件：</p><ul><li>$ P(0) = P_k $</li><li>$ P'(0) = (P_{k+1} - P_{k-1}) $</li><li>$ P(1) = P_{k+1} $</li><li>$ P'(1) = (P_{k+2} - P_k) $</li></ul><p>其中，控制点 $ P_k $ 和 $ P_{k+1} $ 处的斜率分别与弦 $ P_{k-1}P_{k+1}$ 和 $ P_kP_{k+2} $ 成正比。 参数 $ t $ 控制 Cardinal样条与输入控制点间的松紧程度，称为张量（tension）参数。</p><p>用类似 Hermite 样条的方法，可将边界条件转换成矩阵形式</p><p><span class="math display">\[P(u) = [u^3\ u^2\ u\ 1] \cdot M_c \cdot\begin{bmatrix}P_{k-1} \\ P_k \\ P_{k+1} \\ P_{k+2}\end{bmatrix}\]</span></p><p>将矩阵方程展开成多项式形式，可得到混合函数表达式：</p><p><span class="math display">\[P(u) = P_{k-1}(-t u^3 + 2t u^2 - t u) + P_k[(2-t)u^3 + (t-3)u^2 + 1] +P_{k+1}[(t-2)u^3 + (2-t)u^2 + t u] + P_{k+2}(t u^3 - t u^2)\]</span></p><p>或</p><p><span class="math display">\[P(u) = P_{k-1} \cdot CAR_0(u) + P_k \cdot CAR_1(u) + P_{k+1} \cdotCAR_2(u) + P_{k+2} \cdot CAR_3(u)\]</span></p><p>其中，多项式 $ CAR_k(u) <span class="math inline">\(（\)</span>k=0,1,2,3 $）称为 Cardinal混合函数，它们混合了边界约束值（终点坐标和斜率）来得到曲线上每个坐标点的位置。</p><h4 id="kochanek-bartels-样条">Kochanek-Bartels 样条</h4><ul><li><strong>定义</strong>：在Cardinal基础上增加偏离（bias）和连续性（continuity）参数，能灵活控制曲线弯曲和连接处的连续性。</li></ul><p>由四个连续控制点 $ P_{k-1} <span class="math inline">\(、\)</span>P_k <span class="math inline">\(、\)</span> P_{k+1} $ 和 $ P_{k+2} $定义，$ P_k $ 和 $ P_{k+1} $ 间的 Kochanek-Bartels曲线段的边界条件为：</p><ul><li><p>$ P(0) = P_k $</p></li><li><p>$ P(1) = P_{k+1} $</p></li><li><p>$ P^_{in}(0) = (1-t)[(1+b)(1-c)(P_k - P_{k-1}) +(1-b)(1+c)(P_{k+1} - P_k)] $</p></li><li><p>$ P^_{out}(1) = (1-t)[(1+b)(1+c)(P_{k+1} - P_k) +(1-b)(1-c)(P_{k+2} - P_{k+1})] $</p></li><li><p>其中：</p><ul><li>$ t $ 是张量（tension）参数，控制曲线段的松紧程度；</li><li>$ b $是偏离（bias）参数，用于调整曲线段在端点处的弯曲程度，曲线段可以偏向一个端点或另一个端点；</li><li>$ c $是连续性（continuity）参数，控制切向量在曲线段边界处的连续性。若 $ c $取非零值，则曲线在曲线段边界处的斜率不连续。</li></ul></li><li><p>Kochanek-Bartels样条的设计主要用于动画路径模拟，特别是当物体运动有突变时，可以通过设置参数$ c $ 为非零值来模拟这种突变效果</p></li></ul><h4 id="省流版总结">省流版总结</h4><ul><li><strong>三次插值样条</strong>：通过所有控制点并在点上超级连续，整体性强但不具备局部性，修改一个点会影响整条曲线，适合数据平滑但不便于局部调整。</li><li><strong>Hermite插值样条</strong>：每段由端点位置和切线（斜率）决定，支持局部调整，适合需要指定端点斜率的场景。</li><li><strong>Cardinal插值样条</strong>：不需手动指定切线，斜率由相邻控制点自动计算，带有张量参数$ t $ 控制曲线松紧，适合一般插值需求。</li><li><strong>Kochanek-Bartels样条</strong>：在Cardinal基础上增加偏离b和连续性c参数，能灵活控制曲线弯曲和连接处的连续性，适合动画路径等需要特殊形状控制的场合。。</li></ul><hr /><p>既然插值样条曲线的共同特点是<strong>生成的曲线通过所有给定的“型值点”</strong>，存在如下问题：</p><ul><li><strong>插值曲线不具有局部性</strong>，无法使设计和修改结果灵活直观地得到反映。</li><li><strong>初始型值点往往不精确</strong>，修改型值点意味着必须重新生成曲线，且结果难以预测。实际使用中，仅为外观而逐点插值计算很不合算。</li></ul><p><strong>下面是曲线/曲面的拟合生成</strong></p><h3 id="bézier-曲线">Bézier 曲线</h3><ul><li><p><strong>定义</strong>：- 给定 $ n+1 $ 个控制点：$ P_k = (x_k,y_k, z_k) <span class="math inline">\(，\)</span> k=0,1,2,,n $</p></li><li><p>这些点通过混合函数产生位置向量 $ P(u) $，描述 $ P_0 $ 和 $ P_n $间的 Bézier 多项式路径（Bézier 曲线）：</p><p><span class="math display">\[P(u) = \sum_{k=0}^{n} BEZ_{k,n}(u) \cdot P_k\]</span></p></li><li><p>其中混合函数 $ BEZ_{k,n}(u) $ 即 Bernstein 多项式。</p></li><li><p>利用 Bernstein 基函数的降（升）阶公式，可递归计算 Bézier曲线上点的坐标位置。</p></li><li><p>用递归定义 Bézier 混合函数：</p><p><span class="math display">\[BEZ_{k,n}(u) = (1-u) \cdot BEZ_{k,n-1}(u) + u \cdot BEZ_{k-1,n-1}(u)\]</span></p><p>其中：- $ BEZ_{k,k}(u) = u^k $</p><ul><li>$ BEZ_{0,k}(u) = (1-u)^k $</li><li><span class="math display">\[BEZ_{i,n}(u) = \binom{n}{i} (1-u)^{n-i}u^i,\quad 0 \leq u \leq 1,\ i=0,1,\ldots,n\]</span></li></ul></li><li><p><strong>性质：</strong></p><ul><li><strong>非负性</strong>：在区间 [0,1] 内，$ BEZ_{i,n}(u) $</li><li><strong>权和为1</strong>：<span class="math inline">\(\sum_{i=0}^nBEZ_{i,n}(u) = 1\)</span></li><li><strong>对称性</strong>：$ BEZ_{i,n}(u) = BEZ_{n-i,n}(1-u) $</li><li><strong>最大值</strong>：$ BEZ_{i,n}(u) $ 在 $ u = $处取得最大值</li><li><strong>降阶公式</strong>：n 次 Bernstein 基函数可表示为两个 n-1次基函数的线性和： <span class="math display">\[BEZ_{i,n}(u) = (1-u) BEZ_{i,n-1}(u) + u BEZ_{i-1,n-1}(u),\quad(i=0,1,\ldots,n)\]</span></li><li><strong>升阶公式</strong>：n 次 Bernstein 基函数可表示为两个 n+1次基函数的线性和。</li></ul><p><span class="math display">\[BEZ_{i,n}(u) = \frac{n+1-i}{n+1} BEZ_{i,n+1}(u) + \frac{i+1}{n+1}BEZ_{i+1,n+1}(u)\]</span></p><ul><li><strong>区间积分</strong>： <span class="math display">\[\int_0^1 BEZ_{i,n}(u) du = \frac{1}{n+1}\]</span></li><li><strong>线性无关性</strong>：<spanclass="math inline">\(\{BEZ_{i,n}(u)\}_{i=0}^n\)</span> 是 n次多项式空间的一组线性无关基函数，任何 n次多项式都可表示为它们的线性组合。</li><li><strong>导数</strong>：对 $ i=0,1,2,,n $， <spanclass="math inline">\(\frac{d}{du} BEZ_{i,n}(u) = n [BEZ_{i-1,n-1}(u) -BEZ_{i,n-1}(u)]\)</span></li></ul></li></ul><p><strong>性质：</strong></p><ul><li><p><strong>端点位置</strong>：Bézier 曲线以 $ P_0 $ 为起点，以 $ P_n$ 为终点，即</p><p><span class="math display">\[P(0) = P_0,\quad P(1) = P_n\]</span></p></li><li><p><strong>端点切矢量</strong>：Bézier曲线在起点和终点处分别与控制多边形的第一条边和最后一条边相切，其端点切矢量为</p><p><span class="math display">\[P&#39;(0) = n(P_1 - P_0),\quad P&#39;(1) = n(P_n - P_{n-1})\]</span></p></li><li><p><strong>对称性</strong>：如果保持全部控制点位置不变，但次序颠倒（即$ P_k $ 变为 $ P_{n-k} $），则 Bézier曲线形状不变，但参数变化方向相反（u变为1-u）。</p></li><li><p><strong>仿射不变性</strong>：Bézier 曲线具有仿射不变性。</p></li><li><p><strong>凸包性</strong>：Bézier曲线始终位于其控制顶点的凸包内。凸包性将曲线限制在一定范围内，使曲线形状控制更加方便。</p></li><li><p><strong>直线再生性</strong>：若所有控制顶点 $ P_0, P_1, , P_n $共线，则 Bézier 曲线必为一条直线。</p></li><li><p><strong>平面曲线的保型性</strong>：若 Bézier 曲线的控制顶点 ${P_k} $ 全部位于同一平面内，则该 Bézier 曲线也是平面曲线。</p><ul><li><strong>保凸性</strong>：如果控制多边形是凸的，则 Bézier曲线也是凸的。</li><li><strong>变差缩减性</strong>：平面内任一直线与 Bézier曲线的交点数不多于该直线与其控制多边形的交点数，即 Bézier曲线比其控制多边形波动小，更加光顺。</li></ul></li><li><p><strong>拟局部性</strong>：</p><ul><li>Bézier 曲线不具备严格的局部性，但具备拟局部性。</li><li>移动一个控制顶点 $ P_k $ 时，对应参数 $ u = k/n $处的曲线点变动最大，远离该参数的曲线点变动越来越小。</li><li>也可引入其它参数来调整 Bézier 曲线的“张力”和“偏移”。</li></ul></li></ul><hr /><p>下面举例 1 次、2 次和 3 次 Bézier 曲线的表达式：</p><ul><li><p><strong>1 次 Bézier 曲线（直线段）：</strong></p><p><span class="math display">\[P(u) = (1-u)P_0 + uP_1\]</span></p></li><li><p><strong>2 次 Bézier 曲线：</strong></p><p><span class="math display">\[P(u) = (1-u)^2 P_0 + 2(1-u)u P_1 + u^2 P_2\]</span></p></li><li><p><strong>3 次 Bézier 曲线：</strong></p><p><span class="math display">\[P(u) = (1-u)^3 P_0 + 3(1-u)^2 u P_1 + 3(1-u) u^2 P_2 + u^3 P_3\]</span></p></li></ul><hr /><ul><li><p><strong>生成算法</strong>：DeCasteljau递归算法，便于分割和细分。递归公式如下：</p><ul><li>当 $ r = 0 $ 时，$ P_i^{(0)} = P_i $（即初始控制点）</li><li>其余时候，$ P_i^{(r)} = (1-u) P_i^{(r-1)} + u P_{i+1}^{(r-1)} $</li><li>曲线上的点 $ P(u) $ 即为 $ P_0^{(n)} $（n 为控制点数减一）。</li></ul></li><li><p><strong>分割定理</strong>：对于给定参数 $ u' $，将 Bezier 曲线从$ u' $ 处分割为两段曲线 $ Q $ 和 $ R $，它们仍然可以用 Bezier曲线表示。</p><ul><li><p><strong>前一段曲线 $ Q $（区间 $ [0, u'] $）：</strong></p><p><span class="math display">\[Q(u) = \sum_{i=0}^{n} P_0^{(i)}(u&#39;) \cdotBEZ_{i,n}\left(\frac{u}{u&#39;}\right), \quad u \in [0, u&#39;]\]</span></p><p>其中 $ P_0^{(i)}(u') $ 是 De Casteljau算法生成的左下角一列点。</p></li><li><p><strong>后一段曲线 $ R $（区间 $ [u', 1] $）：</strong></p><p><span class="math display">\[R(u) = \sum_{i=0}^{n} P_i^{(n-i)}(u&#39;) \cdotBEZ_{i,n}\left(\frac{u-u&#39;}{1-u&#39;}\right), \quad u \in [u&#39;, 1]\]</span></p><p>其中 $ P_i^{(n-i)}(u') $ 是 De Casteljau算法生成的右上角一列点。</p></li><li><p>这样，原曲线被精确分割为两条新的 Bezier 曲线，且在 $ u' $处位置和切线都连续。</p></li><li><p>利用分割定理，可以每次取中点分割曲线，可以使控制多边形逐步逼近原曲线。</p></li><li><p>在实际计算中，常用控制多边形顶点到直线 $ P_0P_n $的距离来近似判断控制多边形与曲线的偏差，从而简化计算过程</p></li></ul></li><li><p>封闭曲线可通过首尾控制点重合实现。</p></li><li><p>Bezier曲线可通过升阶算法提升阶数，保证曲线形状不变（此时增加的控制顶点并不改变曲线的实际次数）。具体为：</p><p><span class="math display">\[P^\star_i = (1 - \lambda) P_i + \lambda P_{i-1}, \quad i = 0, 1, \ldots,n+1\]</span></p><p>其中 $ = $，并规定 $ P_{-1} = P_{n+1} = 0 $。</p></li><li><p>降阶则做不到准确降阶，仅能看作被较低次数的曲线逼近</p></li><li><p><strong>拼接</strong>：多段Bézier曲线可通过端点及导数连续性拼接。</p><ul><li><strong>C0连续（位置连续）</strong>：上一段曲线终点与下一段起点重合，即 $ P_n =Q_0 $</li><li><strong>C1 连续（一阶导数连续）</strong>：在 C0连续的前提下，上一段最后两个点与下一段前两个点共线，即</li></ul><p><span class="math display">\[Q_1 = P_n + (P_n - P_{n-1})\]</span></p><ul><li><strong>C2 连续（二阶导数连续）</strong>：在 C1连续的前提下，新段第三点被定位为</li></ul><p><span class="math display">\[Q_2 = P_{n-2} + 4 (P_n - P_{n-1})\]</span></p><p>或更一般地，满足二阶导数在拼接点处相等的条件。</p></li></ul><hr /><h3 id="b样条b-spline曲线">B样条（B-Spline）曲线</h3><ul><li><p><strong>定义</strong>：B样条（B-spline）曲线是由一组控制多边形（$n+1 $ 个控制顶点 $ {P_i} $）和节点向量 $ U_{n,k} = {u_i} <spanclass="math inline">\(（\)</span> i = 0, 1, 2, , n+k $，且 $ u_i u_{i+1}$）共同决定的。通常称 $ u_i $ 为节点，$ U_{n,k} $ 为节点向量。</p><p>若 $ u_{j-1} &lt; u_j = u_{j+1} = = u_{j+r-1} &lt; u_{j+r} $，则称从$ u_j $ 到 $ u_{j+r-1} $ 为 r重节点。节点的重数会影响曲线在该处的连续性和插值性。</p><p><span class="math display">\[P(u) = \sum_{i=0}^{n} B_{i,k}(u) P_i\]</span></p><p>其中 $ B_{i,k}(u) $ 为 k 次 B样条基函数。</p></li><li><p><strong>递归定义（Cox-de Boor公式）：</strong></p><p><span class="math display">\[B_{i,0}(u) =\begin{cases}  1, &amp; u_i \leq u &lt; u_{i+1} \\  0, &amp; \text{otherwise}\end{cases}\]</span></p><p><span class="math display">\[B_{i,k}(u) = \frac{u-u_i}{u_{i+k-1}-u_i} B_{i,k-1}(u) +\frac{u_{i+k}-u}{u_{i+k}-u_{i+1}} B_{i+1,k-1}(u)\]</span></p><p>其中 $ k $ 为阶数，$ u_i $ 为节点。（约定 $ 0/0=0 $）</p></li><li><p><strong>性质</strong>：</p><ul><li><strong>局部性</strong>：每个 B 样条基函数 $ B_{i,k}(u) $ 仅在区间 $(u_i, u_{i+k}) $ 内为正值，其他地方为 0。对于 $ (u_i, u_{i+k+1}) $的任意一点，至多有 $ k+1？ $ 个基函数非零，具有良好的局部可调性。</li><li><strong>凸包性</strong>：曲线始终在控制点凸包内</li><li><strong>分段多项式</strong>：每段为低次多项式，连接处高阶连续</li><li><strong>节点重数</strong>：可调节插值性和连续性</li><li><strong>顶点重合与尖角</strong>：若有连续 $ k+1 $个控制顶点重合，则对应的曲线段退化为重合点；若前后 $ k+1 $个顶点共线，则在该处形成尖角，可能导致参数曲线在尖角处参数连续性和结合连续性不一致。</li><li><strong>连续性</strong>：在 $ r $ 重节点 $ u_i $处，B样条曲线至少具有 $ C^{次数-r} $ 次连续性（即导数连续到 $ 次数-r $阶）；整段曲线的最低连续性为 $ C^{次数-r_{max}} $，其中 $ r_{max} $为节点向量中的最大重数。<ul><li>例如：$ 次数=0 $ 时为 $ C^{-1} <spanclass="math inline">\(（离散控制顶点），\)</span> k=2 $ 时为 $ C^0 <spanclass="math inline">\(（控制多边形），\)</span> k=3 $ 时为 $ C^1 $</li></ul></li></ul></li><li><p><strong>定义域：</strong></p><ul><li>由 $ n+1 $ 个顶点定义的 $ k $ 次 B样条曲线有 $ n-k+1 $ 段，每段由 $k+1 $ 个控制点定义。不含重节点时，每增加一个段数就加 1。</li><li>曲线的定义域为 $ [u_k, u_{n+1}] $。虽然节点向量包含 $ n+k+1 $个区间，但曲线仅定义在由 $ [u_k, u_{n+1}] $ 构成的 $ n-k+1 $个节点区间上，两端各有 $ k $ 个节点不作为定义区间。</li><li>一般而言，先确定 $ [u_k, u_{n+1}] $ 作为定义域，再向两边各延伸 $ k $个节点以构成完整的节点向量。</li></ul></li></ul><hr /><p><strong>定义实例：</strong></p><ul><li>给定控制顶点 $ {P_i} <span class="math inline">\(（\)</span>i=0,1,,8 $），定义一条三次 B 样条曲线。<ul><li>即 $ n=8 <span class="math inline">\(，\)</span> k=3 $。</li><li>节点向量：$ U = {u_0, u_1, , u_{n+k+1}} = {u_0, u_1, , u_{12}}$。</li><li>曲线定义域：$ u = [u_3, u_9] $。</li><li>当定义域 $ [u_3, u_9] $ 内不含重节点时，曲线的段数为 $ n-k+1 = 6$。</li><li>定义在 $ u $（即 $ i=6 <spanclass="math inline">\(）上的曲线段，其四个控制点为：\)</span>$ (P_{i-k},P_{i-k+1}, , P_i) = (P_3, P_4, P_5, P_6) $$</li><li>该曲线段的两端点分别与其中前后 $ k=3 $ 个顶点有关。</li><li>移动顶点 $ P_3 $ 至多影响定义在区间 $ [u_3, u_7] $内的那些曲线段的形状，对曲线其它部分无影响。</li><li>移动顶点 $ P_7 $ 应该对定义在区间 $ [u_7, u_{11}] $内的那些曲线段的形状产生影响，但由于 $ (u_9, u_{11}] $落在定义域外，故仅影响 $ [u_7, u_9] $ 内的曲线</li></ul></li></ul><hr /><ul><li><p><strong>曲线类型：</strong></p><ul><li><p><strong>均匀B样条</strong>：节点区间等距分布，曲线参数分布均匀。</p><ul><li>例如可取 $ u_i = i $，此时具有平移性质 $ B_{i,k}(t) = B_{0,k}(t-i)$。</li><li>选择均匀B样条时，实际上放弃了利用参数节点控制曲线形状的能力，曲线形状仅由控制点决定。</li></ul></li><li><p><strong>准均匀B样条</strong>（也叫均匀非周期B样条）：</p><ul><li>两端节点重复度为 $ k+1 $，内节点重复度为 1，且节点等距分布。</li><li>这种类型兼顾了端点插值性和均匀分布的优点。</li></ul></li><li><p><strong>分段Bezier</strong>：</p><ul><li>两端节点重复度为 $ k+1 $，内节点重复度为 $ k $，要求控制点个数 $ n $为次数 $ k $ 的正整数倍。</li><li>本质上是将Bezier曲线分段拼接而成（<strong>考试考过！！！！</strong>）。<ul><li>当端节点重复度为 $ k $ 时：<ul><li>$ k $ 次 B样条曲线的端点将与相应的控制多边形的端顶点重合，并在端点处与控制多边形相切。</li></ul></li><li>当端节点重复度为 $ k+1 $ 时：<ul><li>$ k $ 次 B 样条曲线就具有和 $ k $ 次 Bézier曲线相同的端点几何性质。</li></ul></li><li>若 $ k $ 次 B 样条曲线在定义域内相邻两节点都具有重复度 $ k $：<ul><li>可生成定义在该节点区间上的那段 B 样条曲线的 Bézier 曲线。</li></ul></li><li>若端节点重复度为 $ k+1 $ 的 $ k $ 次 B样条曲线的定义域仅有一个非零节点区间：<ul><li>所定义的该 $ k $ 次 B 样条就是 $ k $ 次 Bézier 曲线。</li></ul></li></ul></li></ul></li><li><p><strong>非均匀B样条</strong>：</p><ul><li>节点向量为任意非递减序列，且两端节点重复度不超过 $ k+1$，内节点重复度不超过 $ k $。</li><li>一般不具有平移性质，计算量较大，但可以自由调节节点的值来灵活控制曲线形状。</li></ul></li></ul></li><li><p><strong>生成算法</strong>：除了利用之前的递归定义外还有一种方法</p><ul><li>通过递归算法（de Boor-Cox算法）计算曲线上的点，适合数值稳定的绘制。</li><li>令</li></ul><p><span class="math display">\[\lambda_i^r(u) = \frac{u - u_i}{u_{i+k-r+1} - u_i}\]</span></p><p>其中 $ r = 1, 2, , k <span class="math inline">\(，\)</span> i = j -k + r, , j <span class="math inline">\(，\)</span> u [u_j, u_{j+1})$。</p><ul><li>递归计算控制点：</li></ul><p><span class="math display">\[P_i^0 = P_i\]</span></p><p><span class="math display">\[P_i^r(u) = (1 - \lambda_i^r(u)) P_{i-1}^{r-1}(u) + \lambda_i^r(u)P_i^{r-1}(u)\]</span></p><ul><li>最终，曲线在参数 $ u $ 处的点为</li></ul><p><span class="math display">\[P(u) =\sum_{i=j-k+r}^j P_i^r(u)B_{i,k-r}\]</span></p><p>其中 $ j $ 满足 $ u [u_j, u_{j+1}) $，r可取0-k</p><ul><li>该算法本质上是对控制点的递归线性插值，类似于 De Casteljau 算法在Bézier 曲线中的作用，能够高效、稳定地生成 B样条曲线上的任意点</li></ul></li><li><p><strong>节点插入/分割/升阶</strong>：灵活调整曲线形状和复杂度</p></li></ul><hr /><p><strong>控制顶点：</strong></p><ul><li>B样条具有良好的局部性，可以直观地看出控制顶点对曲线的影响。</li><li>设曲线的控制顶点为 $ (P_{i-3}, P_{i-2}, P_{i-1}, P_i) $，其凸包为 $ch_i $。</li><li>在区间 $ [u_i, u_{i+1}) $ 内，三次B样条曲线 $ P(u) $只与这四个控制顶点有关。</li><li>对于三次B样条，若四个控制点重合，则该处曲线为尖角；若四个控制点共线，则对应区间的曲线段为直线段。</li><li>若 $ P_{i-2} = P_{i-1} = P_i $，且节点 $ u_{i+1} $ 重数不超过3，则有$ P(u_{i+1}) = P(u_i) $。</li><li>若 $ P_{i-2}, P_{i-1}, P_i $ 共线，且节点 $ u_{i+1} $重数不超过2，则曲线在该处与直线段 $ P_{i-2}P_i $ 相切</li></ul><hr /><p><strong>对比：</strong></p><ul><li><strong>特例关系</strong>：k 次 Bézier 曲线是 k 次 B样条曲线的特例，B 样条方法是 Bézier 方法的有力推广和扩展。</li><li><strong>次数关系</strong>：Bézier 曲线的次数等于控制顶点数减 1，B样条曲线的次数与控制点数无关，由节点向量和阶数决定。</li><li><strong>基函数性质</strong>：Bézier 基函数为单一多项式函数，B样条基函数为分段多项式样条，具有更强的灵活性。</li><li><strong>曲线性质</strong>：Bézier 曲线是参数多项式曲线，B样条曲线是参数样条曲线（分段多项式，连接处有高阶连续性）。</li><li><strong>局部控制能力</strong>：Bézier曲线缺乏局部性，修改一个控制点会影响整条曲线；B样条曲线具有良好的局部性。</li></ul><hr /><h3 id="nurbs非均匀有理b样条">NURBS（非均匀有理B样条）</h3><ul><li><strong>定义</strong>：在B样条基础上引入权重，能精确表示圆、椭圆等解析曲线。</li><li><strong>表达式</strong>： <span class="math display">\[C(u) = \frac{\sum N_{i,k}(u) w_i P_i}{\sum N_{i,k}(u) w_i}\]</span></li><li><strong>性质</strong>：<ul><li>权重调节曲线对控制点的吸引力</li><li>权重为1时退化为普通B样条</li><li>能精确表达常见几何体</li></ul></li><li><strong>应用</strong>：CAD、工业设计、动画等</li></ul><hr /><h3 id="曲面">曲面</h3><ul><li><strong>参数曲面</strong>：曲线在两个参数方向上的推广（如Bézier曲面、B样条曲面、NURBS曲面）。</li><li><strong>控制网格</strong>：决定曲面形状。</li><li><strong>表达式</strong>：双参数形式，基函数为两个方向的乘积。</li></ul><hr /><p><strong>对比表：</strong></p><table><thead><tr><th>特性</th><th>Hermite</th><th>Bézier</th><th>B样条</th><th>NURBS</th></tr></thead><tbody><tr><td><strong>凸包性</strong></td><td>否</td><td>是</td><td>是</td><td>是</td></tr><tr><td><strong>插值控制顶点</strong></td><td>是</td><td>是</td><td>否</td><td>增加节点重数可插值控制顶点</td></tr><tr><td><strong>离散生成方法</strong></td><td>端点与切矢量</td><td>控制顶点</td><td>控制顶点</td><td>控制顶点+权重</td></tr><tr><td><strong>连续性</strong></td><td>C1, G1</td><td>C1, G1</td><td>C2, G2</td><td>C2, G2</td></tr><tr><td><strong>形状控制参量</strong></td><td>端点位置与切矢量</td><td>控制顶点</td><td>控制顶点</td><td>控制顶点、权重</td></tr><tr><td><strong>局部可调性</strong></td><td>局部（每段独立）</td><td>拟局部（但全局影响）</td><td>强（仅影响相邻区段）</td><td>强（仅影响相邻区段）</td></tr><tr><td><strong>端点插值</strong></td><td>是</td><td>是</td><td>否</td><td>增加节点重数可实现</td></tr><tr><td><strong>计算复杂度</strong></td><td>较好</td><td>好</td><td>一般</td><td>计算复杂</td></tr><tr><td><strong>适用场景</strong></td><td>需指定端点斜率、动画路径</td><td>曲线建模、动画、字体</td><td>曲面建模、CAD、动画</td><td>高级建模、工业设计、动画</td></tr></tbody></table><hr /><p><strong>复习建议</strong>：掌握每种曲线/曲面的定义、表达式、主要性质和适用场景，理解控制点、节点、权重等对形状的影响，能写出基本公式和递归算法思想。</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>来时路</title>
    <link href="/2025/04/12/%E6%9D%A5%E6%97%B6%E8%B7%AF/"/>
    <url>/2025/04/12/%E6%9D%A5%E6%97%B6%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4a38b294c18dcfa43b6cc8bdac3c875fa91fab758030c6f48d71bd1158721690">993001887e685ce116fe55cfc0af2e19756f54c96abd96c28d4c8d8127f626140f320add533a9326e0f1a291a9080b8a79ee565a9b778841674a1a616e7cc2dc97041c2db7d13c403f1b98cb87bb1884db632afb6b9493b71368a717816466d173ad19e297792473946d021ec828e0c7ffdc163f42a5070510a0260b85d055f96516ae1eed27926a14c3010211c9ee7cc5d97befb726fee171907b8ad949a3e6cd92f88f34b3addbb24867b9bfc58c000a765ea64ef6310ba3e074de50b55b16943c6f4b95348057e5d2f093485414c3d025ae8a9f6c587bd678b49eeff355ea6b6577ffc4eee75011d5933387dbb8e4e8eb81250ee737d0af61aa2aa69381012ac1288269413cfe3538fce307cc9ae71d3e0ff66c8812a423fafdcd3f0e68a4ea6dc8afd25009ea1dd761aa5a408072c8ae4248912bbf8c77dc90bc01978fb577fb350e618d62f261db515191a2822460a84e9ca63b57ec81a03bfd4a4cf45b5be5a87075d5ec32fa3c38fcc0aee63fa4e1207663f1c8056873f4d68591522ba7eee9a7a03d6763c6d1e03fc9c2d6f389e45f483284e4285e6ef0edeafebb00bda2a07416928a679283fa129e3fff19</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>remote-ssh-to-wsl</title>
    <link href="/2025/04/11/remote-ssh-to-wsl/"/>
    <url>/2025/04/11/remote-ssh-to-wsl/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自知乎，原文链接为https://zhuanlan.zhihu.com/p/357038111.</p></blockquote><p>最近希望能通过VScode的Remote-SSH插件来远程访问位于寝室Windows主机上的WSL，但是考虑到处于校园网环境，Windows主机的IP地址是动态分发的且<del>一直开机并不现实</del>，因此可能每次使用远程访问时都要重复操作，为避免遗忘，遂记录于此.</p><ol type="1"><li>在WSL2下重装ssh</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get remove openssh-server<br>sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>编辑sshd_config文件，修改几处配置</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/ssh/sshd_config<br><br>+++ Port 22<br>+++ PermitRootLogin <span class="hljs-built_in">yes</span><br>+++ PasswordAuthentication <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编辑hosts.allow</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts.allow<br><br>+++ sshd: ALL<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>重启ssh服务</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo service ssh --full-restart<br><br>sudo systemctl <span class="hljs-built_in">enable</span> ssh <span class="hljs-comment">#设置开机自启</span><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>进行端口转发</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ifconfig <span class="hljs-comment">#在WSL，查看ip地址</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># in Win : 管理员cmd</span><br>netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=22 connectaddress=xxx.xxx.xxx.xxx connectport=22<br><br>netsh interface portproxy show all <span class="hljs-comment">#查看已设置的转发</span><br>netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=22 <span class="hljs-comment">#删除某一转发</span><br>netsh interface portproxy reset <span class="hljs-comment">#重置所有转发</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>cmd下查询Windows的内网IP地址</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ipconfig<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>通过Remote-SSH进行连接</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh root@xxx.xxx.xxx.xxx <span class="hljs-comment">#root可换成对应用户名</span><br></code></pre></td></tr></table></figure><blockquote><p>Windows防火墙设置默认会关闭22端口，需要开放防火墙设置：<code>Win+R</code>键入<code>control firewall.cpl</code>，新建入站规则即可.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Happy-Birthday!</title>
    <link href="/2025/04/04/Happy-Birthday/"/>
    <url>/2025/04/04/Happy-Birthday/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5d4e8e15c921a904d779959554b2a0dd66504dc711ed4ebe1801f68cac2e75ff">10d79030e8222445804370796b90fca1b3149e2c2a0f36d6b4ea04e548758c2111af2b8f18804544ae7edb4f8d5e33e48fc2a9e5d9e9f70e011ebca3a0dafa9769cd7daa121cdd45e0c91ba3361a09d36de5c6e0fb770a3ed9dd4c90afdc474230ef1020e3f05616cf54411d130d330d0a4ce5198ef3f64941d5c9594d0dc0a6122e77f4437062fb68ea3e7e79b2b82b9b48604a51b072c920e858bc130b529d5cb22b633e42c6ad6a697b6db93e9586058e36b1865c3d3280101deda27938cfc3ff9926d9d79cdc8a4f9144c8a06a72d6c84672c15d0832a35644787f1f8b9ee7c4ef6b4617227f33c68880d33652e2b9b118b97bde873f5554112119329d3f88a36ea527fe07c7f75d2c70ccefb3e288a05a8d5b234df5f5f0d2a9cda0660f3c0fe41ad418601cb0398b757ed0192b9231545d014692a6e872a64971e402f9deee6ace0e80ee062e884bd36370c13d7290527cc0416df2a64debc6eb01ac49e696d905a188a5f85e495d1c1c63cc1003a263b5c8f48636aa860bfbc14cad80794cf7be3eac3926ef77c5ff34d1db09a5c4c1a31026772936aeb5cc0b01802499103d5a73c60d9755c4ce9588bdb016f1c7a7ccdc0756d6cea85416691ad0b9fd355cc637ec21e6953928aecad5cd034deb0cd194df35af0569bb174ef50e69a10be1011f42a6b49b2bb0da289c783630cdcc9c0b918613e1fd939d7054e5a240ab9d1c55a27b72e030114ac122ac727df6377387fc56d40c93a65c5a6e31e27e9e83bcb7781de4a68b880fce78aa075ea4c2e3f2730eb23f00f828bf015e24a138249fbc153cad4cbc801682b1b508a6074bbd2a20df884d6d3d397d489d8103349f6857534038d63cf03b21e8742801da36bff61bc7db8f7555bbcd5c233bb635b32856025bc385a8db7683d1c3e178ae58447b78818562ac1c6830dc979841f242014ebee71eaabf499b4ff6a8eb0e22f1770a1ac0cc2d81081a10e5ea5ccb028e24161bd2bef71d7804588e4a94e4327b1afb98066c44a4f595068d2f7803038e0775df8593a07eaad1dd34e49eb98a1bb0376bde504709a6e51532ea20383567e16164fe55925936a279a88b1416d4a59accdccc9b11d151f81f9e308e8451113ac945f4aa509d05d582d9a7480b02d011307cf13abcbeffd333ceeedeffae655337e805e819eff7e00893a53a557104bdc77ad4edb1af7771f6468b624385ba5863eafc9f7eaff889b6af08aa237e54441fcbb40b63332e6f800d1f4d37d9a5ae97178386fe1ad920a30f47ce63ecdb01312dc37c834bea162f6e730f672ccf3fab55aa551a96c15de0d9c4707ef6b81d49e67e09973de7ec94ca608ab649a35037dc838d7b1ca9678b156d3c423ac2ed6806b66fd5ff428b15e3031e4a1025a8399e646af4d45ba72f8d16236dc06e6d353a811a1b9668b45be0c23d4383bf7013171d6fac360d276b20ab92539f1aeb074e45f040a5b96b927dea99f5b2111759b563c5aa55561b07351397221ff8ee1bdd36bfc4eb9961f11a49f0fcf8fcae9d53dec8d22fb804a80ebd1885ee3b65b1d2b458f43031ecd3d581fbbe7d361d2c993c9720784388ef669898dfc2dad805eb20f537276d4e963d1747bfcdefae7ed9ebc0633c02b43bfb7dc9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Win安装“动手学深度学习”</title>
    <link href="/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/"/>
    <url>/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/</url>
    
    <content type="html"><![CDATA[<p>课程网站上的<ahref="https://zh.d2l.ai/chapter_installation/index.html">安装说明</a>已经很friendly了，但是并未列出Windows下的安装教程，谨在此记录我是如何在Win11下进行安装的.</p><h2 id="安装配置-miniconda">安装配置 Miniconda</h2><p>根据自己使用的python版本，在<ahref="https://repo.anaconda.com/miniconda/">miniconda</a>官网中选择对应的版本即可，如笔者使用的是<code>python 3.9</code>，则选择了<code>Miniconda3-py39_24.11.1-0-Windows-x86_64.exe</code>来下载并双击安装.</p><ul><li>建议勾选 Register Miniconda3 as my default Python 3.9...</li><li>不要忘记设置环境变量</li></ul><p>详细安装教程可参见<ahref="https://www.bilibili.com/opus/509341163774622170">bilibili</a>.</p><h2 id="其余即可参照课程网站">其余即可参照课程网站</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>生日快乐</title>
    <link href="/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <url>/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="eee754c680eee422755caa7629bf38031c9061637af1d9456d14c46fefceb82a">10d79030e8222445804370796b90fca1b3149e2c2a0f36d6b4ea04e548758c216c4f8b959fb5a2e4b286d076935415b6f0cdcf9e45f7294fc1e8b64cbc9380b3fe6487b2928a50342d05240db2caa35730dbb529bcc971a81652b3114321186ac79b1ecd9b95b4d8af574ecafaf902dd1cbca9697f1d3bb19746e3856145feeeb87114c2fe1d38a7856c22de22b34243a6d2c4f7ba1aca75e07b9da9838b071a16fd10387eb0db1d7778a621b36ea5c78bf0a7edba408b0a8d10d9f935292e294755990afd8f95b5c4cdc9b9993b21ac9fbf4ec994a8e762644a4eb4b6fca0342c855f1458eb8f9ffd947d55744c1a52044da75d3fcdb6716e661aa984a8f1d9234b5373cd1c347829812e01f0d0003b60610339d954448218226ec58ab9f0553a5a26ce57b9c40a5a0676355ce1157244924371f1623bee26ec46883ed60e139901d839cb35b3bbacac99bd0a32baaac5dfc8dd4c49e466b2d5b8cbaace0c0a36e0a0777bd98113acdf7af01737ea7f73f187a82cebf3ddbe544ff77749785399da7ffcfb65fbe1b2c2986ac0f0ba7dccadb0f871d3b0722f416e00ceb3709a64743fdc5ea6f76e018976de732b3e74adcf5f841e2e8e3594f9de30f57c9586b5a656b027904f3e1c8c4f0595f78c76b9d13a5d4aabcdf45ae62c0a06008ff1ca3deaef08b5236bdf64abb9fb07e8f09c2ab6f41fee57abc17e8664c7376bf8cd7ead7c606a699b496ebae5cd59c673318f29b2f595d363a967b94ea17ab72758d4de468858aa228c5dc1f5f95733d6d711b625b38d0f80eb9e58425ca8317614ba38197687af7f56b48296b289f04e816342073bdfb2393c8cc282c8d8ca9e2e9caae9e0ab604cf498313e4dc1b62ad28b42329117faec1bc3def578d6e20df8f5afaa2a5783af5aab5ce83f0194f732fe77f3f3b64105b9610e92e6013f65112c5ed58a2c7e36d738b7df75494c154a77c35b60d176b43cc8ac6eefccd55f033c6e167da696e86b42e4052f0522eb5b0827c8de001d1b38ceb7b8057b96037ad19d56a6c19ec04674312dae33efd9447846ec56cd7868dc5a93178979c22ee8708b3d72e08613e069408fa3f80922e297a9f5378239ca653132ee7edc6da005e3de65793f8c4983994eeffb89757434fb23ff747b3d5037598a7d310e1ac24f196bb4d84fb006f7ac67f39ce17709816c3fdac776ba5c4f30d942f2ff9e6390c4c0c381e47dcd0fe90726f1ba9e4f468abdc35d1f79aca9f47dd6ecdf8693727f8cddb3b3c95b139d693d84b561ffb1a1d163cf6e3ec35acad436a462322a938e24070375c44352aa0214dc61f2fac8df4f72de6983fe3d1d139275346e82732a16b7e93d514d3064c7ceea3070a03bbb7e70918245ad1d773896bdd17b4174de19bf5e4d4951501ec03dc083821a53c6d06e2631ed6e04c10d8b06cfb1f63799d868e4056d67459491c52b38092e5dfe8d436fa561efc75f139c2cf804c9a5293981ab297b8da1570fb2d961d392059861f6e941edf4688850eae78c1fd7c964d16ba51bfed11c0a7864fd9b92fa16246feeac091da290bf2223e6889a2b514d83124222b97481ea5ead8f93fbcc0675e9e93ffdcfa6c93ff761ac3df6ea504cd531313f1c1de75eea3018a15100</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CRYPTO</title>
    <link href="/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="消息认证">消息认证</h2><ul><li>消息认证的必要性</li><li>MAC<ul><li>定义</li><li>正确性与安全性要求</li><li>使用</li></ul></li><li>构造 secure MACs<ul><li>定长</li><li>CBC-MAC处理长消息</li></ul></li><li>AE<ul><li>定义</li><li>CCA安全</li><li>不可伪造加密</li><li>构造AE</li></ul></li></ul><h3 id="消息认证的必要性">消息认证的必要性</h3><p>安全的对话要确定消息发送方的身份和以及消息未被串改，仅加密在很多时候并不能确保这些.</p><h3 id="mac">MAC</h3><p>给我们的消息打一个tag！</p><h4 id="定义">定义</h4><p>消息认证码，即 MAC 是一个 PPT 算法组成的三元组 <spanclass="math inline">\(\Pi=(Gen,Mac,Vrfy)\)</span>: + 密钥生成算法: <spanclass="math inline">\(k \leftarrow Gen(1^n) , |k| \geq n\)</span>. +标签生成算法：<span class="math inline">\(t \leftarrow Mac_k(m)\ or\ t:= Mac_k(m), m\in \{0,1\}^*\)</span>. + 确定性的认证算法：<spanclass="math inline">\(b := Vrfy_k(m,t) , b=1 \ iff.\ m\ is\valid\)</span>.</p><h4 id="正确性与安全性要求">正确性与安全性要求</h4><p><strong>正确性</strong>：正确生成的MAC要被认可，即 <spanclass="math display">\[\forall n, k \leftarrow Gen(1^n), \forall m\in\{0,1\}^*, Vrfy_k(m,Mac_k(m))=1\]</span></p><p>当 <span class="math inline">\(Mac\)</span>是确定性算法时，一种典型的认证方法是重新计算tag并进行比对.</p><p><strong>安全性</strong>通过消息认证试验 <spanclass="math inline">\(Mac-forge_{\mathcal{A},\Pi}(n)\)</span> 来定义：1. <span class="math inline">\(k \leftarrow Gen(1^n)\)</span>对敌手保密. 2. 给 <span class="math inline">\(\mathcal{A}(1^n)\)</span>调用 <span class="math inline">\(Mac_k(\cdot)\)</span> 的能力，<spanclass="math inline">\(\mathcal{A}\)</span> 查询若干次，最终输出 <spanclass="math inline">\((m,t)\)</span>. 记 <spanclass="math inline">\(\mathcal{Q}\)</span> 为 <spanclass="math inline">\(\mathcal{A}\)</span> 所查询消息的集合. 3. <spanclass="math inline">\(\mathcal{A}\)</span> 成功也即 <spanclass="math inline">\(Mac-forge_{\mathcal{A},\Pi}(n)=1\)</span> 当且仅当<span class="math inline">\(Vrfy_k(m,t)=1 \wedge m \notin\mathcal{Q}\)</span>.</p><p>一个 MAC 是 secure 当且仅当 对于任何一个PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , 都存在可忽略的函数 <spanclass="math inline">\(negl\)</span> ，使得 <spanclass="math display">\[Pr[Mac-forge_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>secure保证了一个敌手不可能为一个先前未认证的<strong>新消息</strong>生成一个合法的tag, 但是并未保证敌手不能为已经认证的消息生成一个<strong>新的合法tag</strong>, 于是有了 strongly secure</p><p>消息认证试验 <spanclass="math inline">\(Mac-sforge_{\mathcal{A},\Pi}(n)\)</span> : 1.<span class="math inline">\(k \leftarrow Gen(1^n)\)</span> 对敌手保密.2. 给 <span class="math inline">\(\mathcal{A}(1^n)\)</span> 调用 <spanclass="math inline">\(Mac_k(\cdot)\)</span> 的能力，<spanclass="math inline">\(\mathcal{A}\)</span> 查询若干次，最终输出 <spanclass="math inline">\((m,t)\)</span>. 记 <spanclass="math inline">\(\mathcal{Q}\)</span> 为 <spanclass="math inline">\(\mathcal{A}\)</span> 所查消息和对应tag对的集合. 3.<span class="math inline">\(\mathcal{A}\)</span> 成功也即 <spanclass="math inline">\(Mac-sforge_{\mathcal{A},\Pi}(n)=1\)</span>当且仅当 <span class="math inline">\(Vrfy_k(m,t)=1 \wedge (m,t) \notin\mathcal{Q}\)</span>.</p><p>一个 MAC 是 strongly secure 当且仅当 对于任何一个PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , 都存在可忽略的函数 <spanclass="math inline">\(negl\)</span> ，使得 <spanclass="math display">\[Pr[Mac-sforge_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>显然典型的使用确定性的 secure 的 MAC 天然就是 strongly secure 的.</p><h4 id="如何使用-mac">如何使用 MAC</h4><p>What if Alice needs to send a message in Q, (i.e. was sentpreviously)? + Directly applying the MAC would cause repeated messagesto be rejected. + One can append a unique timestamp or nonce to eachmessage.</p><h3 id="构造-secure-的-mac">构造 secure 的 MAC</h3><h4 id="定长-mac">定长 MAC</h4><p>如果有函数 <span class="math inline">\(l\)</span> 使得对于任意 <spanclass="math inline">\(k \leftarrow Gen(1^n)\)</span>, <spanclass="math inline">\(Mac_k\)</span> 仅对 <spanclass="math inline">\(m\in \{0,1\}^{l(n)}\)</span> 上的消息有定义.</p><p>使用PRF！</p><p>令 <span class="math inline">\(F\)</span> 是 PRF . 对长为 n的消息定义一个定长的 MAC： + Mac : 输入密钥 <spanclass="math inline">\(k\in \{0,1\}^n\)</span> 和消息 <spanclass="math inline">\(m\in\{0,1\}^n\)</span>,输出标签 <spanclass="math inline">\(t:=F_k(m)\)</span>. + Vrfy: 输入密钥 <spanclass="math inline">\(k\in \{0,1\}^n\)</span> 消息 <spanclass="math inline">\(m\in \{0,1\}^n\)</span> 和标签 <spanclass="math inline">\(t\in\{0,1\}^n\)</span>,输出1当且仅当 <spanclass="math inline">\(t=F_k(m)\)</span>.</p><p>若 <span class="math inline">\(F\)</span> 是 PRF ，上述构造就是一个对长度为n的消息的 secure fixed-length MAC.</p><h4 id="处理长消息定长">处理长消息（定长）</h4><p>basic CBC-MAC: <span class="math inline">\(F\)</span> 是一个 PRF ，以及长度函数 <span class="math inline">\(l\)</span> + Mac : 输入 <spanclass="math inline">\(k \in \{0,1\}^n, m\in \{0,1\}^{n\cdotl(n)}\)</span> + 将 <span class="math inline">\(m\)</span> 分成 <spanclass="math inline">\(l(n)\)</span> 个长度为 <spanclass="math inline">\(n\)</span> 的块, + <spanclass="math inline">\(t_0:= 0^n\)</span>,对 <spanclass="math inline">\(i\)</span> 从 1 到 <spanclass="math inline">\(l(n)\)</span>, <span class="math inline">\(t_i :=F_k(t_{i-1} \oplus m_i)\)</span> + 输出 <spanclass="math inline">\(t_l\)</span> + Vrfy : 输入 <spanclass="math inline">\(k\in \{0,1\}^n, m, t\)</span>,输出1当且仅当 <spanclass="math inline">\(|m|=n\cdot l(n) \wedge t=Mac_k(m)\)</span>.</p><figure><img src="/image/crypto/basic-cbc.png" alt="basic-cbc mode" /><figcaption aria-hidden="true">basic-cbc mode</figcaption></figure><p>仍然仅能处理定长的消息！！！</p><h3 id="ae">AE</h3><p>消息的安全性和真实性都要！</p><h4 id="定义-1">定义</h4><p>一个私钥加密方案是 AE 的如果其是 CCA-secure 并且 unforgeable.</p><h4 id="cca安全">CCA安全</h4><p>CCA安全由CCA indistinguishability experiment <spanclass="math inline">\(PrivK_{\mathcal{A},\Pi}^{cca}(n)\)</span> 定义：1. <span class="math inline">\(k\leftarrow Gen(1^n)\)</span> 2.给敌手调用 <spanclass="math inline">\(Enc_k(\cdot),Dec_k(\cdot)\)</span>的权限，敌手输出 <span class="math inline">\(m_0,m_1\)</span>. 3. 加密<span class="math inline">\(c\leftarrowEnc_k(m_b),b\overset{\$}{\leftarrow}\{0,1\}\)</span>,将 <spanclass="math inline">\(c\)</span> 发送给敌手. 4. 敌手调用 <spanclass="math inline">\(Enc_k(\cdot),Dec_k(\cdot)\)</span>，但不允许直接调用 <span class="math inline">\(Dec_k(c)\)</span>，输出<span class="math inline">\(b&#39;\)</span>. 5. <spanclass="math inline">\(PrivK_{\mathcal{A},\Pi}^{cca}(n)=1\)</span>当且仅当 <span class="math inline">\(b=b&#39;\)</span>.</p><p>私钥加密方案 <span class="math inline">\(\Pi\)</span> 是 <spanclass="math inline">\(CCA-secure\)</span>的当且仅当对于任意PPT的敌手均有 <spanclass="math display">\[Pr[PrivK_{\mathcal{A},\Pi}^{cca}(n)=1]\leq\frac{1}{2} + negl(n).\]</span></p><p>可延展性（malleable) 在不知道 <span class="math inline">\(m\)</span>的前提下构造其密文. CCA安全推出了不可延展性.</p><h4 id="不可伪造性">不可伪造性</h4><p>不可伪造加密试验 <spanclass="math inline">\(Enc-Forge_{\mathcal{A},\Pi}(n)\)</span>: 1. <spanclass="math inline">\(k\leftarrow Gen(1^n)\)</span> 2. 敌手有调用 <spanclass="math inline">\(Enc_k(\cdot)\)</span> 的权限， 最终输出一个密文.3. <span class="math inline">\(m:=Dec_k(c)\)</span> ， <spanclass="math inline">\(Enc-Forge_{\mathcal{A},\Pi}(n)=1\)</span> 当且仅当密文合法且 <span class="math inline">\(m\)</span> 没被查过.</p><p>私钥加密方案 <span class="math inline">\(\Pi\)</span> 是 unforgeable当且仅当对于任意PPT的敌手均有 <spanclass="math display">\[Pr[Enc-Forge_{\mathcal{A},\Pi}(n)=1]\leq  negl(n).\]</span></p><h4 id="构造ae">构造AE</h4><p>加密后验证！</p><figure><img src="/image/crypto/encrpt-then-authenticate.png"alt="encrpt-then-authenticate" /><figcaption aria-hidden="true">encrpt-then-authenticate</figcaption></figure><p><span class="math inline">\(\Pi_E\)</span> 是CPA安全的，<spanclass="math inline">\(\Pi_M\)</span> 是strongly secureMAC,那么上述构造是AE.</p><h2 id="哈希函数及其应用">哈希函数及其应用</h2><ul><li>哈希函数<ul><li>加密哈希函数</li><li>定义域扩展</li><li>例子</li></ul></li><li>MAC 和 Hash<ul><li>使用哈希函数扩展 MAC 的定义域</li><li>使用哈希函数构造 MAC</li></ul></li><li>哈希函数的应用</li><li>针对哈希函数一般攻击</li></ul><h3 id="哈希函数">哈希函数</h3><p>将长串映射到短串！！！</p><h4 id="加密哈希函数">加密哈希函数</h4><p>能在加密应用中使用的符合密码学要求的哈希函数，一般满足如下要求： +collision resistant: It is difficult to find two different messages<span class="math inline">\(m\)</span> and <spanclass="math inline">\(m′\)</span> such that <spanclass="math inline">\(hash(m) = hash(m′)\)</span>. + “completelyunpredictable” (a.k.a. <strong>random oracles</strong>): The hashfunction is indistinguishable from a random mapping.</p><h5 id="抗碰撞哈希函数">抗碰撞哈希函数</h5><p>我们将键控哈希函数 <span class="math inline">\(H\)</span>视为一个以密钥 <span class="math inline">\(s\)</span> 和字符串 <spanclass="math inline">\(x\)</span> 为输入的函数 <spanclass="math inline">\(H^s(x)=H(s,x)\)</span>.</p><p>这儿的密钥 <span class="math inline">\(s\)</span>通常并不是随机采样出来的，而是由密钥生成算法 <spanclass="math inline">\(Gen\)</span> 生成的.此外，密钥 <spanclass="math inline">\(s\)</span> 并不保密...</p><p>输出长度为 <span class="math inline">\(l\)</span>的哈希函数是这么一对 PPT 的算法 (Gen,H), 满足: + <spanclass="math inline">\(s \leftarrow Gen(1^n)\)</span> + <spanclass="math inline">\(H\)</span> 以密钥 <spanclass="math inline">\(s\)</span> 和串 <spanclass="math inline">\(x\in\{0,1\}^*\)</span> 为输入，输出串 <spanclass="math inline">\(H^s(x) \in \{0,1\}^{l(n)}\)</span>.</p><p>如果 <span class="math inline">\(H^s\)</span> 仅对定长 <spanclass="math inline">\(l&#39;(n)&gt;l(n)\)</span>的输入有定义，我们就称之为定长哈希函数，也叫compression function.</p><h5 id="碰撞检测试验">碰撞检测试验</h5><p>The collision-finding experiment <spanclass="math inline">\(Hash\text{-}coll_{\mathcal{A},\Pi}(n)\)</span>: 1.<span class="math inline">\(s \leftarrow Gen(1^n)\)</span> 2. 给敌手<span class="math inline">\(s\)</span>, 敌手输出 <spanclass="math inline">\(x,x&#39;\)</span> 3. <spanclass="math inline">\(Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1\)</span>当且仅当 <span class="math inline">\(H^s(x)=H^s(x&#39;)\)</span></p><p>一个哈希函数 <span class="math inline">\(\Pi=(Gen,H)\)</span>是抗碰撞（collision resistant）的当且仅当对任意PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> ,都有<spanclass="math display">\[Pr[Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>我们有时候省略掉 <span class="math inline">\(Gen\)</span> ，直接称<span class="math inline">\(H\)</span> 或 <spanclass="math inline">\(H^s\)</span>为抗碰撞哈希函数.此外，在实践中，有很多非键控抗碰撞哈希函数.</p><p><strong>更弱的抗碰撞</strong> + 2nd p.r. 给一个均匀随机的 <spanclass="math inline">\(x\)</span>，找 <spanclass="math inline">\(x&#39;\)</span> 使得 <spanclass="math inline">\(H^s(x)=H^s(x&#39;)\)</span>. + p.r.给一个均匀随机的 <span class="math inline">\(y\)</span>, 找 <spanclass="math inline">\(x&#39;\)</span> 使得 <spanclass="math inline">\(y=H^s(x&#39;)\)</span>.</p><p><span class="math display">\[ c.r. \Rightarrow 2nd\ p.r. \Rightarrowp.r.\]</span></p><h4 id="定义域扩展">定义域扩展</h4><p>使用定长的 c.r. 哈希来构造对任意长度的哈希.</p><p>Merkle-Damgard Transform: + “Partition and Padding”. + <imgsrc="/image/crypto/Partition_and_Padding.png"alt="Partition and Padding" /> + “Chained-Compressing”. + <imgsrc="/image/crypto/Chained-Compressing.png"alt="Chained-Compressing" /></p><blockquote><p>If (Gen, h) is collision resistant, the (Gen, H) is also collisionresistant. Pf. 考虑 <span class="math inline">\(|x|=|x&#39;|\)</span> 和<span class="math inline">\(|x|\neq|x&#39;|\)</span> 两种情况.</p></blockquote><h3 id="mac-与-哈希">MAC 与 哈希</h3><h4 id="hash-and-mac">Hash and MAC</h4><p>至此，我们有对定长消息做认证的MAC，也有将任意长度的串映射到定长串的Hash，二者的结合注定发生奇妙的化学反应.</p><p>令 <span class="math inline">\(\Pi=(Mac,Vrfy)\)</span> 是对长度为<span class="math inline">\(l(n)\)</span> 的消息的 MAC , <spanclass="math inline">\(\Pi_H=(Gen_H,H)\)</span> 是输出为定长 <spanclass="math inline">\(l(n)\)</span> 的哈希函数, 构造一个MAC <spanclass="math inline">\(\Pi&#39;=(Gen&#39;,Mac&#39;,Vrfy&#39;)\)</span>适用于任意长度的消息： + Gen': 输入 <spanclass="math inline">\(1^n\)</span> ，均匀选择 <spanclass="math inline">\(k\in\{0,1\}^n\)</span> , 运行 <spanclass="math inline">\(Gen_H(1^n)\)</span> 得到 <spanclass="math inline">\(s\)</span> , 密钥 <spanclass="math inline">\(k&#39;:=&lt;k,s&gt;\)</span>. + Mac': 输入密钥<span class="math inline">\(&lt;k,s&gt;\)</span> , 和任意长度的消息<span class="math inline">\(m\in\{0,1\}^*\)</span> , 输出 <spanclass="math inline">\(t \leftarrow Mac_k(H^s(m))\)</span>. + Vrfy':输入密钥 <span class="math inline">\(&lt;k,s&gt;\)</span> , 消息 <spanclass="math inline">\(m\in\{0,1\}^*\)</span> , tag <spanclass="math inline">\(t\)</span> , 输出1当且仅当 <spanclass="math inline">\(Vrfy_k(H^s(m),t)=1\)</span>.</p><p>如果 <span class="math inline">\(MAC\)</span> 是secure的 , 且 <spanclass="math inline">\(\Pi_H\)</span> 是抗碰撞的，那么上述构造是对任意长度的消息的一个secure的MAC.（Pf.两种情况分别规约到c.r.Hash和secure MAC上）</p><h4 id="hmac">HMAC</h4><figure><img src="/images/HMAC.png" alt="HMAC" /><figcaption aria-hidden="true">HMAC</figcaption></figure><h3 id="针对哈希的一般攻击">针对哈希的一般攻击</h3><p>由鸽巢原理，找 <span class="math inline">\(2^{l+1}\)</span>个值总能找到碰撞 <span class="math inline">\(\Theta(2^l)\)</span>,有没有可能少找一些期望有一定概率找到呢？</p><p>生日问题： &gt; If q people are in a room, what is the probabilitythat two of them have the same birthday?</p><p>若 <span class="math inline">\(y_1,...,y_q\)</span> 是从 <spanclass="math inline">\(\{1,...,N\}\)</span> 中均匀抽取的，当 <spanclass="math inline">\(q=\Theta(N^{1/2})\)</span> 时，有接近 1/2的概率存在碰撞.</p><blockquote><p>The above imply that a hash function with n-bit output is limited ton/2 bits of security.</p></blockquote><h2id="单向函数与硬核谓词hard-core-predicates">单向函数与硬核谓词(Hard-CorePredicates)</h2><ul><li>单向函数</li><li>OWF候选名单</li><li>硬核谓词<ul><li>任意OWF的硬核谓词</li></ul></li><li>使用OWF构造PRG</li></ul><h3 id="单向函数">单向函数</h3><p>什么是OWF？ + easy to compute + hard to invert</p><p>我们给出OWF的<strong>形式化定义</strong>.一个函数 <spanclass="math inline">\(f:\{0,1\}^* \rightarrow \{0,1\}^*\)</span> 是<strong>one-way</strong> 如果满足以下两个条件： 1. Easy to compute :存在PPT的算法 <span class="math inline">\(M_f\)</span> 来计算 f(多项式时间内可计算) 2. Hard to invert: <spanclass="math inline">\(\forall PPT \mathcal{A} ,Pr_{x\overset{\$}{\leftarrow}\{0,1\}^n}[\mathcal{A}(1^n,f(x))\inf^{-1}(f(x))]\leq negl(n)\)</span>.</p><p>注意，此处的 <spanclass="math inline">\(x\overset{\$}{\leftarrow}\{0,1\}^n\)</span>是均匀选取的，并且我们只要求给出原象，不求给出 <spanclass="math inline">\(x\)</span> 本身.</p><p>我们当然也有inverting experiment <spanclass="math inline">\(Invert_{\mathcal{A},f}(n)\)</span>: 1. 均匀选取<span class="math inline">\(x\in\{0,1\}^n\)</span> , 计算 <spanclass="math inline">\(y:=f(x)\)</span> 2. 敌手以 <spanclass="math inline">\(y\)</span> 为输入， 输出 <spanclass="math inline">\(x&#39;\)</span> 3. <spanclass="math inline">\(Invert_{\mathcal{A},f}(n)=1/ iff./f(x&#39;)=y\)</span></p><p>Hard to invert: 对任意PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , <spanclass="math inline">\(Pr[Invert_{\mathcal{A},f}(n)=1]\leqnegl(n)\)</span>.</p><h3 id="owf的候选名单">OWF的候选名单</h3><p>事实上，我们并不知道是不是真的有OWF:(但是我们还是有些候选函数，至少我们至今没有发现PPT的算法来invert它们...</p><ul><li>整数分解</li><li>子集和问题</li><li>离散对数问题</li></ul><h3 id="硬核谓词hard-core-predicates">硬核谓词(Hard-CorePredicates)</h3><p><span class="math inline">\(f(x)\)</span> 是OWF意味着我们无法从 <spanclass="math inline">\(f(x)\)</span> 中还原出 <spanclass="math inline">\(x\)</span>, 但并不意味着 <spanclass="math inline">\(f(x)\)</span> 不会泄露 <spanclass="math inline">\(x\)</span> 的信息，就比如 <spanclass="math inline">\(f(x_1||x_2)=x_1||g(x_2)\)</span>.</p><p>我们定义函数 <span class="math inline">\(f\)</span> (不一定是OWF)的硬核谓词 <span class="math inline">\(hc:\{0,1\}^*\rightarrow\{0,1\}\)</span> 如果 <span class="math inline">\(hc\)</span>可以在多项式时间内计算，并且对任意PPT的 <spanclass="math inline">\(\mathcal{A}\)</span> 有 <spanclass="math display">\[Pr_{x\overset{\$}{\leftarrow}\{0,1\}^n}[\mathcal{A}(1^n,f(x))=hc(x)]\leq1/2 + negl(n)\]</span>.</p><p>这儿的 <spanclass="math inline">\(x\overset{\$}{\leftarrow}\{0,1\}^n\)</span>依然是均匀选取的.另外，我们没要求函数 <spanclass="math inline">\(f\)</span> 一定是OWF.</p><h4 id="任意owf的硬核谓词">任意OWF的硬核谓词</h4><p><strong>Goldreich-Levin Theorem</strong>: Assume one-way function(resp. permutation) exists. Then there exists a one-way function (resp.permutation) <span class="math inline">\(g\)</span> and a hard-corepredicate <span class="math inline">\(hc\)</span> of <spanclass="math inline">\(g\)</span>.</p><figure><img src="/image/crypto/Goldreich-Levin-Theorem.png"alt="Goldreich-Levin Theorem" /><figcaption aria-hidden="true">Goldreich-Levin Theorem</figcaption></figure><p>这里的 <span class="math inline">\(r\)</span> 是均匀随机选取的.</p><h3 id="使用owf构造prg">使用OWF构造PRG</h3><p>令 <span class="math inline">\(f\)</span> 是一个one-waypermutation，<span class="math inline">\(hc\)</span> 是 <spanclass="math inline">\(f\)</span> 的硬核谓词，那么 <spanclass="math inline">\(G(s)=f(s)||hc(s)\)</span> 是一个 PRG 扩展因子为<span class="math inline">\(l(n)=n+1\)</span>.</p><p>下面开始叠叠乐！</p><p>如果有一个 扩展因子为 <span class="math inline">\(n+1\)</span>的PRG，那么对任意多项式 <span class="math inline">\(poly\)</span>，存在PRG <span class="math inline">\(\hat{G}\)</span> 扩展因子为 <spanclass="math inline">\(poly(n)\)</span>.</p><figure><img src="/image/crypto/polyPRG.png" alt="polyPRG" /><figcaption aria-hidden="true">polyPRG</figcaption></figure><h2 id="数论与密码学困难度假设">数论与密码学困难度假设</h2><h3 id="基础知识">基础知识</h3><p>带余除法唯一表示：<span class="math display">\[a \in \mathbb{Z} , b\in \mathbb{Z}_+ , \exists \ unique\ q,r \in \mathbb{Z}, s.t.\ a=qb+r,\0\leq r\leq b.\]</span> <strong>最大公因数</strong> <spanclass="math display">\[a,b\in \mathbb{Z}_+, \exists X,Y \in \mathbb{Z},\s.t.\ Xa+Yb=gac(a,b).\]</span> 此外，<spanclass="math inline">\(gcd(a,b)\)</span> 是满足上述方程的最小正整数.</p><blockquote><p>欧几里得算法与拓展欧几里得算法.</p></blockquote><p>对大于等于1的整数 <span class="math inline">\(b,N\)</span> , <spanclass="math inline">\(b\)</span> 在模 <spanclass="math inline">\(N\)</span> 意义上有逆元当且仅当 <spanclass="math inline">\(gcd(b,N)=1\)</span>.</p><blockquote><p>拓展欧几里得算法.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>    x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>  y -= a / b * x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>群</strong>是一种代数结构，由一个集合 <spanclass="math inline">\(\mathbb{G}\)</span> 和定义在集合上的二元运算 <spanclass="math inline">\(\circ\)</span> 构成，满足: + 封闭性 + 结合律 +有逆元 + 有单位元 <img src="/image/crypto/group.png" alt="group" /></p><p>$N=_i p_i^{e_i} $ , 其中 <span class="math inline">\(p_i\)</span>是不同的素数， <span class="math inline">\(e_i\geq 1\)</span>, 那么有<span class="math inline">\(\phi(N)=\Pi_ip_i^{e_i-1}(p_i-1)\)</span>.</p><p><spanclass="math inline">\(g^0\overset{def}{=}1,g^{-m}\overset{def}{=}(g^{-1})^m\)</span>.</p><p>令 <span class="math inline">\(\mathbb{G}\)</span> 是有限群 <spanclass="math inline">\(m=|\mathbb{G}|\)</span> ,则 <spanclass="math inline">\(\forall g \in \mathbb{G} ,g^m=1\)</span>.</p><p><strong>Fermat-Euler Theorem</strong> <spanclass="math inline">\(\forall N&gt;1, a\in Z_N^* ,a^\phi(N)=1\ mod\N.\)</span></p><blockquote><p>Fermat-Euler Theorem 在计算模下求幂和非素性检测有用</p></blockquote><h3 id="中国剩余定理">中国剩余定理</h3><p>常用来解同余方程.</p><figure><img src="/image/crypto/CRT.png" alt="CRT" /><figcaption aria-hidden="true">CRT</figcaption></figure><blockquote><p>from <ahref="https://oi-wiki.org/math/number-theory/crt/#%E5%BC%95%E5%85%A5">OI-Wiki</a></p></blockquote><p>群论下的中国剩余定理：</p><figure><img src="/image/crypto/gCRT.png" alt="gCRT" /><figcaption aria-hidden="true">gCRT</figcaption></figure><p>求逆：</p><figure><img src="/image/crypto/crt-eg3.png" alt="crt-eg3" /><figcaption aria-hidden="true">crt-eg3</figcaption></figure><figure><img src="/image/crypto/crt-eg3-.png" alt="crt-eg3—" /><figcaption aria-hidden="true">crt-eg3—</figcaption></figure><h3 id="factoring-assumption">Factoring Assumption</h3><p><strong><spanclass="math inline">\(GenModulus(1^n)\)</span></strong>: + 输出 <spanclass="math inline">\((N,p,q)\)</span> + <spanclass="math inline">\(N=pq\)</span> + 除可忽略的概率 <spanclass="math inline">\(negl(n)\)</span> 外，<spanclass="math inline">\(p,q\)</span> 均为 <spanclass="math inline">\(n-bit\)</span> 素数.</p><p><strong>The factoring experiment</strong> <spanclass="math inline">\(Factor_{\mathcal{A},GenModulus}(n)\)</span>: 1.<span class="math inline">\((N,p,q) \leftarrow GenModulus(1^n)\)</span>2. 给 <span class="math inline">\(\mathcal{A}\)</span> <spanclass="math inline">\(N\)</span> , 要其输出 <spanclass="math inline">\(p&#39;,q&#39;\)</span> 3. <spanclass="math inline">\(Factor_{\mathcal{A},GenModulus}(n)=1\)</span> iff.<span class="math inline">\(N=p&#39;q&#39;\)</span>.</p><p><strong>Factoring is hard relative to GenModulus</strong> if for allPPT algorithms <span class="math inline">\(\mathcal{A}\)</span> thereexists a negligible function <span class="math inline">\(negl\)</span>such that <spanclass="math display">\[Pr[Factor_{\mathcal{A},GenModulus}(n)=1]\leqnegl(n).\]</span></p><p><strong>FactoringAssumption</strong>就是假设存在这么一个<strong>GenModulus</strong>使factoring是hard的.</p><h3 id="rsa-problem">RSA problem</h3><p><span class="math inline">\(GenRSA(1^n)\)</span> : + 输出 <spanclass="math inline">\((N,e,d)\)</span> + <spanclass="math inline">\(N\)</span> 是两个 <spanclass="math inline">\(n-bit\)</span> 素数的乘积 + <spanclass="math inline">\(gcd(e,\phi(N))=1, ed=1\ mod\ \phi(N)\)</span></p><p>The RSA experiment <spanclass="math inline">\(RSA-inv_{\mathcal{A},GenRSA}(n)\)</span>: 1. <spanclass="math inline">\((N,e,d)\leftarrow GenRSA(1^n)\)</span> 2. 均匀选取<span class="math inline">\(y\in \mathbb{Z}_N^*\)</span>. 3. 给 <spanclass="math inline">\(\mathcal{A}\)</span> <spanclass="math inline">\((N,e,y)\)</span> , 输出 <spanclass="math inline">\(x\in \mathbb{Z}_N^*\)</span> 4. <spanclass="math inline">\(RSA-inv_{\mathcal{A},GenRSA}(n)=1\)</span> iff.<span class="math inline">\(x^e=y\)</span>.</p><p><strong>The RSA problem is hard relative to GenRSA</strong> if forall PPT algorithms <span class="math inline">\(\mathcal{A}\)</span>there exists a negligible function <spanclass="math inline">\(negl\)</span> such that <spanclass="math display">\[Pr[RSA-inv_{\mathcal{A},GenRSA}(n)=1]\leqnegl(n).\]</span></p><p><strong>RSAAssumption</strong>就是假设存在这么一个<strong>GenRSA</strong>使RSAproblem是hard的.</p><h3 id="循环群">循环群</h3><figure><img src="/image/crypto/cyclic_group.png" alt="cyclic_group" /><figcaption aria-hidden="true">cyclic_group</figcaption></figure><h3 id="离散对数问题">离散对数问题</h3><p>对于 <span class="math inline">\(h\in \mathbb{G}\)</span> , <spanclass="math inline">\(\mathbb{G}\)</span> 是一个循环群, 存在唯一的 <spanclass="math inline">\(x\in Z_q, q=|\mathbb{G}|\)</span>, 使得 <spanclass="math inline">\(g^x=h\)</span>, 我们称 <spanclass="math inline">\(x\)</span> 是 <spanclass="math inline">\(h\)</span> 的离散对数 w.r.t <spanclass="math inline">\(g\)</span> , 写作 <spanclass="math inline">\(x=log_g\ h\)</span>.</p><p>离散对数问题就是求解一个在循环群上均匀抽取的元素的离散对数，可定义为以下试验.</p><p>The discrete-logarithm experiment <spanclass="math inline">\(DLog_\{\mathcal{A},\mathcal{G}\}\)</span>: 1.<span class="math inline">\((\mathbb{G},q,g)\leftarrow\mathcal{G}(1^n)\)</span>, 其中 <spanclass="math inline">\(\mathbb{G}\)</span> 是循环群, <spanclass="math inline">\(q=|\mathbb{G}|,\overline{||q||=n}\)</span>, <spanclass="math inline">\(g\)</span> 是生成元. 2. $h $ 3. 给 <spanclass="math inline">\(\mathcal{A}\)</span> 输入 <spanclass="math inline">\(\mathbb{G},q,g,h\)</span> , 其输出 <spanclass="math inline">\(x\in \mathbb{Z}_q\)</span>. 4. <spanclass="math inline">\(DLog_\{\mathcal{A},\mathcal{G}\}=1\)</span> iff.<span class="math inline">\(g^x=h\)</span>.</p><p>We say that <strong>the discrete-logarithm problem is hard relativeto <span class="math inline">\(\mathcal{G}\)</span> </strong>if for allPPT algorithms <span class="math inline">\(\mathcal{A}\)</span> thereexists a negligible function <span class="math inline">\(negl\)</span>such that <span class="math display">\[Pr[DLog_\{\mathcal{A},\mathcal{G}\}=1]\leq negl(n) .\]</span></p><p>离散对数假设就是假定存在这么一个 <spanclass="math inline">\(\mathcal{G}\)</span>.</p><h3 id="d-h-problem">D-H Problem</h3><p>The <strong>computational</strong> D-H (CDH) problem: Given <spanclass="math inline">\(g\)</span>, <spanclass="math inline">\(g^x\)</span> and <spanclass="math inline">\(g^y\)</span>, can you compute <spanclass="math inline">\(g^{xy}\)</span>?</p><p>The <strong>decisional</strong> D-H (DDH) problem: Given <spanclass="math inline">\(g\)</span>, <spanclass="math inline">\(g^x\)</span>, <spanclass="math inline">\(g^y\)</span>, and g^{xy}, can you differentiate<span class="math inline">\(g^{xy}\)</span> from a uniform random groupelement <span class="math inline">\(g^z\)</span>?</p><p>The D-H assumptions are assumptions that there exists instances ofCDH/DDH problem which are hard.</p><blockquote><p>Closed related to the discrete-logarithm problem, but <strong>notknown</strong> to be equivalent.</p></blockquote><h2 id="密钥管理与公钥加密变革">密钥管理与公钥加密变革</h2><h3 id="kdc">KDC</h3><p>A secure key-distribution protocol using a KDC:</p><figure><img src="/image/crypto/Needham-Schroeder.png"alt="Needham-Schroeder" /><figcaption aria-hidden="true">Needham-Schroeder</figcaption></figure><h3 id="d-h-key-exchange-protocol">D-H key-exchange protocol</h3><p>D-H key-exchange protocol 的构造如下，其中 <spanclass="math inline">\(\mathbb{G}\)</span> 是循环群, <spanclass="math inline">\(q=|\mathbb{G}|,||q||=n\)</span>, <spanclass="math inline">\(g\)</span> 是生成元$:</p><figure><img src="/image/crypto/D-H-exchange.png" alt="D-H-exchange" /><figcaption aria-hidden="true">D-H-exchange</figcaption></figure><p><strong>安全性</strong>：我们把脚本协议双方来往的所有信息记录下来丢给敌手，如果敌手在此加持下无法区分真正的密钥和一个随机抽取的假密钥，那么协议应该是安全的。具体的：</p><figure><img src="/image/crypto/KE.png" alt="KE" /><figcaption aria-hidden="true">KE</figcaption></figure><p>A key-exchange protocol <span class="math inline">\(\Pi\)</span> issecure in the presence of an eavesdropper if for all PPT adversaries<span class="math inline">\(\mathcal{A}\)</span> there is a negligiblefunction <span class="math inline">\(negl\)</span> such that <spanclass="math display">\[ Pr[KE^{eav}_{\mathcal{A},\Pi}(n) = 1] ≤ 1/2+negl(n).\]</span></p><figure><img src="/image/crypto/KEsecure.png" alt="KEsecure" /><figcaption aria-hidden="true">KEsecure</figcaption></figure><blockquote><p>我们在这儿使用了KE试验的变体，证明时将DDH问题规约到KE上来.</p></blockquote><h2 id="公钥加密">公钥加密</h2><h3 id="定义-2">定义</h3><p>公钥加密方案是一个PPT算法的三元组(Gen,Enc,Dec),其中Gen生成一对密钥(pk,sk),Enc使用公钥pk进行加密,Dec则使用私钥sk进行解密.具体的<strong>定义</strong>见下图：</p><figure><img src="/image/crypto/public-key_encryption.png"alt="public-key_encryption" /><figcaption aria-hidden="true">public-key_encryption</figcaption></figure><h3 id="安全性">安全性</h3><h4 id="cpa">CPA</h4><p>在下图所定义的EAV试验中，敌手 <spanclass="math inline">\(\mathcal{A}\)</span> 是被给予了 <spanclass="math inline">\(pk\)</span>的，以及试验中的加密采用了公钥加密方案，除此之外和私钥加密时定义的EAV试验是一样的。但是正由于敌手被给予了<span class="math inline">\(pk\)</span>，而加密方案又是公开的，因此敌手相当于得到了Enc的权限，从而一旦secure天然就有CPA-secure.</p><figure><img src="/image/crypto/pubeav.png" alt="pubeav" /><figcaption aria-hidden="true">pubeav</figcaption></figure><p>同样我们有根据试验所定义的<strong>安全性</strong>.</p><figure><img src="/image/crypto/Pub-secure.png" alt="Pub-secure" /><figcaption aria-hidden="true">Pub-secure</figcaption></figure><p>如果一个公钥加密方案是CPA-secure，它对多消息加密天然也是CPA-secure的.</p><p>此外，定长的CPA-secure加密可以推出任意长的CPA-secure加密(切成定长块，和多消息加密差不多了就).</p><h4 id="cca">CCA</h4><p>私钥当然是不能给敌手的，因此敌手还是以神谕基的形式调用Dec.</p><figure><img src="/image/crypto/CCA-secure.png" alt="CCA-secure" /><figcaption aria-hidden="true">CCA-secure</figcaption></figure><p>我们当然也有基于试验的安全性定义.</p><figure><img src="/image/crypto/CCA-secure-def.png" alt="CCA-secure-def" /><figcaption aria-hidden="true">CCA-secure-def</figcaption></figure><p>如果一个公钥加密方案是CCA-secure，它对多消息加密天然也是CCA-secure的.但是我们无法将定长CCA安全方案推广到任意长了，因为敌手完全可以打乱顺序进行解密...</p><h3 id="杂交加密">杂交加密</h3><figure><img src="/image/crypto/hybrid-encryption.png"alt="hybrid-encryption" /><figcaption aria-hidden="true">hybrid-encryption</figcaption></figure><p>KEM: 一个黑盒，输入公钥，为私钥加密生成对应的私钥和私钥密文.</p><p>DEM: 也就是公钥加密.</p><blockquote><p>A key-encapsulation mechanism (KEM) is a public-key primitive thatefficiently generates an encryption key for the private-key encryption kand its ciphertext c in a hybrid encryption scheme. Accordingly, theprivate-key encryption scheme is called a data-encapsulation mechanism(DEM) here.</p></blockquote><figure><img src="/image/crypto/KEM-DEM.png" alt="KEM-DEM" /><figcaption aria-hidden="true">KEM-DEM</figcaption></figure><h3 id="cdhddh-based-encryption">CDH/DDH-Based Encryption</h3><p>The El Gamal encryption scheme is described in the following:</p><figure><img src="/image/crypto/El-Gamal-encryption.png"alt="El-Gamal-encryption" /><figcaption aria-hidden="true">El-Gamal-encryption</figcaption></figure><p>安全性：</p><figure><img src="/image/crypto/El-Gamal-encryption-secure.png"alt="El-Gamal-encryption-secure" /><figcaption aria-hidden="true">El-Gamal-encryption-secure</figcaption></figure><blockquote><p>构造一个完全随机的 <span class="math inline">\(&lt;g^y,g^z\cdotm\)</span> 来证明.</p></blockquote><p>El Gamal encryption 不是CCA安全的！！！具有延展性(<spanclass="math inline">\(&lt;c_1,c_2&gt;,&lt;c_1^2,c_2^2&gt;\)</span>).</p><h3 id="rsa">RSA</h3><h4 id="plain-rsa">Plain RSA</h4><figure><img src="/image/crypto/RSA-key-generation.png"alt="RSA-key-generation" /><figcaption aria-hidden="true">RSA-key-generation</figcaption></figure><figure><img src="/image/crypto/plain-RSA-encryption-scheme.png"alt="plain-RSA-encryption-scheme" /><figcaption aria-hidden="true">plain-RSA-encryption-scheme</figcaption></figure><p>plainRSA不是CPA安全的.事实上任何确定性的公钥加密算法都不会是CPA安全的！此外，我们无法通过RSAassumption来证明其安全性...</p><h4 id="padded-rsa">Padded RSA</h4><figure><img src="/image/crypto/Padded-RSA.png" alt="Padded-RSA" /><figcaption aria-hidden="true">Padded-RSA</figcaption></figure><figure><img src="/image/crypto/PKCS.png" alt="PKCS" /><figcaption aria-hidden="true">PKCS</figcaption></figure><h2 id="数字签名机制">数字签名机制</h2><p>TBD</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CRYPTO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成长的短视</title>
    <link href="/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/"/>
    <url>/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/</url>
    
    <content type="html"><![CDATA[<p>小百合系版"有像我一样不会写代码的cser么?"回复节选</p><ul><li>我们都是活生生的人,从小就被不由自主地教导用最小的付出获得最大的得到,经常会忘记我们究竟要的是什么. 我承认我完美主义,但我想每个人心中都有那一份求知的渴望和对真理的向往,"大学"的灵魂也就在于超越世俗, 超越时代的纯真和理想--我们不是要讨好企业的毕业生, 而是要寻找改变世界的力量. -- jyy</li><li>教育除了知识的记忆之外, 更本质的是能力的训练, 即所谓的training.而但凡training就必须克服一定的难度, 否则你就是在做重复劳动,能力也不会有改变. 如果遇到难度就选择退缩,或者让别人来替你克服本该由你自己克服的难度,等于是自动放弃了获得training的机会, 而这其实是大学专业教育最宝贵的部分.-- etone</li><li>这种"只要不影响我现在survive, 就不要紧"的想法其实非常的利己和短视:你在专业上的技不如人, 迟早有一天会找上来,会影响到你个人职业生涯的长远的发展; 更严重的是,这些以得过且过的态度来对待自己专业的学生,他们的survive其实是以透支南大教育的信誉为代价的 --如果我们一定比例的毕业生都是这种情况, 那么过不了多久,不但那些混到毕业的学生也没那么容易survive了,而且那些真正自己刻苦努力的学生, 他们的前途也会受到影响. -- etone</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>名师导学期中</title>
    <link href="/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/"/>
    <url>/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h1id="关于高效寻找适用于锂-空气电池催化剂的思考">关于高效寻找适用于锂-空气电池催化剂的思考</h1><h2 id="介绍研究背景和现状">介绍研究背景和现状</h2><h3 id="研究背景">研究背景</h3><p>煤、石油、天然气等化石能源的日益枯竭，以及化石燃料燃烧带来的诸多环境问题，迫使人们寻求、开发清洁高效的可再生能源和储能系统。锂-空气电池（<spanclass="math inline">\(Li-O_2\)</span>电池）以金属锂作为负极，从空气中直接获取氧气进行正极反应而无需将氧气存储在电池内部，具有非常高的理论比能量(约<spanclass="math inline">\(11140Wh·kg^{-1}\)</span>)，这一数值非常接近汽油的理论比能量（约<spanclass="math inline">\(13kWh·kg^{-1}\)</span>）。这使得锂-空气电池在新能源汽车领域有着较好的应用前景，受到了人们的广泛关注。相关领域经过多年发展，针对锂-空气电池的研究逐渐深入，成果显著，锂-空气电池也是被视为极具应用前景的下一代储能系统之一，但锂-空气电池体系仍存在一些亟待解决的技术问题。</p><h3 id="研究现状">研究现状</h3><p>依据工作环境和介质条件的不同，当前被研究最多的锂空气电池主要是有机电解液、有机-水组合电解液以及全固态电解质三种类型。</p><p>有机体系锂-空气电池的结构相对简单，符合经典的摇椅式电池结构，能量密度最高、体系最为稳定。其选择溶解有钾盐的有机溶剂为电解液，如醚、烯酯等。放电时，氧气在正极被还原并与电解液里的<spanclass="math inline">\(Li^+\)</span>结合，金属锂在负极被氧化生成 <spanclass="math inline">\(Li^+\)</span>进入电解液。虽然正极的反应方式容易使人们联想到氢氧燃料电池，但与氢氧燃料电池不同的是，锂-空气电池放电会产生锂的绝缘难溶氧化物，可能会使空气通道被阻塞、电池极化增大从而导致放电提前终止，从而影响放电容量。另外，由于金属锂的活泼性，空气中的水、二氧化碳等诸多成分都会造成金属锂的腐蚀，影响电池寿命。事实上，已经有研究报道了水分子（相对湿度）对有机锂-空气电池的影响：水分子会使得放电容量有所增加，但会对电池的循环性能和倍率性能造成负面影响<spanclass="math inline">\(^4\)</span>。除此之外，有机体系锂-空气电池还存在着充放电过程空气正极过电位过大、充放电效率低等问题，对催化剂的性能、催化剂的稳定性提出了较高的要求，这也是当前许多研究人员正在关注、研究的重要课题。</p><p>为解决有机体系中正极反应会生成绝缘难溶氧化物问题，周豪慎教授研究组首先提出有机-水组合电解液型锂-空气电池。在这种锂-空气电池里，<spanclass="math inline">\(LiOH\)</span>水溶液和有机电解液分别与电池的正负极接触，二者用<spanclass="math inline">\(LISICON\)</span>隔开。研究表明，该类型电池可连续放电<spanclass="math inline">\(500h\)</span>以上，比容量高达<spanclass="math inline">\(50000mAh·g^{-1}\)</span>。在后续研究中，研究人员针对<spanclass="math inline">\(LISICON\)</span>在碱性环境不稳定等问题进行了改进，进一步提高了电池的稳定性与能量密度。另外，在组合电解液型电池的基础上，研究人员还提出了液流型锂-空气电池。有机-水组合电解液和液流型锂-空气电池都解决了有机电解液型电池中存在的正极产生绝缘氧化物影响电池性能的问题，更为接近燃料电池，同时使电池受空气中其他成分影响大幅减小，持续放电能力增强<spanclass="math inline">\(^4\)</span>。但此类型电池对隔膜材料的稳定性和离子电导率提出了较高要求，仍存在较大过电位损失这一问题。</p><p>事实上，虽然锂-空气电池理论能量密度高，应用潜力巨大，但还无法真正实现商业化，仍有诸多问题亟待解决：</p><ul><li>正极充放电过程有较大的过电位</li><li>实际容量要比理论容量低</li><li>循环过程中的容量衰减较大</li></ul><h2 id="提出重要科学问题">提出重要科学问题</h2><p>当前的锂-空气电池的空气正极在充放电过程中均存在有较大的过电位问题，这使得空气正极被视作限制锂-空气电池发展的一大重要因素，寻找合适的催化剂可能有效缓解、甚至解决这一问题。事实上，为解决这一问题，早有国内外研究人员对不同相中的氧还原反应深入研究，试图找到廉价、高效、稳定的催化剂材料<spanclass="math inline">\(^5\)</span>。既然寻找催化材料如此重要，我们是否有方法加速寻找适用于锂-空气电池的催化剂材料？</p><h2 id="对问题的分析和研究">对问题的分析和研究</h2><p>当前计算机技术飞速发展，机器学习已在诸多领域有了广泛应用，例如机器学习已成为高效预测蛋白质功能的有效手段，在酶功能预测领域有了广泛应用<spanclass="math inline">\(^1\)</span>。而酶本身是一种高效的有机催化剂，是否也可以利用机器学习等计算机技术帮助我们高效设计、寻找高效稳定的催化剂材料来有效解决锂-氧气电池存在的过电位问题呢？本文余下内容旨在讨论机器学习等计算机技术协助寻找、开发合适的催化剂材料助力锂-空气电池发展的可能性与展望。</p><p>首先是利用机器学习来加速寻求高效稳定的催化剂材料的可能性。机器学习等数据科学能够为研究人员提供了快速灵活的预测框架，在材料研发等领域展现出极大的应用前景。</p><p>在电池领域，机器学习已有诸多应用。锂离子电池能量密度高，循环次数多，广泛应用于移动设备和电动汽车领域。但锂离子电池的寿命难以预测，使得对人们不得不花费大量的时间与成本做破坏性实验来得到某种电池的寿命数据。这就导致在用户的实际应用中，由于缺乏电池的剩余寿命数据，无法准确制定电源计划。另外，锂离子电池的剩余电量甚至也无法通过传统方法来精准预测。而随着人工智能技术的发展，研究人员发现可以利用深度学习等技术很好的解决这些问题。人们只需要提供电池使用一段时间的相关数据，就可利用机器学习技术，参照过去得到的数据信息，精准预测电池的剩余寿命和剩余电量<spanclass="math inline">\(^2\)</span>。与我们论题更为相关的电池材料方面，机器学习也已经在发挥重要作用。各种材料具有复杂的不同的性质，当人们采用不同的材料组合时，这些材料的性质相互影响叠加在一起才能决定电池的实际性能。人工穷举所有的材料组合显然是个难以完成的任务，而机器学习技术可以利用计算机的计算、存储能力，通过学习过去已有的实验资料高效而准确的筛选材料组合，从而大幅提高研发效率<spanclass="math inline">\(^2\)</span>。</p><p>在催化剂领域，机器学习也早已有了广泛的应用。除去上文提及的对酶的结构、功能的预测外，机器学习在无机催化领域也发挥着巨大的作用。温室效应的加剧是人们不得不面临的一个问题便是对<spanclass="math inline">\(CO_2\)</span>的处理。二氧化碳的电还原便是实现二氧化碳回收的重要方法之一。和锂-空气电池类似，此技术需要寻找高性能的电催化剂。近些年，诸多研究者利用大数据来辅助新型催化剂的开发，提高了开发效率，降低了开发成本，加速了二氧化碳电还原技术的发展<spanclass="math inline">\(^2\)</span>。此外，机器学习在搜寻新型双钙钛矿氧化物光催化剂领域也起到了重要的加速作用<spanclass="math inline">\(^3\)</span>。</p><p>锂-空气电池的空气正极通常包括防水层、集流体、催化层等部分<spanclass="math inline">\(^4\)</span>。多数情况，开发可有效降低锂-空气电池过电位的催化材料可以视为开发合适的电池材料的一个子任务。由上述介绍，我们知道机器学习已经在催化化学领域和电池材料领域有了广泛而重要的应用，利用机器学习等技术来加速研发适用于锂-空气电池的高效、稳定催化材料显然也是可能的。</p><h2 id="结果讨论与展望">结果讨论与展望</h2><p>正如上文所述，利用机器学习技术加速开发合适的正极催化材料来有效缓解、解决锂-空气电池充放电过程中的较大过电位问题是可能的。机器学习等方法相当依赖训练数据，为了得到更好的预测结果，除了需要选择、开发更合适的算法之外，还需要建立、完善相应的数据库，已加强训练效果。此外，选择、开发合适的算法涉及到学科交叉，这意味着数据科学研究者和自然科学家之间需要进行充分的对接。最后，机器学习方法不应与理论分析分离。由于机器学习归根结底是依靠训练数据进行猜测，在未训练到的方面是不可靠的，纵使在已经得到充分训练的领域，在对其结果进行应用前也应对进行相应理论分析和实验研究，方能放心使用。</p><p>综上所述，相信借助机器学习技术的辅助能使锂-空气电池技术加速发展，从而推动能源技术发展，进而助力人类社会可持续发展。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>池燕飞, 李春, 冯旭东. 机器学习在蛋白质功能预测领域的研究进展[J].生物工程学报, 2023, 39(6): 2141-2157.</li><li>许建兵, 李翰实, 谭济民, 等. 机器学习在固体氧化物燃料电池, 锂电池,CO2 电还原催化剂中的研究进展[J]. 硅酸盐学报, 2022, 50(11).</li><li>万新阳, 章烨辉, 陆帅华, 等.机器学习加速搜寻新型双钙钛矿氧化物光催化剂[J]. 物理学报, 2022.</li><li>童圣富, 何平, 张雪苹, 等.基于有机和组合电解液的锂空气电池研究进展[J]. 电化学, 2015, 21(3):234.</li><li>王迪, 乔羽, 邓瀚, 等. 锂-空气电池研究进展与表征方法[J]. 催化学报,2019, 40(s1): 217.</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Review for Principles of Marxism</title>
    <link href="/2023/12/19/Review-for-Principles-of-Marxism/"/>
    <url>/2023/12/19/Review-for-Principles-of-Marxism/</url>
    
    <content type="html"><![CDATA[<h1 id="马原复习">马原复习</h1><blockquote><p>搬运自本人大一下马原复习文档</p></blockquote><h2 id="马克思主义">马克思主义</h2><ul><li><strong>马克思主义</strong>：由马克思和恩格斯创立，并为后继者所不断发展的科学理论体系，是关于科学社会以及人类思维发展的一般规律的学说，是关于社会主义必将代替资本主义最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。</li><li><strong>马克思主义的基本组成部分</strong>：马克思主义哲学、马克思主义政治经济学、科学社会主义。</li><li><strong>创立</strong>：三大先进思潮是德国古典哲学、英国古典政治经济学、英法空想社会主义。</li><li><strong>特征</strong>：科学性、人民性、实践性、发展性。</li></ul><h2 id="物质">物质</h2><ul><li><strong>物质</strong>：是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，不依赖我们的感觉而存在，为我们的感觉所复写、摄影、反映。</li><li><strong>哲学基本问题</strong>：一、存在和思维、物质和意识谁为本源的问题，即何者为第一性的问题（产生了唯物和唯心）；二、存在和思维、物质和意识是否具有同一性的问题，即思维能否正确反映存在，人能否认识和正确认知世界的问题（产生了可知论和不可知论）。</li><li><strong>马克思理论意义</strong>：坚持唯物主义一元论（非唯心一元or二元论），坚持能动的反映论和可知论，批判不可知论，体现了唯物论和辩证论的统一，克服形而上学唯物主义的缺陷，体现唯物主义自然观和历史观的统一，为彻底的唯物主义奠定了理论基础。</li><li><strong>物质和意识的相互作用</strong>：1.意识是人脑的机能和属性，是客观世界的主观映像，物质对意识的决定作用表现在意识的本质和起源上：意识在内容上是客观的，在形式上是主观的，体现了主观与客观形式的统一。2.物质决定意识，意识对物质具有反作用，这种反作用是意识的能动作用，表现在：第一，意识具有目的性和计划性；第二，意识具有创造性；第三，意识可以指导实践改造客观世界；第四，意识可以调控人的行为和生理活动。</li><li><strong>意识与人工智能</strong>：人工智能是人的意识能动性的一种特殊表现，是人的本质力量的对象化和现实化。人工智能不能超越人类。第一，人类意识是知情意的统一体，而人工智能只是对人类的理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形态。第二，社会性是人类意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性。第三，人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力。</li></ul><h2 id="实践和认识">实践和认识</h2><ul><li><strong>科学实践观的意义</strong>：1.克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础；2.建立了科学的、能动的、革命的反映论，实现了人类认识史上的变革；3.在人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础；4.为人类能动的认识和改造世界提供了基本的思想方法和工作方法。</li><li><strong>实践对认识的决定作用</strong>：实践是认识的来源，是认识发展的动力，是认识的目的，是检验认识真理性的唯一标准。</li><li><strong>实践的本质</strong>：是人类能动的改造世界的社会性的物质活动，具有客观实在性、自觉能动性和社会历史性三个基本特征。</li><li><strong>实践的结构</strong>：实践主体、实践客体、实践中介。</li><li><strong>实践的过程</strong>：实践目的的确定、主体通过中介或手段作用于客体、实践结果的检验和评价。</li><li><strong>认识的本质</strong>：主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。唯心主义认识路线否认认识是人脑对客观世界的反映，认为认识先于人的实践经验。旧唯物主义认识论以感性直观为基础，把人的认识看成消极的、被动的反映和接受外界对象，是直观的、消极被动的反映论。</li><li><strong>真理</strong>：是标志主观和客观相符合的哲学范畴，是对客观事物及其规律的正确反映。</li><li><strong>谬误</strong>：所谓谬误，是同客观事物及其发展规律相违背的认识，是对客观世界及其发展规律的歪曲反映。</li><li><strong>价值</strong>：价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义。</li><li><strong>真理与谬误的关系</strong>：第一，二者相互对立；第二，二者的对立是相对的，它们在一定条件下能够相互转化；第三，真理和谬误的对立统一关系表明，真理总是同谬误相比较而存在、相斗争而发展的。实践是检验真理的唯一标准。</li></ul><h2 id="人类社会的发展规律">人类社会的发展规律</h2><ul><li><strong>社会存在</strong>：社会存在是指社会物质生活条件，是社会生活的物质方面，主要包括自然地理环境、人口因素和物质生产方式。</li><li><strong>唯物史观和唯心史观</strong>：马克思主义产生之前，唯心史观占据统治地位。</li><li><strong>社会意识</strong>：是社会存在的反映，是社会生活的精神方面，社会意识是人们进行社会物质交往的产物。</li><li><strong>社会存在和社会意识的辩证关系</strong>：1.社会存在决定社会意识。社会意识是对社会存在的反映，并反作用于社会存在，社会存在的变化发展决定社会意识的变化发展；2.社会存在是社会意识的内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映；3.社会意识具有相对独立性，社会意识有时会落后于社会存在，有时会先于社会存在而变化发展；4.社会意识对社会发展具有能动的反作用，落后的社会意识对社会的发展起到阻碍作用，先进的社会意识可以正确预见社会发展方向和趋势，对社会的发展起到积极的推动作用。</li><li><strong>生产力</strong>：生产力是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量。</li><li><strong>基本要素</strong>：劳动资料、劳动对象、劳动者</li><li><strong>生产关系</strong>：人们在物质生产过程中形成的不以人的意志为转移的经济关系。</li><li><strong>生产力和生产关系的相互作用</strong>：生产力和生产关系是社会生产不可或缺的两个方面。第一，生产力决定生产关系。第二，生产关系对生产力具有能动的反作用。生产关系和生产力的相互作用是一个过程，表现为二者的矛盾作用。二者的矛盾运动规律的原理有重要的理论和现实意义：1.否定了单纯以道德为评判历史功过的是非标准的思想体系；2.是马克思主义政党指定路线方针和政策的重要依据。</li><li><strong>经济基础</strong>：是指由社会一定发展阶段的生产力所决定的生产关系的总和。</li><li><strong>上层建筑</strong>：建立在一定经济基础上的意识形态以及与之相适应的制度、组织和设施。</li><li><strong>阶级</strong>：在历史上一定的社会生产经济体系中所处地位不同的集团。</li><li><strong>人类社会的基本矛盾</strong>：生产力和生产关系、经济基础和上层建筑之间的矛盾。</li><li><strong>经济基础与上层建筑的关系</strong>：相互影响，相互作用。经济基础决定上层建筑；上层建筑对经济基础具有反作用；经济基础与上层建筑的相互作用构成二者的矛盾运动；经济基础和上层建筑之间的内在联系构成了上层建筑一定要适应经济基础状况的规律。</li><li><strong>社会形态的内涵</strong>：社会形态是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。社会形态包括社会的经济形态、政治形态和意识形态，是三者具体的历史的统一。</li><li><strong>社会基本矛盾</strong>：1.生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量。2.生产力是社会进步的根本内容，是衡量社会进步的根本尺度。3.社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展。</li><li><strong>主要矛盾和基本矛盾</strong>：社会基本矛盾和社会主要矛盾。二者不是同一概念，也不是同一层次。社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展；社会主要矛盾是社会基本矛盾的具体体现。</li><li><strong>科学技术在社会发展中的作用</strong>：1.科技革命是推动经济和社会发展的强大杠杆：对生产关系产生了深刻影响，对生产方式产生了巨大影响，促进了思维方式的改变；2.科学技术能够通过促进经济和社会发展造福于人类。</li><li><strong>阶级斗争</strong>：是社会基本矛盾在阶级社会的直接体现，是阶级社会发展的直接动力。</li></ul><h2 id="资本主义">资本主义</h2><ul><li><strong>劳动二重性</strong>：1.具体劳动：生产一定使用价值的具体形式的劳动；2.抽象劳动：人的脑力和体力耗费。3.二者在时间和空间上统一，是统一劳动过程不可分割的两个方面；另一方面，反映劳动的不同属性（具体to自然抽象to社会）。</li><li><strong>商品二因素</strong>：使用价值和价值。对立统一：对立表现在二者相互排斥不可兼得，统一表现在作为商品必须同时具有使用价值和价值两个因素。</li><li><strong>商品经济</strong>：不是从来就有的，而是在一定历史条件下，作为自然经济的对立物而产生和发展的。</li><li><strong>资本原始积累</strong>：以暴力手段是生产者和生产资料分离，资本迅速集中于少数人手中，资本主义得以迅速发展的历史过程。</li><li><strong>资本总公式和商品交换之间的矛盾</strong>：按照等价交换原则，交换不能创造新价值，而资本总公式表明资本在流通过程中创造了新价值，关键在于劳动力成为商品。</li><li><strong>剩余价值</strong>：剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值。</li><li><strong>绝对剩余价值</strong>：是指在必要的劳动时间不变的条件下，由于延长工作日的长度或提高劳动强度而生产的剩余价值。</li><li><strong>相对剩余价值</strong>：是指在工作日长度不变的条件下，通过缩短必要劳动时间而延长剩余劳动时间所生产的剩余价值。</li><li><strong>资本积累</strong>：把剩余价值转化为资本，或者说，剩余价值的资本化。</li><li><strong>劳动力成为商品的基本条件</strong>：劳动者在法律上是自由人，能把自己的劳动力当作自己的商品来支配，劳动者没有其他生产资料，没有生产资料来源，因而不得不一靠出卖劳动力为主。</li><li><strong>资本主义基本矛盾</strong>：生产社会化和生产资料资本主义私人占有之间的矛盾。</li><li><strong>资本主义经济危机的本质特征</strong>：生产过剩（一种相对过剩）。</li></ul><h2 id="资本主义发展和趋势">资本主义发展和趋势</h2><ul><li><strong>垄断</strong>：指少数资本主义大企业为了获得高额利润，通过相互协议或者联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制。垄断是从自由竞争中形成的，是作为自由竞争的对立面产生的，但是，垄断并不能消除竞争，反而使竞争变得更加复杂和剧烈。垄断没有消除产生竞争的经济条件；垄断过程需要通过竞争来维持；社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产全部包下来。</li><li><strong>经济全球化的表现</strong>：生产全球化、贸易全球化、金融全球化。</li><li><strong>动因</strong>：科学技术的进步和生产力的发展为经济全球化提供了坚实的物质基础和根本的推动力；跨国公司的发展为经济全球化提供了适宜的企业组织形式；各国经济体制的变革和国际经济组织的发展为经济全球化提供体制和组织保障。</li><li><strong>影响</strong>：1.积极作用：为发展中国家提供先进技术和管理经验，提供更多的就业机会，推动发展中国家的贸易发展，促进发展中国家跨国公司的发展。2.消极作用：发达国家和发展中国家在经济全球化过程中的地位和收益不平等，加剧了发展中国家的环境污染，一定程度上增加了经济风险。</li></ul><h2 id="社会主义从空想到科学">社会主义（从空想到科学）</h2><ul><li><strong>马克思剩余价值学说的意义</strong>：剩余价值学说深刻揭示了资本家剥削工人的秘密，揭示了无产阶级与资产阶级利益的根本对立，从而科学论证了无产阶级肩负的推翻资本主义旧世界建设社会主义新世界的历史使命，使人们找到了变革资本主义旧社会的力量和通向社会主义新社会的途径。</li><li><strong>唯物史观</strong>：深刻揭示了人类历史发展的一般规律，揭示了人民群众的历史主体作用，揭示了阶级斗争在阶级社会发展中的巨大作用，从而把人们对社会主义的追求建立在对社会发展客观规律科学认识的基础上，克服了空想社会主义者不懂得历史规律的根本缺陷。</li><li><strong>科学社会主义核心命题</strong>：资本主义必然灭亡，社会主义必然胜利。两个必然的根本依据是人类社会发展规律。两个绝不会是指：“无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的。”要把两个必然和两个绝不会联系起来全面把握。</li></ul>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>calculus</title>
    <link href="/2023/12/19/calculus/"/>
    <url>/2023/12/19/calculus/</url>
    
    <content type="html"><![CDATA[<blockquote><p>实测部分浏览器可能无法识别Latex公式，建议使用GoogleChrome或移步知乎食用！</p></blockquote><blockquote><p>本文搬运自本人知乎，原文链接为:https://zhuanlan.zhihu.com/p/627529870</p></blockquote><h1 id="常数项级数">常数项级数</h1><h2id="从正项级数的收敛判定到任意项级数的收敛判定">从正项级数的收敛判定到任意项级数的收敛判定</h2><h3 id="正项级数的收敛判定8种方法">正项级数的收敛判定（8种方法）</h3><p>如下：</p><p>1.定义法；2.柯西收敛；3.前n项部分和有上界；4.比较判别法；5.比较判别法（极限版本）（+p级数=阶估法）；6.比值（达朗贝尔）判别法；7.积分判别法；8.柯西根值.</p><h3id="任意项级数的收敛判定6种方法">任意项级数的收敛判定（6种方法）</h3><p>如下：1.定义法；2.柯西收敛；3.绝对收敛；4.使用柯西根值或达朗贝尔判别不绝对收敛时发散;5.迪利克雷判别法和阿贝尔判别法；6.交错级数的莱布尼茨判别法.</p><blockquote><p>先看必要条件是否满足（通项趋于0），再看是否绝对收敛（正项级数），若不绝对收敛，再看是否发散（迪阿莱）.</p></blockquote><h3 id="正部级数负部级数">正部级数&amp;负部级数</h3><p>定义：</p><p><span class="math display">\[a_n = a_n^+ - a_n^- ,|a_n|=a_n^+ + a_n^-;\]</span></p><p><span class="math display">\[a_n^+ = \frac{a_n+|a_n|}{2},a_n^-= \frac{|a_n|-a_n}{2}.\]</span></p><h3 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h3><p>几个定理：</p><p><strong>TH1.</strong> 级数绝对收敛必然收敛.</p><p><strong>TH2.</strong> 级数<span class="math inline">\(\Sigma _{n=1} ^\infty a_n\)</span>绝对收敛的充要条件即为正部级数和负部级数均收敛.</p><p><strong>TH3.</strong> 绝对收敛级数可任意更序，和不变.</p><p><strong>TH4.</strong>（黎曼定理）对于条件收敛的级数，可更换其次序使其收敛于任意给定数或以任意形式发散.</p><h3 id="阿贝尔变换几何直观">阿贝尔变换（几何直观）</h3><p><span class="math display">\[\Sigma_{i=1}^n a_ib_i=a_nB_n -\Sigma_{i=1}^{n-1}(a_{i+1}-a_i)B_i\]</span></p><h3 id="迪利克雷判别法和阿贝尔判别法">迪利克雷判别法和阿贝尔判别法</h3><p>前提条件：</p><p><span class="math display">\[\Sigma u_n =\Sigma a_nb_n\]</span></p><p>迪：</p><p><span class="math display">\[\{a_n\} 单调，且lim_{n\rightarrow\infty} a_n=0\]</span></p><p><span class="math display">\[\{b_n\} 的前n项部分和序列有界\]</span></p><p>阿：</p><p><span class="math display">\[\{a_n\} 单调有界\]</span></p><p><span class="math display">\[\{b_n\} 收敛\]</span></p><h3 id="交错级数">交错级数</h3><p><span class="math display">\[\Sigma (-1)^{n+1} u_n , u_n&gt;0\]</span></p><h3 id="交错级数的莱布尼茨判别法">交错级数的莱布尼茨判别法</h3><p>若<span class="math inline">\(u_n\geq u_{n+1} , lim_{n\rightarrow\infty}u_n=0\)</span>,则收敛，其和<span class="math inline">\(S\lequ_1.\)</span></p><h2 id="几道例题">几道例题:</h2><blockquote><p><spanclass="math inline">\(\Sigma\frac{(-1)^n}{\sqrt{n}-(-1)^n}\)</span>(有理化，发散)</p></blockquote><blockquote><p><span class="math inline">\(\Sigma sinnx\)</span> (sin(x/2))</p></blockquote><h1 id="广义积分">广义积分</h1><h2 id="敛散性的判定">敛散性的判定</h2><p>1.柯西收敛；2.比较判别法（非负）&amp;极限形式；3.阶估法（非负）（两个重要的广义积分）；4.绝对收敛定理；5.迪利克雷判别法.</p><h2 id="迪利克雷判别法">迪利克雷判别法</h2><p><spanclass="math inline">\(判定\int_a^{+\infty}f(x)g(x)收敛：\)</span></p><p>条件：</p><p><spanclass="math inline">\(\int_a^xf(x)dx在[a，+\infty)上有界,g(x)在[a,+\infty)上单调且趋于零\)</span></p><p>证明：</p><p>使用积分第二中值定理.</p><h2 id="tips">TIPS</h2><p>1.当<spanclass="math inline">\(f(x)\)</span>非负且单调递减时，可以用使用积分判别法转化为判定相应级数的敛散性.</p><p>2.广义积分收敛时，被积函数未必趋于零.</p><p>(eg.<spanclass="math inline">\(\int_1^{+\infty}sin(x^2)dx\)</span>).</p><p>3.上下限之间只有一个奇点，多个奇点要将广义积分进行拆分.</p><h2 id="几道例题-1">几道例题</h2><blockquote><p><spanclass="math inline">\(\int_1^{+\infty}sin(x^2)\)</span>(换元)</p></blockquote><blockquote><p><spanclass="math inline">\(\int_0^{+\infty}|\frac{sinx}{x}|dx\)</span>(<spanclass="math inline">\(1.\geq\frac{sin^2x}{x};2.\int_{k\pi}^{(k+1)\pi}|\frac{sinx}{x}|dx\)</span>)</p></blockquote><h1 id="函数项级数">函数项级数</h1><h2 id="一些概念">一些概念</h2><p>一般项/通项 部分和函数 收敛点 发散点 收敛域 发散域 和函数</p><h2 id="一句话">一句话</h2><p>要讨论函数项级数的收敛、发散、绝对收敛、绝对发散，只需要将<spanclass="math inline">\(x\)</span>任意固定，再应用常数项级数的一切有关敛散性定理.</p><h2 id="幂级数">幂级数</h2><h3id="阿贝尔第一定理从收敛到绝对收敛">阿贝尔第一定理（从收敛到绝对收敛）</h3><p>1.如果幂级数<span class="math inline">\(\Sigmaa_nx^n\)</span>在点<spanclass="math inline">\(x=x_0(x_0\neq0)\)</span>收敛，则它在区间<spanclass="math inline">\(|x|&lt;|x_0|\)</span>中绝对收敛；</p><p>2.如果幂级数<span class="math inline">\(\Sigmaa_nx^n\)</span>在点<spanclass="math inline">\(x=x_1\)</span>发散，则在满足<spanclass="math inline">\(|x|&gt;|x_1|\)</span>的点上都发散.</p><h3 id="收敛半径的存在性">收敛半径的存在性</h3><p>如果幂级数具有非零的收敛点与发散点，则必存在一个确定的非负数，使得当<spanclass="math inline">\(|x|&lt;R\)</span>时，级数绝对收敛；而当<spanclass="math inline">\(|x|&gt;R\)</span>时级数发散.</p><h3 id="求收敛半径">求收敛半径</h3><p><span class="math display">\[lim_{n \rightarrow\infty}|\frac{a_n}{a_{n+1}}|\]</span></p><p><span class="math display">\[\lim_{n \rightarrow\infty }\frac{1}{|a_n|^{\frac{1}{n}}}\]</span></p><h3 id="tips-1">TIPS</h3><p>关于幂级数的很多结论都是针对标准形式的，因此会出现一些典型问题比如缺项，可换元解决，或直接依靠定义讨论.</p><h3 id="一道例题">一道例题</h3><blockquote><p>证明：若<span class="math inline">\(f\)</span>是<spanclass="math inline">\([a,+\infty)\)</span>上的单调函数，且<spanclass="math inline">\(\int_a^{+\infty}f(x)dx\)</span>收敛，则<spanclass="math inline">\(lim_{x\rightarrow +\infty}f(x)=0\)</span>，且<span class="math inline">\(f(x)=o(1/x),x\rightarrow+\infty.\)</span></p></blockquote><blockquote><p>思路：1.证有极限-&gt;证有界;2.证极限为0-&gt;反证;3.证高阶小量-&gt;积分中值定理&amp;夹逼.</p></blockquote><h2 id="一致收敛函数项级数的分析性质">一致收敛函数项级数的分析性质</h2><h3 id="一致收敛">一致收敛</h3><h4 id="直观">直观</h4><p>收敛速度可以总体控制.</p><h4 id="定义">定义</h4><p><span class="math inline">\(\{f_n(x)\}\rightrightarrows f(x) ,x\inI\iff\forall\epsilon&gt;0,\exists N&gt;0,n&gt;N,|f_n(x)-f(x)|&lt;\epsilon,x \in I .\)</span></p><p><span class="math inline">\(\{\Sigma u_n(x)\}\rightrightarrows S(x),x\in I.\)</span>$ &gt;0,N&gt;0, n&gt;N,|u_1(x)+..+u_n(x)-S(x)|&lt;,xI.$</p><p><span class="math inline">\(\iff\forall\epsilon &gt;0, \existsN&gt;0,n&gt;N,\forall p\in N,|u_{n+1}(x)+...+u_{n+p}(x)|&lt;\epsilon,x\in I\)</span></p><p><span class="math inline">\(\iff lim_{n\rightarrow\infty}\ sup_{x\inI}|S_n(x)-S(x)|=0.\)</span></p><blockquote><p>上确界和柯西准则在证明不一致收敛时比较好用.</p></blockquote><h4 id="判定">判定</h4><p>M判别法:</p><blockquote><p>数项级数一致收敛.</p></blockquote><p><span class="math display">\[对 \Sigma u_n(x),若：|u_n(x)|&lt;a_n,\forall x\in I  ; \Sigma a_n 收敛\]</span></p><p><span class="math display">\[则 \Sigma u_n 收敛且一致收敛.\]</span></p><blockquote><p>Pf.柯西收敛准则.</p></blockquote><p>迪利克雷判别法：</p><p>若：</p><p><span class="math display">\[1.对区间I上每一个固定的x,数列\{a_n(x)\}单调且一致趋于零;\]</span></p><p><span class="math display">\[2.函数项级数\Sigma b_i(x)的部分和数列\{B_n(x)\}在I上一致有界.\]</span></p><p>则：</p><p><span class="math display">\[\Sigma a_ib_i在I上一致收敛.\]</span></p><p>阿贝尔判别法:</p><p>若:</p><p><span class="math display">\[1.对区间I上每一个固定的x,数列\{a_n(x)\}单调且一致有界;\]</span></p><p><span class="math display">\[2.函数项级数\Sigma b_i(x)在I上一致收敛.\]</span></p><p>则:</p><p><span class="math display">\[\Sigma a_ib_i在I上一致收敛.\]</span></p><h3 id="关于连续性">关于连续性</h3><p><span class="math display">\[若u_n(x)(n=1,2,...)在[a,b]上连续；\Sigma u_n(x)\rightrightarrowsS(x),x\in [a,b].\]</span></p><p><span class="math display">\[则S(x)在[a,b]上连续.\]</span></p><blockquote><p>Pf.搭桥.<span class="math inline">\(S(x)-S_n(x)\)</span>,<spanclass="math inline">\(S_n(x)-S_n(x_0)\)</span>,<spanclass="math inline">\(S_n(x_0)-S(x_0)\)</span>.</p></blockquote><blockquote><p>实际上是两种极限次序的交换.</p></blockquote><h3 id="逐项求积分">逐项求积分</h3><p><span class="math display">\[若u_n(x)(n=1,2,...)在[a,b]上连续；\Sigma u_n(x)\rightrightarrowsS(x),x\in [a,b].\]</span></p><p><span class="math display">\[则S(x)在[a,b]上可积，并且可逐项求积分,\int_a^b\Sigmau_n(x)dx=\int_a^bS(x)dx=\Sigma\int_a^b u_n(x)dx.\]</span></p><blockquote><p>Pf.<span class="math inline">\(r_n(x)\rightrightarrows0\)</span>.</p></blockquote><h3 id="逐项求导">逐项求导</h3><p>若：</p><p><span class="math display">\[1.u_n(x)在[a,b]连续可导;\]</span></p><p><span class="math display">\[2.\Sigma u_n(x)\rightarrow S(x),x\in [a,b]；\]</span></p><p><span class="math display">\[3.\Sigma u_n^{&#39;}(x)\rightrightarrows U(x),x\in[a,b].\]</span></p><p>则:</p><p><span class="math display">\[S(x)在[a,b]上连续可导，并且可逐项求导，即S^{&#39;}(x)=U(x).\]</span></p><blockquote><p>注意，以上关于连续性、逐项积分、逐项求导的讨论都是在闭区间.</p></blockquote><h3 id="内闭一致收敛">内闭一致收敛</h3><p>若<span class="math inline">\(\Sigmau_n(x)\)</span>在开区间的任意一个闭子区间都一致收敛，则成为其在区间<spanclass="math inline">\(I\)</span>上内闭一致收敛.</p><blockquote><p>连续性和逐项求导可在内闭一致区间上进行推广.</p></blockquote><h2 id="幂级数的分析性质">幂级数的分析性质</h2><h3 id="阿贝尔第二定理">阿贝尔第二定理</h3><p>已知:</p><p><span class="math display">\[幂级数\Sigma a_n x^n的收敛半径为R&gt;0\]</span></p><p>有:</p><p><span class="math display">\[（1）幂级数在(-R,R)上内闭一致收敛\]</span></p><p><span class="math display">\[（2）若在右端点R出收敛，则对\forall0&lt;\delta&lt;2R,幂级数在[-R+\delta,R]上一致收敛\]</span></p><p><span class="math display">\[（3）左端点类似（2）\]</span></p><blockquote><p>Pf.（1）M判别法；（2）（3）阿贝尔.</p></blockquote><h3 id="幂级数的分析性质-1">幂级数的分析性质</h3><p>和函数在收敛域内连续、可逐项积分、可逐项求导.逐项求导或求积分后收敛半径不变但端点的收敛性未必.</p><p>推论：</p><ul><li>级数<spanclass="math inline">\(\Sigma_{n=1}^{\infty}na_nx^{n-1}\)</span>,<spanclass="math inline">\(\Sigma_{n=0}^{\infty}\frac{a_n}{n+1}x^{n+1}\)</span>,<spanclass="math inline">\(\Sigma_0^{\infty}a_nx^n\)</span>有相同的收敛半径.</li><li>幂级数<spanclass="math inline">\(\Sigma_nx^n\)</span>的收敛半径为<spanclass="math inline">\(R\)</span>，则在<spanclass="math inline">\((-R,R)\)</span>内该级数可逐项求导数任意次，逐项求积分任意次.</li></ul><h2 id="函数的幂级数展开">函数的幂级数展开</h2><h3 id="函数幂级数展开的存在唯一性">函数幂级数展开的存在唯一性</h3><p>设函数<span class="math inline">\(f\)</span>在点a的邻域<spanclass="math inline">\(U=U(a,R)\)</span>上任意阶可导，则：</p><ul><li><p><span class="math inline">\(f\)</span>在<spanclass="math inline">\(U\)</span>上可展成泰勒级数的充要条件是函数<spanclass="math inline">\(f\)</span>所展成的泰勒公式中的余项<spanclass="math inline">\(r_n(x)\)</span>在<spanclass="math inline">\(U\)</span>上处处收敛于<spanclass="math inline">\(0\)</span>.即：</p><p><span class="math display">\[f(x)=\Sigma_{k=0}^{\infty}\frac{f^{(k)}(a)}{k!}(x-a)^k\ifflim_{n\rightarrow\infty}r_n(x)=0,\forall x\in U.\]</span></p></li><li><p>若<span class="math inline">\(f\)</span>可在<spanclass="math inline">\(U\)</span>上展成幂级数，则这个幂级数唯一，就是<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(a\)</span>的泰勒级数.</p></li></ul><h3 id="基本展开式">基本展开式</h3><ul><li><span class="math display">\[e^x=1+x+\frac{x^2}{2!}+...+\frac{x^n}{n!}+..., (-\infty &lt;x&lt;+\infty)\]</span></li><li><span class="math display">\[sinx=x-\frac{x^3}{3!}+...+(-1)^{m-1}\frac{x^{2m-1}}{(2m-1)!}+...,(-\infty&lt;x&lt; +\infty)\]</span></li><li><span class="math display">\[cosx=1-\frac{x}{2!}+...+(-1)^m\frac{x^{2m}}{(2m)!},(-\infty &lt;x&lt;+\infty)\]</span></li><li><span class="math display">\[(1+x)^\mu=1+\mux+\frac{\mu(\mu-1)}{2!}+...+\frac{\mu(\mu-1)...(\mu-n+1)}{n!}x^n+...,(-1&lt;x&lt;1,\forall\mu)\]</span></li></ul><blockquote><p>1/(1+x)和1/(1-x)展开式很常用</p></blockquote><ul><li><span class="math display">\[ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}+...+(-1)^{n-1}\frac{x^n}{n}+...,(-1&lt;x\leq1)\]</span></li></ul><blockquote><p>求一个函数的展开式的方法有二：一，利用定义直接求；二，利用求导求积分等运算和以上几个基本式子间接求出.</p></blockquote><h1 id="含参积分">含参积分</h1><h2 id="含参常义积分">含参常义积分</h2><h3 id="连续性">连续性</h3><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,y\inI\}\)</span>上连续，则<spanclass="math inline">\(\phi(y)=\int_a^bf(x,y)dx\)</span>在<spanclass="math inline">\(I\)</span>上连续，特别的，对<spanclass="math inline">\(y_0\in I\)</span>，有<spanclass="math inline">\(lim_{y\rightarrowy_0}\int_a^bf(x,y)dx=\int_a^blim_{y\rightarrowy_0}f(x,y)dx\)</span>,即极限和积分的运算顺序可以交换.</p><blockquote><p>推论：设函数<span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(a(y)\leq b(y),y\in I\)</span>上连续，函数<spanclass="math inline">\(a(y),b(y)\)</span>在<spanclass="math inline">\(I\)</span>上连续，则含参变量<spanclass="math inline">\(y\)</span>的积分 $ (y)=_{a(y)}^{b(y)}f(x,y)dx$在<span class="math inline">\(I\)</span>上连续.</p></blockquote><h3 id="积分号下求导">积分号下求导</h3><p>设<span class="math inline">\(f\)</span>与<spanclass="math inline">\(\frac{\partial f}{\partial y}\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,y\inI\}\)</span>上连续，则<span class="math inline">\(\phi\)</span>在<spanclass="math inline">\(I\)</span>上可导，且有（莱布尼茨公式）：</p><p><span class="math display">\[\phi^{&#39;}(y)=\frac{d}{dy}\int_a^bf(x,y)dx=\int_a^b\frac{\partial}{\partial y}f(x,y)dx,\forall y\in I.\]</span></p><p>设二元函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(\frac{\partial f}{\partial y}\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,\alpha\leqy\leq\beta\}\)</span>上连续,函数<spanclass="math inline">\(a(y),b(y)\)</span>在<spanclass="math inline">\([\alpha,\beta]\)</span>上有连续导数，且<spanclass="math inline">\(a\leq a(y)\leq b,a\leq b(y)\leqb\)</span>,则函数</p><p><span class="math display">\[\phi(y)=\int_{a(y)}^{b(y)}f(x,y)dx\]</span></p><p>在</p><p><spanclass="math inline">\([\alpha,\beta]\)</span>上具有连续导数，且有</p><p><span class="math display">\[\phi^{&#39;}(y)=\int_{a(y)}^{b(y)}f_y(x,y)dx+f(b(y),y)b^{&#39;}(y)-f(a(y),y)a^{&#39;}(y),y\in[\alpha,\beta]\]</span></p><h3 id="积分换序">积分换序</h3><p>条件同连续性.</p><h2 id="含参广义积分">含参广义积分</h2><h3 id="一致收敛-1">一致收敛</h3><p><span class="math display">\[\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,s.t.当A&gt;A_0,\forall y\in I,|\int_A^{+\infty}f(x,y)dx|&lt;\epsilon\]</span></p><p><span class="math display">\[\iff lim_{A\rightarrow+\infty}sum_{y\in I}|\int^{+\infty}_Af(x,y)dx|=0\]</span></p><p><span class="math display">\[\iff\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,\forallA_2&gt;A_1&gt;A_0 有|\int^{A_2}_{A_1}f(x,y)dx|&lt;\epsilon,\forall y\inI\]</span></p><h3 id="m判别法">M判别法</h3><p>条件：</p><ul><li><span class="math display">\[\exists M(x),s.t. |f(x,y)|\leq M(x),\forall (x,y)\in D\]</span></li><li><span class="math display">\[\int _a^b M(x)dx 收敛\]</span></li></ul><p>结论：</p><ul><li><span class="math display">\[\int_a^bf(x,y)dx 在I上一致收敛.\]</span></li></ul><h3 id="分析性质">分析性质</h3><p>针对连续性、积分号下求导、积分顺序交换的分析，此处略过.</p><h2 id="gamma函数和-b函数"><spanclass="math inline">\(\Gamma\)</span>函数和 B函数</h2><p>了解定义域、递推关系、不同形式、两者之间的关系、余元公式.</p><h2 id="傅里叶级数">傅里叶级数</h2><p>求傅里叶级数</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
