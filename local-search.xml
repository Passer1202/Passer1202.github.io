<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Lawbreaker and ABLE</title>
    <link href="/2025/08/22/Lawbreaker-and-ABLE/"/>
    <url>/2025/08/22/Lawbreaker-and-ABLE/</url>
    
    <content type="html"><![CDATA[<h2 id="lawbreaker">Lawbreaker</h2><h3 id="研究背景">研究背景</h3><p>自动驾驶系统（ADS）在上路前需要进行充足的测试，高保真的仿真器（如LGSVL ,CARLA）能够低成本高效地使其在多样化场景下接受检验。尽管已有测试用例的自动生成方法，但这些方法往往只关注“弱”判定标准（例如车辆是否能在无碰撞的情况下到达目的地），而忽略了行程本身是否安全、是否符合交通法规。为此，作者提出了<code>Lawbreaker</code>，旨在提供了一套<code>面向驾驶员</code>的丰富规范语言，用以形式化描述交通法规，并通过<code>模糊测试引擎</code>搜索各种可能的违规方式，以最大化规范覆盖率。</p><h3 id="痛点">痛点</h3><p>交通法规是现成的，但是针对这些法规对 ADS 进行测试还是有挑战性的：</p><ul><li>法规通常以<code>自然语言</code>书写，并且是从<code>驾驶员视角</code>进行描述。这使得在现有基于全局视角的规约语言中进行编码时，往往显得不直观。</li><li>各国交通法规差异显著，因此需要一种通用且可扩展的规约语言，而不是只能针对某一国家、固定内嵌的判定器。</li></ul><p>很不幸，现有的描述交通法规的规约方法在可复用性和可扩展性方面均存在局限。比如rulebooks侧重于逻辑转换过程，并未提供一种自然的方式来描述法规；而其他形式化方法则与具体测试场景紧密耦合，每当引入新场景时，都必须对法规进行重新定制。一言以蔽之，<strong>要不难写，要不难改</strong>。</p><h3 id="解决方案">解决方案</h3><p>为了解决以上痛点，作者提出了 <code>Lawbreaker</code>——一种用于描述交通法规的领域专用语言（DSL），以及一个可据此对自动驾驶系统（ADS）进行自动化测试的框架：</p><ul><li>允许用户从<code>驾驶员视角</code>而非全局视角更自然地表述交通法规，例如“在路口右转时，驾驶员应礼让行人”。</li><li>与任何具体测试场景解耦：同一套法规不仅可以在不同地图上统一解释，还能与任何用于生成测试场景的DSL 共同使用（这些场景定义了车辆、行人及障碍物在地图中的摆放）。</li><li>内置的<code>模糊测试引擎</code>会系统性地搜索各种违规情形，通过尽可能多地覆盖不同违规方式来发现潜在缺陷，而这些未被覆盖的违规情形也能为改进ADS 提供线索。</li></ul><blockquote><p>领域专用语言是什么？ 领域专用语言（Domain-SpecificLanguage，DSL）是一种为了解决特定领域问题而专门设计的“小语言”。与通用编程语言（如Python、Java、C++）“什么都能写”不同，DSL只关注某一个细分领域的词汇、概念和规则，因此语法更简洁、表达更贴近业务，普通人也能快速看懂。</p><ul><li><p>例子</p><ul><li>SQL：专用于“关系数据库查询”的 DSL。</li><li>HTML：专用于“网页结构描述”的 DSL。</li><li>正则表达式：专用于“文本模式匹配”的 DSL。</li><li>LawBreaker 的 DSL：专用于“描述交通法规”的DSL，让你用接近自然语言的句子（如“在路口右转时应礼让行人”）去告诉计算机一条法规是什么。</li></ul></li><li><p>特点</p><ul><li>词汇和语法高度贴合领域概念，非程序员也能写。</li><li>功能受限，但在领域内表达力极强，错误更少。</li><li>通常位于“通用语言写的系统”之上，为其提供配置或规则输入。</li></ul></li></ul><p>一句话总结：DSL就是“为特定任务量身定做的小语言”，让领域专家用他们熟悉的话，把需求直接写成计算机能懂的规则。</p></blockquote><p>如下图所示，用户只需提供一个场景脚本、待测 ADS 和仿真器，以及用Lawbreaker语言编写的若干交通法规。随后，模糊测试引擎在仿真器中系统地生成测试用例，尝试诱导ADS违反这些法规，从而暴露其设计缺陷。而所有违规行为都会被记录，并可借助仿真器进行可视化回放。</p><figure><img src="/image/paper/lawbreaker/LF1.png" alt="LawBreaker的workflow" /><figcaption aria-hidden="true">LawBreaker的workflow</figcaption></figure><p>具体的，LawBreaker 的实现包含三部分：</p><ul><li>基于 ANTLR4的语法解析器，用于抽取场景描述和相应交通法规中的要素；</li><li>模糊测试引擎，用于系统地生成测试用例；</li><li>桥接层：将语法解析器、模糊测试引擎、待测 ADS以及仿真器连接起来，使整套系统能够协同运行。</li></ul><p>LawBreaker 的架构如下图所示：</p><ul><li>用于描述场景与情境的<strong>现有</strong> DSL（作者使用的 AVUnit）；</li><li>新提出的、面向驾驶员视角的交通法规描述语言，其语义基础为<code>时序逻辑公式</code>；</li><li>LawBreaker 模糊测试算法。</li></ul><figure><img src="/image/paper/lawbreaker/LF2.png" alt="LawBreaker架构" /><figcaption aria-hidden="true">LawBreaker架构</figcaption></figure><p>具体的，场景脚本组件首先将给定场景翻译为仿真器所需的 API调用，为其准备初始测试用例。然后交通法规组件完全从驾驶员视角描述测试预言（testingoracles），无需依赖关于地图或其交通参与者的任何特定知识。最后，模糊测试引擎不断从ADS中提取运行轨迹，依据法规规范对其评估，并根据评估结果生成新的测试用例供仿真器执行。</p><h3 id="面向驾驶员的描述语言">面向驾驶员的描述语言</h3><blockquote><ul><li>轨迹（trace）：若干场景（scene）按序组成的序列。</li><li>场景（scene）：也即状态，各个变量按序组成的序列。</li></ul></blockquote><p>所谓规则，无非是需要满足的较为复杂的布尔表达式，我们使用时序逻辑公式来描述交规，如下图所示：</p><figure><img src="/image/paper/lawbreaker/LF3.png" alt="LawBreaker公式语法" /><figcaption aria-hidden="true">LawBreaker公式语法</figcaption></figure><p>作者为了描述布尔表达式定义了足足6类变量，用于表示<code>车辆状态</code>、<code>驾驶状态</code>、<code>道路状态</code>、<code>信号状况</code>、<code>交通状况</code>、<code>地图状况</code>。关于各类变量的定义此处不再赘述，下面来看一个例子：</p><ul><li><code>proposition1</code>给出条件：前方十米有停车线或路口，且信号灯为闪烁的黄灯；</li><li><code>proposition2</code> 给出行动：未来两秒内，车速要降到 20 km/h以下直到 15 米内没有 NPC；</li><li><code>law42</code> 则要求 <code>proposition1</code>为真时，<code>proposition2</code> 永远为真。</li></ul><blockquote><p>《道路交通安全法实施条例》第 42 条: “闪光警告信号灯”为持续闪烁的黄灯，提示车辆、行人通过时注意瞭望，确认安全后通过。</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">proposition1 = trafficLightAhead.color==yellow <br>                &amp; trafficLightAhead.blink <br>                &amp; (stoplineAhead(10) | junctionAhead (10) ); <br>proposition2 = F[0,2]((speed &lt;<span class="hljs-number">20</span>) U ~NearestNPC (<span class="hljs-number">15</span>));<br>law42 = G(proposition1 -&gt; proposition2);<br></code></pre></td></tr></table></figure><h3 id="模糊引擎">模糊引擎</h3><p>在讨论算法之前，我们首先约定一些符号。</p><p>令 <span class="math inline">\(\Phi\)</span>是一个信号时序逻辑（STL）公式，我们约定 <spanclass="math inline">\(\Theta(\Phi)\)</span> 表示违背 <spanclass="math inline">\(\Phi\)</span> 的不同方式对应的约束集合，则 <spanclass="math display">\[\forall \xi \in \Theta(\Phi),\phi \models \xi\Rightarrow \phi \not\models \Phi\]</span>.</p><p>对于 <span class="math inline">\(\Theta(\Phi)\)</span>，计算方式见下图：</p><p><img src="/image/paper/lawbreaker/LF4.png" /></p><blockquote><p><spanclass="math inline">\(\Theta(\theta_1\mathcal{U}_{\mathcal{I}}\theta_2)\)</span>被违背有两种情况： + <span class="math inline">\(\theta_1\)</span> 和<span class="math inline">\(\theta_2\)</span> 都不成立之前，一直处于<span class="math inline">\(\theta_1\)</span> 成立 <spanclass="math inline">\(\theta_2\)</span> 不成立的状态； + 从一开始就<span class="math inline">\(\theta_1\)</span> 和 <spanclass="math inline">\(\theta_2\)</span> 都不成立。</p></blockquote><p>其中，<span class="math inline">\(N(\Phi)\)</span> 表示 <spanclass="math inline">\(\Phi\)</span>被满足的不同方式对应的约束集合，计算方式如下图所示：</p><p><img src="/image/paper/lawbreaker/LF5.png" /></p><p>实践中只需要利用上述规则和布尔恒等式展开计算即可。</p><p>下面考虑 <span class="math inline">\(\phi \models \xi\)</span>的判定问题，作者使用了下图所示的定量语义：</p><p><img src="/image/paper/lawbreaker/LF6.png" /></p><p>一旦有 <span class="math inline">\(\rho(\varphi,\pi,t)\geq 0\)</span>, 我们就说 <span class="math inline">\(\varphi\)</span> 被 <spanclass="math inline">\(\pi\)</span> 所满足。若不加说明，约定 <spanclass="math inline">\(\rho(\varphi,\pi)=\rho(\varphi,\pi,0)\)</span>。</p><p>万事俱备，只欠东风，下面介绍模糊算法：</p><figure><img src="/image/paper/lawbreaker/LF7.png" alt="模糊算法本法" /><figcaption aria-hidden="true">模糊算法本法</figcaption></figure><p>模糊算法基于<code>遗传算法</code>，<spanclass="math inline">\(\Theta_r\)</span> 集合表示 <spanclass="math inline">\(\Theta(\Phi)\)</span> 中还没满足的约束， <spanclass="math inline">\(Seed_r\)</span>将约束和场景一一对应，用于记录亲代，<spanclass="math inline">\(Robust_r\)</span>记录当前约束离被满足还差多少，<span class="math inline">\(G\)</span>为子代场景集合，而 <span class="math inline">\(\Gamma\)</span>为选出的场景，也即测试用例.</p><p>关于模糊算法，还有几点需要注意：</p><ul><li>第20行选子代的时候，<span class="math inline">\(Seed_r\)</span>数量未必等于子代数 <span class="math inline">\(n\)</span> , 作者选择将<span class="math inline">\(Seed_r\)</span> 依据 <spanclass="math inline">\(Robust_r\)</span> 降序排列，然后从前半部分和所有<span class="math inline">\(Seed\)</span>各随机抽取一个测试用例作为亲代，然后交换变量，生成子代。</li><li>注意“生殖隔离”，不允许不同类型（作者定义了6类变量）变量的值进行交换！</li><li>存在“变异”：对连续值，施加高斯变异。</li></ul><h3 id="结果">结果</h3><blockquote><p>LawBreaker was able to find 14 violations of these laws, including173 test cases that caused accidents.</p></blockquote><h2 id="able">ABLE</h2>]]></content>
    
    
    
    <tags>
      
      <tag>reading</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lightweight Remote Procedure Call</title>
    <link href="/2025/07/10/LRPC/"/>
    <url>/2025/07/10/LRPC/</url>
    
    <content type="html"><![CDATA[<blockquote><p><del>Lightweight Remote Procedure Callc 阅读笔记，一个“小孩子才做选择，我全都要”的故事</del></p></blockquote><p>原文已删除，<a href="/file/pre.pdf">slides</a>附上.</p>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>浮于表面的代价</title>
    <link href="/2025/07/07/%E6%B5%AE%E4%BA%8E%E8%A1%A8%E9%9D%A2%E7%9A%84%E4%BB%A3%E4%BB%B7/"/>
    <url>/2025/07/07/%E6%B5%AE%E4%BA%8E%E8%A1%A8%E9%9D%A2%E7%9A%84%E4%BB%A3%E4%BB%B7/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>os</title>
    <link href="/2025/07/07/os/"/>
    <url>/2025/07/07/os/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="1c7239de1f61da1d9d7109bfb715f6b13972c885b196ecf116944052b3bc6186">1d5143e84f1286eb68062c5277c63e16d70c4e0348bc201d4293245c71f6b35861cc5a55cdad1569be90eceb6b69905df9c98a4d454cb2b58e0dfe34948e676ecee444de944e6dab68c9978fac6f076db13e7ac818e27137078df86cad6106483ca1b09ab1fcb77fa60d212da2f83f7299e770f551924dca3e9480d2b23ba1dbc4a1c92b7e95d9f63be948d234666e2f837a4ace6777273925c4dc045f0bed495b746502f0ba59664bfd0b6c92b12960ffc3a653fc68981e81d73991d1a395ed928dd5084996bb62ed61cc6726484fa787dff9d6679296b158a62dadd053beffb4e9673e8cbc3f665cfeadef55dd9c9a2ae94651cde1b414f03f557fd6740dde02e1369120dbf56a942024717abd29c90093f10cc429b7d0d352aea5cfc24601e176db56bc474e375c173139a599c8e4522ab8882a50ed76f1f042c197db64900516be553352d001319d520568c41cc2706e5d662ed8ce166d21f8efe9e5d29af1833bf2aaeecc2d92537aee960de42cc3f5f2a05fb447c2f98d51428d4a5ef187d3c3183fe68f319c721c4e3f871c2dbdeea222ac2e09e4bb4b499b06f0d5aa20c8266bb6dbd6b726f359945679b7e7b95cded11505b808f31ab4a74255cbbedb0e363a79840a73ac4e5cd08acbed9345405c05a0338d5401bc626ff8a24f2917c58db733259e1f32b75c885c60d1f01354724e657a900d10e0c617825b25c50c15bec7a2eb04302e224b48492a8fb7b3c8ea0c21a97c4df43918f293163b4f96feebee7cf9c0a4f7dac16fe2534c7a72cf6d2dbb2cc87fabe84e237b626f3e5d0609dfc28a83ef118d787dfaab09aa4b374b2539ea2d762b280587c8a07fd25d99f2aceccc28623f0686e152f91c18e0186c0ebc980766abfe3b71bf08c14c96d3fa68fa149b2d8badaa7b0dcf61b0a2773a68f5eca46450470d7e5ca12396883981e73e1662151a9242a004ea4b187c9fb44b5584b3dcc13a89ca7fe67cfa8a23087fa9d588a1ebb450143f8384bee855a9d7eae8334b765b9cb84714db63c8df94065fd3b06277d1bfd59ac1cae439f4fbd3ac3ed2edaa86430c40609f47a5ab1f4a44713fcd24aabb5d1d276dfd5ffe121497905044659734c2970fc8129249d3d6037adcf20815a279fb99d5a8758203eebfdd5144a516006900fdc962f1c348c7fcc669135ea1eae3c53883b26b71bfd2afcb005013053471cca78cd1356adf46f0b3212e90e28783f90c12ea3e6f694ac8c738de772bf540b4ede6518f44eb84b4e4998e435eabddf1349a42dcae9c44e6db750bc1ac4690d520ac39ede54dfb78a579a1526527a7cb1c2b8f4d5651df69d14c2b41724cab56497a06ac04df187d02f866caf822951376c6a622b489592d4ae69ca61bfd039fb5e326cae06df8e0d899474c755666a131eacd317aecf043c78e8d19c3171bce0385d4f3e393b7874a243225a32dde3d263adc088324d50ba9a9cea63417b8e161a364f90074902feaba9c32a0fc7aeb70a240381edb79f3944ec44a987c89ac8f8d3cdf833b76de39db2f394ff98ac378f266a80f6a95426c2ff81af95a84f82ac29140b3ffd265bd5fb18940c2b4aecd78380aa2c13040562ddd83585b566ef45a7f59b1ce24a0fc9444bf234d915712614d27b7931b0db305d0c7d6d6112852286b233de15aa7de70aefa031be66bd1cda3158d29e9ee9ac31b0ae5f24812e7f5330fd5425c67c859371e7865cf05044585faf8f0f2df82a3482bc8945c829c35c92f1d286b164124391e9c8799734a988a77b82338e1cd3065c93afdf7c2f02faefdc00bd958f7b5beb0310374fdf71bbbdd6f30bbb91a99e44e0d06204129559f96faa7f1913cdd4b9abed76545213bb976f814d88713cbf5233bad398be7403c600c6e58263b373eb92ec75deec3fea40ce5c2999bfc3c311135a83891dff1f3c58764ca9576bc9863d6e03643e68fa64c20e9f2bbb37befcec9eb7c3dfd66e884ec86cc9edaee8544ab84f96ad2e8f9985ed1e0c9487dc09bf3b21434a9b9b9c0e67693138978c65df87a33d6e1d77ff59f456877f7553ec81488d1a6b5f04f091e480008c6cc09479db9ee76a94df480c518d3153e7a5af9e903f1afd75564170484e09c813c5cab8f0d9c3678f82d1325edacc63b323c7875d2b6b16d1d7e2a0960c743d5284dbc824a789db736bc45909669ca0fb971676f8a37baf5429e1d446c1879c4f9229bc006b53f96b5afe127d85e61ec6b37451c547a34177f08b8bc5c6463e682914ea54e9c50259123ed256d7bbaa6e283f3d5ebcd2972b4e3d2a1f9b22d343d6bf70a8c85a2c070a57829c7ec53b09fa93e0936f5384bb58ee54b056f35649c43fce933876795611ae3987f3027cc97d35986e1bab1b697ce438193f683cc7975f71db4e24965d29cb186a51896ebfc52684d87b4853c8201c875f81d4ef9a0e7ba9b2130b48c76426db62893b8f5a1b694012b4155a783354d4988055697a78ecd764497e4c0f1f026332572d0921f1e09985532c54d50ea87ed03931b76e04c8d98e0d971234999cce9ea4a61ae08fd5b16b8f983061331121268dcb361108ba89c351c651694054377c47e83f85e933830cada3b006c612fdeab4c47c90e86b2cc4157d0c2fdcbc0b4309fc90bfe1056f1e94be233c82c4b60e0fb3e0fe80e0c9a8df89d466575e056a0cb73be12e9f335ea7aa552d32168410b62c27fa95903d28abff80d118a8b426a7d3eb3ee5684dbfe1d209675eff949b449fd2cbc8d3aa3bd15573303fcea616b98a97f18ab36d84a5e447033fd397eb10568ac5ee4edff5e4b1b94b09fade4eb7c2abf6c6f08b370f653484425e0cadcacb3d1ad810b0aec4dbfcb01967964cfbd9f4689d00fe2b3c8c5f197c9deff31ec2ca1bdbe50c6487029cf4b34dcc408225cb108e373a385403e5d9f60fb65533739f19dd8578069c4671268e83390312b4ff8994ab167f2a2c51733cfe842c55b5bd0aa3c93657170f7747dbad25bb25fe221619178b295bca4de503dc870900743cd38894618e68d5880770f5a580aa4221a91178b0f8417881a1336e85106bf67fca54c4f3e061dd3d757ae9405ab2cb27b1acdf13f99af64c59152e44dbac4e9058fbb3dbbd7d1fbef0fc5962d4fb2d7e05aabfc33b6d5a24412090b7d3d03a6007ed709a5e979af9a59840fa47469f87776cb55eeb70ffcb06db7a406a923bf74d9b1c238ec08755c8e4565596382e4b723778cd2e2b9226ea6b0f176f4cecc452bf14e405404c485f6fd7c3f9f030732ceb30182004deb678957ef98c1de45908425e4d9a0031729699d19a7126a8bb9d6f954b821ea95150bd89492d2d061069a050ae00484ce93f3ce15329f98b8cab5d010d05cb8dd1fbbf23f017fc470dbc64e00af76dd1336b897c6ad905eb87c366e0396815f970ee8e19a412507cb854feb41a65710a42b2d98ddca8d9b56968a486b02397be1d887ebd920de4c06886e3dadd6be3469a017ab3ecdd1505a873b5aaa4948a36fed7425b3da0f7ede9c5b9a656da31f0d7550e59f180194ae64831aab3efcc9085ed400ccb3e62cdeda70f047d78855444c526c2d3d6aa1099bffd0bbca53bda58fa51fb7ec60074c99a7a711c1de2a5d9b8bf562327f4b37660ef903f824ecf3e79b6d974c514ce50825385dd14ab08318e91ed88ca6dbaf0ccc36e35996cac9ab377930dac798b60f43d40519b179748d4d92344f8fb65e916f3f994902ef45831088efbba1a64e9824ac86c64990393204456422acce26584540600fd94cc25db3a153f60710ada81e99fb38fa65a960f263dcdcaa7a5073c2af4bc97d41bb25bb353d44d9d888ac10005d270adefa3c0577f42e689a2116ad6e5a7ab92629e2dcf2ba503f6f277eeb8da8f8887c6ed5f3ecf43a5a95085ab814ef710059c3700bb0b3402525e368a3ca23d48aa28edafc3e6ca81f4b764486a906fb825fe18d83e3367ca14fd86e4ec08a22db7d97218a309498251f6d07308f4e5c431a483e38137551dc86feb846330cf33e83c533817c8523406978b70aa9eed27217293705b1508af4af2c44701a8eb999cc501f18934c4a541ed58449bcafebc371ea801e483b39f10cf3ce8f083167a32b73e01b3b5cd801a260d28e7bd467cfd56cf11d55d4fbd4cb045c9319e397ade5ea5bf3220db25318a2bf0ac2cc5a6462fb59a0e501342b631cff8ae3e73a0aa639bcca7b5017edc86f0d8ff8ad63f2a18ae34b2c0e3afc0e18f15cb195958cba6af8ea85cea134590886fd9259404940282dcb824e6284d198b7bb51e4eed97f59c96e221daa2e906765a3084ec1011d143e17dd4d0728f66628a9b3028e0e4bc9b1b7bd95c21afa32f518f551cf6b5d2f25c96bb521bb004345ec1245e29e2c69c365bdf1c681e2ba1bc6bde46dc8da2720dfcf38f39241530a67e65468f4109d26ba8aa71ce09960ca58cec1ae35d0b84ebd41067fee46a673e0ebfde6dcd6826505eff04cb604ef088872cd49b90ff7602fb9d0c0ffedff55286be79c4a1e9cfc628dc83e981e6ccb4717ef1db95404181e5c1b4aaa0bbab09f5f36b2dd13a8cffc945dbfdc540bedd77776f8387d3d2b24d3f7252a83f3f56a44b955aa16bf50f871f7d168138c43f64a6fdc863d4e0962f2835486707576e67590427c7f38ced9e4f85d7ce55da1afb6f020f1386eb14cc4ac69bebecc0ed846bb26c0e84425e2a56fb2abf6c0c429edf83194c39f7cdbd891dd145ccc1d515c2b206bf5db871d3ee86b185fcb3fd2370104a429014e8ecf9e38054b70fff82f8b842a510ebff6ac7db9840761576938c8cb4262c5c823308e3a32a23b90031d43bf5b50226a27d3d6f85de64630b34c9eab5724b94938272404378684004dbb3e47cd2373a15b90eeeee3493cb446b5b4d477a539409c3bb2f14294c1360473290172b7c57af6a4c896a438f551537bf944e7928464b65f453c3a806dbfff5d17647b46076061ee021bcab6f32a912da30e118b447712f0f33f26a874708b1fdd130fc7d43bfffc75f298b0af825c33e8ab67efe28ac67541cf097487440b23e0273fea70a7002e4dd1cdae2e04ab0d541fee120354f5d02b85d11f81851fd860baf9b288a3725cf8b54555c163a8a7c6f42d3a0a11aeebd7bb5dfb1b621f94c10e82afcf078a1e8548fe59c7697b5a570226fb026b9423b56db61d871b684bb491dbaff8fa1b74a9b9444d4664a7ac9fb6bf0c10107562bb14b530b4cfd2304cd49219ceb2e68c80f7ac469d750d0e5f08276ce99f7d0f2c7d8dc0fcec2d42475d90a86d7e0cc56d2755e1bfc1a0e0fc7edbec541323abd036d98a73f877246efdd467c4cbc716817ffec3c2223d07a25b5c54f500f9931df91aa7b203f0bb7ab0095740e6597a44d88933f6d0f82c71d2fa92580da19917dd7f0aa2bf4ad157f4b6c514c06219708b4481f492742caa3feb46a560c23bb7afba01e31e6c7ade19056341c775c34fe091dbd12c84f3bc2fc58c7322e1d202e250abf39d15a1a8889605da3c280e72c6c4e893778f1050fcb9f837d80f28d4373f97430531c8a174cde226e0adc63cda81749ac6ffc486e2ed7af05ec0d943c509cc8fd253b12610407f74f67824acf45104acdc8cd1ea3706364db85a00251021c8fe7102a5be712407eee7e856b27faa5ad5e173d829b6167c21fadfa250607b497b4ede458de02417d23763e6e89f87e2b8e7ae9f41c6239ee32e41c3d56c9d8c9e478519c265e916f7567417b02a02a4463baa4103be31defe634b5cf3566d343567cc9e4a98dbab191289a2ff0e6c4c604054322a3f328f8d416b8fd17345d05f523e0dcddb13693d0f5c97db6f14a6aae23355ea31bc38749ef239280508f275e736ed8e9d7fba5a4fa6a644fdca8f46f4ef49a14d2a64427dec6951d0c9280ab7e88d58433108208f6a36974ecc2ecf83a5915a942ec98c1c546201b9dfdd108414039018d46c606819562f29f0456ce8e42f75027818dd65d6b05bbb4ca277dc2135a9dc27db75177839e71050bd9b02147f3dde166f41865a035f8e4a8a4112468f2478b1e804af2857a3ac303def1af28a8003b4a6f41f96e93b825d72381e390d805d2123ec54922655bade18eae67f4e162d23903c3f1dab5e30c7230e0263c2c76db6dd5aca9a474b58ed0ff698cbb8d16c7f17f1e92f4f1f23250224380f150ef83d5866eaefa05ee77bbd540d8f71c60e7670cc8fb25ad1dc5cbbe30ba67a049d9681dd89520a490cbb433a7356f5275dc4cc3ea2e6eb034b7adf2869080758ba2302c88139a3cbae4795bb8a0a5f0ba302df480e83b5d041859eae9652cf0f0bb694e0d45fafc0e272544a5bdb840d59f2e5677479781a5204a352c491d53efa2c4bae23b5dcbebd9b61c83779858ef6d31498105f5b239b652c500829df7c11dfe9d9fc49480be42e057f449b78405c97523eb55153ab6ccb34ca21ad4ea23c2c253684d09a6377efafbee8a979691ff163903c42e66df1d10a938fd3974be0a1d5cab22607207a1bd86a2742264282dfb07304514d05e4584aa74caebec89d583365d7b8db6b4e96059bdb9bf8d91f265d1871f19233d0f9e9e01bedaf0a3643e4cb96592b87b3dd8896759bfe351146ab079efc9bdd1f2565fcf2945d6fde89e3ffd940227ed7e43d21118171cf1062e72baa5a39e10cd25c8f6403d7506a2a1a11567231c3d28d30f6873bf3841e8c342a059b1afa73e732f0874a444362c274f2e8083bcbcb41815cbf1db5a76eb4e6c8e7820e217fd323e9a88210215426f8ec31f21b9c818a5af17cd79a0fa776539c755c7c72ea736361ca207975a8caca1dd65c290f7e4f2026c2d81bca75db7745a44bd6534cbd680e07aabbad1ff8cfbbfabbd9814764c4f638e0e62f6ccb02f0c8afe5cbd95a78870109cb7a5139417745f0084f71f0269f2839bdcbc9ede2526ab4c087c7fc0a9251869b6e85c4e3d62b99d5e808ac4fc79e958b0292c0de56456671e247c105e4fd5015f93e07ea8984514f0fd16e1ffd2a1a24eb7b52ed4889f063bc4c650209954d234ee11afecd5fa0837c0e0521e1a6cc93b0d79095d16c67ad3276efe7369fbaa44c01d43c9d85aaee0d06e6ee21d3d98fb17ab1a86ac50d6974a8d06e722357a7da46a08de0671387f21931517261e2c2f83a6277f7e364d68e3f2864df8b89366c682312209bde401852a5aaf4adf301e3d1efb9f125739329971f85073b3e23c3f1e56a3c161c37a3542b3189b4c7115d06ee4969eaaa40da6ca1a347b0e2ac13f3249ac0b3e3e46fc9b1780c5abb7bab6e9f897f4db1ac77912253c691b824d35b85bc7b18fff4ee551bb5e1f2f6457f3b5ca19fb9211aef2b3cd869418450b8ee5d6d423dd523e059a692937d535a88e1c313b310bfe95db50a71e481f776e217567372165d2185374d39e73dd45a7f620f17d583d9556c1d83e10ddbb63d28f3f9e8f1425c63690f158a5413c1ae39461e3f82467c43872251857064255c1369ca77fa6e02aef7333791dfd24caedd32cbd46c906ca008a6bb156b343ef0582d522655065c199191dbdfb6e669488a43ab3126a7f271d81313ff68be6d4cf11504e5c51c6eb90d6554451f8caa614c7d60cf9d14364d41ee096cd4cae0e00b82b1ba4f9a3070586e6ddc5e6505fe895df776ad7d0e4101f788c9dc00f807a14d69cb89d02b95d771d823222737ba35a8c5d1624d0022e4558107c840ca66fcfc82ec688278ac816350007ab027e456897a1a16428c091c45b28f38191ac1b46d78f0135df51ae599e9279b0410e223edeb410e1151698ea98d15b3338e96f017925e4310c19f91793687ceb92e06a4cf2d77c1fa939ed880c30d33fcd33ceccc42653b54e989e8a3ee22b966e5cfcf96963fc84e066f41e9331f43a9b344269ec00473bba68fee0d4f0b82fd454e547c95660e309d8d136c2d420407b3a9b2680c1a7f6b01c621f4a44c6d152392d7e8d7f3a34e0c2cbca4d915ab90a27d2e5100f04cd7853277bc23c5b196fdf8225c24e3e79db2beaca9f7444295ed97d8af17f045aefd515032940fa7b5cebf2fd90924deaf3da6bb5209ac74310168866756b4462b02285bf172033bb3b34170c0fb55a4ce225ccc1e03d5ca960eeb2686964b861df2f3dca6c06eba064f818e2c97ce2c9367393ce48c403f5bc11e71d93fae95109c4ed9febea8848c23179bd54a3155b3655edb144531ff9f5c28d2ab2e1f5d6c40d95dde256d2a8e45696cfabd2e8e1eeead25c7ce642e7ca58aee2ab12ff7774e4920d6257f17fd37e5e8312d2179bd3f622ddce38778c113ff8e470a6de103d61a8f55b7867c01420d029e29c4ffed2c3b41047ba55ae288f8dfd0ea4ceaac6cdfd52da916df69afc82648f62465f66baade3c9763be5aeb81e3673661b4c2a9230fad533436c808bf006ff4ebad8efe6cdfa30dac5b3d6d3512d395cd9974c2b749da39734a4a83dc61cbd756e392cdb7a029ef980c5fed638f50eac6a590bb0eda72906e58ce9e2370c631b96847ac8960a2dad0343fd76c54fa98fb81267bca68a61b40a3b266ae378ec6bbc88405fea82f62cd03d3ca95efac310c743a2372a12d0815de5c4d94904c643386ddb484190e729ae7fe084cf97ca8b8b21d1ac7a8e6fe16f0cbac0f3251eca1d2ff4eb4e3c2bddbd15247f89526f7a5527b7e9ab3cc5d33e4f76b2d995ff096b07245acbc3d0ef04d9b567f1fccb82b6d34b6d10cf021e1f1e1207a993180b9346911432b4dac8959ee4c7595f92164cb0ae1319c6d7e1c4ba62cbfaa4783425a052eed9fb4705068d5338e97534277c24681e67c5ddd670dcb3a1e96afc37f8acf45bb8ed558faebc7ba73d45d03012657c421c67f3ed09d30f655bbf3d720ecd7d6d8c928235a445470562aa208a53adcb593eb446ba8695551f50e2d7d9ce5f4c105e319de091d0ac300bb6e2d3d574d790d9c38cdd62d9d01895b57cccff1cef355ac3b61288e9074b4a4a053fbe9e24614048161cb0ec13f4fce122e7e7624c0316b9e935fdce891c33a49d4c8824c14456d4874319b343bc208a85dd34c4216bafac40906b2c54bd4803e44a41d28f025be4962971c6e253880ab969e823daa4cc3e25c35e4c6531098b6d23961475eb20906ad4ae21a948571a93c04b270ba5dd91ecf54e1eb46153885086e1338154cec32c4e75f0792773ce13ddaaaf4cf29b4ef2f1567a19dd5a866ceaedb70f4e567c502e8271a6d923f9445d44c54ae398c3ddb374c9f66bebb18bb28ce5f8d857594b927cdb593e657d4f4748c54bca8ffcc2c4a8d2ca540257435ad47479765c81698eba17bdf437d15aa457dd484da8cb057baff045fbc8a584bcab57f41eb3c78f1bfa4ee53a5ced013cfa6c9206e8ada88ff0554b16defc0d9775249e4487edd9b951251da48d63ccdc70d7e9c5d2294083c04df0e86d809cce5ed632f401823c1157f56dabc852760aa80b76d0f01378f11f97588acd72417ea04b218a21a3a3a0cdd70b347b75e0ccf60f2e4830b5d11d9c9f22517513241646b56043a75573bf1a35d8e8991fc5895ec23cf0fd061412a2bd4009bb30e438f90999e515922a29f5691c3f40d42e984b0b8f148de4e677e28075db2963b9397db00061951d59baf89f90e6f2497f3499f5ae6ad005b61525b745740c803b2f9c8a468987c95cedf3a379224933fabce61a1892dcb4d4f02d995d40e5fbe40c9dc0bed2b318e9d4236a6a914a0cdad9587d832394b34ad0e8a68d57c3fcb5c060e364108da26ea89ae4aa917095dc45c0b320e85e2c623ec7664d7b41a3a3e123cc616b05e17915953a4f7b2ca123a42f34a6c679ace98ec4ed00570bdab05aa23bc7ff2db530d238e5da2129eea17c6c9d9609df73b9414241e4129976f61c33b3b58ccab7b9a0122bbf292ecd03a6e37ccdfcf00c95d565d9dded51fd98b35d8d72f877df944ec03a23b7deee8b82ea1106f6225b44d3cad8855450d6f80c24995bb1a9736bc60ca05599c02e44c1eb290d9e398a8fc054dd8b21d3db49c410f7dcda76d27ab28218a3fbaadb0d29aff93d2399aa0fd4e639bf18dbb632197b3ea1ff461e71d77871e1313ed944cd073ca03b2759897f69d6c84cd3e3be9bf966d7d9ce41f45acaea81164e324994ff6fea89895f9eead5377c99de51aeccfbb4e2c19e56b9ac7d1282095df6d610b56681e8a3382c1abecc1a999c4932ce15234a57f19d3391de0ee2f0c9921c91738da877c92307a2c158ebbfed34a79247462186d5db15b7121191fabd29e196e5f8b018fe20d9b233c993002092419ca1290e71a272a1f97797480bf6d7c865b3c79dff18a124dcb44b5c03131e9dc569d322f09db20be5aa7fa390e89b07fe0cef81ee25183ca44c32a212c0408f700727e21dffd3f720262d53e681bd819704a01819b1e59fd557482199b6b68fbfe4fc6b8ec17444d5b3cdeeff0342f9cfbb20ee5c51715d026e306a8346601cba31a427ffc5038ad9abec19c1e94b567d4976fa6092ee8f3af9201ae2c92227392a6b3ddf7e10314d85433c6255de99478a4b8d32e7d331ba9203ff498ecbe71d68fa02dad634c133ba6975cf2f258c00d8c9e38973b3e8d377eccbb5ee343b846fc24bfa0a93af2e6a04b6f8f37977fadfa02fd7603f44cd219af4133dc918eff558e6b63778c1551819c85fe597e49805f775ec2aa2256a448cd7e6f242be07b406e9bb1c6578ace5fbb84ecc757ee06c1ad79755d344ec96db31fd0cb0047deedbbb6fb9f62cc8195f1b79065e4b4f7676f9f7e972e68f00f5e0040abb83a2473758839b80b11312bca9d2f4c256e16a0c8d24580c53f8d6abb6d09f98b0a5a37455f6a204aac95b5dced60af32978d1c3ad97a8f8b90458c136d5be62e4a974247b54e462a26748a55321900ca1644face234ebfc716615d28705b0d8b74972cf3f137402511474daac13dc0a080211e48610efa2bd995fad03333d4729a11fe582ea5177def816dc59248b39374cb65cefa0d0052ad645258dc7eccac8ead0e0954742b98183aa3c315a62b045510d6a5de1b478fa191b7f2d76d9633af0a3a680ff4a60873e88a78812986d60dc2eaf05f12058213a7abf4e521952715df5571f7a8f740c826a7925af3b3ab07dd55d96b6f7773bebd15793d62b8e48d4e27c40aaca588295e58a2ee1d34244ae73d514d6e8f917bed64c0d1576530f1e31ed54d9350f349feeb3e595e826ee966e707e0a3d651f211f6ab2635a455736392dec3658e55a664113017207fef9ee0197bb49a383e18096002cb0b3d0a7328a5360ca445be92c60cc71d2c0c28c5b7344993b6fc00f3d0cee904381ffd7765a074b6f80ce349f383d24a93f5aaa896d7389f703b8af4fea92230f930a97f240d534b3084bed710300adc55696840dd4107d491bf95a3ff0fe1e5fae50b2708b6a445981cb0bb4ea7bff9f2947c26a4b302b702765d0dad1624c526a5742bea508dfa60c036f528a0b1d2d0209430955ad3b3f7f7ed3b23a5beaadc83a07ee26c3e0178d56689a2042c85b11f8f045e0c5e0247912e232c01a43968efa9969e8a48aa3d1823ff5fcbd9da5511c92e81df00b4c773dca60f6589ffc4a4821c963bd39a13dc7f29bbf3622d498e6f182437afd8166ebac81e18964ac96de40e9cd341d5c21c2b8cbcbcd192d7234e780f25d5d7609905cfdd50defde3a9c39fed157e912586477c74b47d9fa3f044c0e6cf48b15ace8e86b7ddbe248e0d6a16d4bf8c589406f1978c025ae01651aeaa44e4792414288d65cea4e603931f3e63c443674e0cf25b33acfa2e982b47848e4aa686f40f34858e894e7f63c644691311619da351aa8a8f372501ca6b7562df122760d702d814c1f6ad36c9b4d25eee17ca26a06b78c24da1f52173b9b5d7a98f904f3db9c32f6e4f5d214d7946a93ee643ce8a95297f48f02e34e72c4f4ee10c756d207a0b16e7d8e7f8fb3de5e08433ff8f60754084d10b2004d9dcad24834116296d6592e26fb48d79629a1b779d916c2d3f3bfbda4bf61b10fd25ab41b322de5e5746c5b80a46ba9866b3a43775be9023f5104cf6b540218c1930385043c2649168595abbb1412898edb8aa09b3b8a9d77e5656876a6a0ded5985c9e6a0f3b7da885b86d5d3b3c094269a87acbfb8c19c5dc6f7afa8eb5a6ee29af01344f2820a2641ea06209e99dd1384e47dd7278404187b896fd90360c41cf36f8e77054f10374c7877985ac400ffbbd327c592607769c4bc83143088af92c3f247b690e98545e3acb8cd716594d4ca55acd960d17ba7e3f1f4f8c30524ddf7ec3445372fb49c81775372212b9181cfebb2e9dce165d342add626d91966300d08c820250c8c47c2a3ed7d65948c76650d90e03f619a83b4d793e397c150b8bfa04f921f4093af046341f31c5e9827b0762aa710945d42dc1e17cf9d9ffb438a3298ec41eb95a3120458d017fc52ce36a8240b758368b50406d684a3a6e405f5413b5efee753ec4b01fbbe67d8cdf16ac51cea0147614a710ba605f758585a3e3fb3b92ebab2f492e57addfc6553044738c7984c6eacf95026dd4a9f1428dbf7dba733ab934a1b7f26deb76eda4855608335949d1a84daf9c059aaea381dba7053708e6593422b87fac1d7be14e59c070d55b843a5f788730c29d5490809d386eda6056655031d1226c02f4e0a0eb084205b84c298559a0d50cba5d0606389fae9da9e5b493f810c69ef116505088d1751d0be21352cfcde66929a88bd1dbff153124a7b63c6ed2443ca537ec5029d11dc4658416c5ae98a4561807d6f2b3f26c35f37bc87d8f882b8039e06c5cd89513515f3069aea676cf95ca69826395cdb54d4b962c2ce8ce611189517a0093b7a4fd3cd74f2102c43f3ac5ae1fdd42ecd8308aa0292dfcd062f6e4267cca0a996a3c029165da18b52b5c011d1df179e49a9ed677dee436211cc839a9b7b3fe775cf009f31ee5ff4c3e018cc9f09c98be6dc029b4e7017ac36d036eeefb1f77305d4cedc824deb82f9e6ac477673480f39d9967a48134b4fc6e68e878e0348841ce4271006f443721d3cdce2b387201d2ae6575957a104fdd873eb35558fce234955d006495d4b94171fce5b05af404381a7033a1ac64ff80a8e0322cdbc89b86d04b8f37b9d8a9d630c731f118e16e3530e0d6ef3d49fc1c7022d8eb742c1bab3076f4e2511c4dde88e2d9fbfeb7e0ad448f513395445905e4cd38f2dadc561541821d244bdf1184fed4f1567bc45a477938078f449e6461f7afcf44f92249afb242c091499a091f99283261bc278509826ceeb230955b6e13eadb95f5ddcd570cbb6feb672694c818183e2d24f41919f154cd0dd56adf4dd8f93ca7f9e11581ba1831a3e9407064b904673112fff81bd00bea3ef46c41bc8ef37e19bcf9d07e46c487499fb28747ae493e5e88a0912e19baa0b3d3d980370039f8f2745e2030d1ac27936834ffefa8d50e073df0a6b73e3ab28b43118913b59c8d867a8a84a5f2eba39a743e9c60726a10a74b73300017c7cdb9c794784d941d145cbf14b86c055c0898c1343b80a693cfe914b6ddb86826c44d24f9a8db4862a66c1b5a0b5b39cb33eeddece7853fc600ec7b3011c032d740ff8ea3b2627affbdb8fa05bb5e149e2820af228f75f063d09e43d12a9a7d4e0cdb85e9fb641cb92f9f362fdc1227e10bf1247878bfbb863c3b180bd8259eb1951feb4806edb93145414521e3178a00fece749e1d3ac91a1c1d23fbb9abacf016a31fd4d5729637de4a1572b5152b1064cd20620ceb75f7339388783958332d130b45370695c979292160af2e898934b46d4fe17f9410d47349cdad4eea409a2f374dd34088d701a2720e03a1f26c388e06dcc40733c25744c037e46157b425c34484075f57f55030920c89b685b6ebeadd06b96ba80bbc2531e5c3d1a349574a031e1ba0448dd37828f8f55d2e044cf939ed364fcbd3a152293d7a89d72996642c07732eabfec9c07cb8caa053f1ce5f822409178f8d9ac01eeed8619281f7f98867dd4ce64ff1e4da5fd071732440a4df2ae80bbaf3191ed9594b5fc9484f53a76ba7e5170a19f4cf68e92aa7fc506257adda83a0677df66b50ccfe01c3fcd6a73b37f9c249c5cfd2a66382abadbbff75bdde30c846ecae102e9f3331467f82496419c681180e06fa67c42477fc5176e2beca61790586e9bd1e59d37977383234ec74bc7a4b0c11b9775c9cf52bbf6bccabdac0ba70221a6e315e843d53d1dcb2e0a834787f31638576622d7d2d5fa3c279e035efd03f768b994edb7862b6cd7ec5a3b000cb128e2ad832ac76690f6edf0c45f2afc20fe494d6a06f509512fed346ec143bef33dbd54d732936fe926ae769072cb8655ddc482e870390b2b7acc59d9cc4cc63b63d8255c61af54c6838e3fe2660222e76f1059b9c13e831dc5d823ba6e678c1ed4a850b2782fbc9e65394d3c23cbc951c3590ca7cc4957e3cea5d52a8627e4ccfa968a9af5896e87f4fcdd9e26fca6032060b0e9533971cebb508a86533400120537c8f293a38ed002d5afef27ad7046b2721b82ed3a371c0f551a4bf55947824a6fc0af82e08696a6b395bc46abbb781c1c8f9686a7a50035e45c00d1e93e03cc0c757a3421ab3232093aa4085a40c883b6bafcbd1717360268cb365979893617ebb822d45916c8cae71b822dcd9cae6fae45d3e2f17c563e30ce8a83ae966d2b4598e79e1b1d07a5341e97ecf110fefd9d9dafa84faf0ee645eaa028686967877a219d067c08969ab2e11a91b42c4663afdc175bdb51dfea0bd56daee23a111625da1054b90a6e37fd733af704e2976b1602083e3ae4130bd0f6456986f474dc2065aca382bfd6af9f43b54e815ad0ed2570d666af47b143e3b207fa1ef01083b2ac89966248a453a507a671b55612cd787bcb33ddb693f6046fcf9210735407e4e6e82e610ca2d4a21a49a961392ccb8db2fa0559d3918043238a98d175037d69b4a5c9e537efad01b467c65357ee1f6922ebb768baf4a37fd5b78cdce980c88a8b757979e9d421a3addfe88df63f927f6310707a6c82511097561690f93eca95fad9b8abf9baf97b699973465c6d78865321723c9e6281ebe641ebf525bd31f67959e7e4b60869baf9d7e711710ae92c20f5232a7a3e3cc4f0fa60220bd2b5737a918c419893cce6d5a3f72bcb1fc9aa655ebce664632ddb21475d819bbe977819fa792ddf7a6bfba79638c08766f8720fa4fa0eef883efb0a1120c3a0818aaeef435c20f5b28836b2bd87792cd64f37f5b03729cffab23c42ba94088f1d1f32b1644a48add83e0a747cb2d7727faadd06c382f83b7f66e5ed264f848233f776a7e992582a3c19f16555386982c0ef70de6adbe56f6f8316676ff5273a5aa36a51468ed0a7d610d343eb21f4dc15758397a8f5bfe444949d0f572a99d67579222632d2ac98eb18102ed45dd4578bf9b92be1482f4d9470531703cb70e3dae62a9df3e7c3d0e05b0d2ece7a3a8023051f92edbf35a4a0fdff164db9a5a1a9c295de5483faed04c444ecbc99759efef5d1351ebd88688ad5de8483f47e4479c34fbc58f1dadfa3a25ba50668c7113c317ca3ee8b7fbffcaaf7361a57e01c2f7a3705f666f59443b229ec42642df3247f90a07e28a268bf44f6420753f116ba053b5d099c09d09bd62b210409800c1564f8f1a2c633e095ade645af6f6d772e00d202f6cca1cb1d93dd0ba8b7879d1c45cad7e61dc8f39257ed97167d4af80b671303783b01a5c795aff7440bdb39e270d05a6fba17594d278652760b54e9a10e4772c2ec25492cb34699278431572961ce0e97360a751e5dc87c324a2477c032005c7d47467c4bfd29a19c5a296ca0462a7c97a10a4ace62fdce12b3a40d99bb174ba3400f293a9e9d3fb88067a990081e7d318faff3fef922f6e43999b4d1df980a6627b1f9f0f28b5154a04b6f931838b26ad308a19508ba2bfbb590f196ca826f963d7578d6cffbe64f90418317a44f87164f6cf073dd2e6d4176d85a30db873ad175c8fab1d3489c03fecf9160fcfc23bd96f78e921efb0513c7de576a95745d43fcdfd01c43b3181f8c0c3045b9d7815ce37b3b526400620aa9bfd40f9a3ed7c49d6a87efdb53cb43d1a6999398a13890c97d29c30c08c22b6980d31f71dfeda4d2098c25f2a164134ba6379cd04d1dca252687e8cba3d5562000399e00d94406e9cca09c860556512c9921f161ea80dabb2ac1b2b86ab94899aeec12cada3dc9d35bb67dc77d5654cde64f3874130ea1119542ad6fe0990fa40b99b005d2b733edfb31e991c11f18ffe4ca5d8e85a78cb8118bf7b07da86d09e6a959ce6685e8fa342b44b5618c2d300f4b5de11fbaf26137f3a5a10ae4e5de4eaa70397a16f066133d50c26f0e8ee07cbe32023eb5001067a0fa05638b7e197c5d2843c80c5258d93342d8d98465404a775cbfbc4fd9652c1ef853f0deae67b0a0a0170db590fc33e9dba609901c52337894836cb755f0e2e60efdc796685d569202f7a6118c76b2a369c34634d83d72af63241f1e52659e3fa4f24e8dc60094970e7b2cd8cd17747407348f9c8d17400dedae990dff74ff192bf4a5508f3ee37fa415150b06628e8a1777b606fe801756482926a07523ca58e01c7ecceecbf24813a9875f741267ec3a4427503e797ab80b360ce2448942a8eee3a333462af38416dd16cb614d60a1ff519135ab8554d79e83d2b4a572ff2faac8689979dae2db83c29b609a17c3c428709b62734d132aef5eea13bc59e2ea78c4a4f1de39198304ec50ffb602e68e1d4efe33b222f2adb203bd9a32bb48dac1d41139de65cc046689bff77c8875d40504be7a2f36fb23750ef2fd3132b677a7a97d7283dcbefe4787cccaa8a62d792aa0cd5e6ea54aa742723e0b6c41e47db55b227e06adc5941e7bfde4421ba2eee612867c8496b9d7a45c0429444700c6621fce311c22cb1c803e3d9ac4451073f6c1fec5220fc295645bd370546df76def95e3537b96d1fba7c5f54700b6e7651247981b01bb5a1c15195435b468912842394b817ec761ca669e78c25e8f55457a7fed1e79b561d1817e6755442c91bcad3847eb6b308e06a8650500c494856a5708d0132e8c39cd0f1d363bfc77e0b2dd6b22a5a686922f18602178e89d0b24f410d9b912c0e03053e7c36297225dd64f390482a1d5b002b89de51453858bd8e347906cc6e912357221709fdc8bdd9c86c141ffc08557648ddd2ec217c57fe5df0dcd4ba1a5803be80c0aa1d66d6cda675ddaae71bb5f39b1e7fe4dc0bd92bdfc130e321a2672a8457dd740df4419d137954d6ad0467b894d36ec643f4f7d98e24f9c11bd571dca30194dd7c545c3aeafc08cb904dcc63cabf68816c10ef05818cebb816aa279e5d119ec81bdbd2aaed7c062169dd7d51dc9056886ce42d873fedb4daac7db85537d474d5831691d63d4d4f8b18f305cff21308989ae7cb5250d299198f3c11814e1532c3e1d88ef5a0cd5fd0cd506d3c9729720135dc80fe0abb815dc9d5f1adc333fee4d84dbda185d142afa394935e381ced0ce4fba51ff8452d8958f9adebb1ed20fa420a555c58e1826b33c68a098de1465f7352d294952ef6ee0f809c255c7ed6a35b07d759d12135e366ecf4ccf0589de1e696a795ebf8f62bc0b3a2ee3d5ca993d341f496d6dd12ada3b6915643bd87ab2165334398b203372958e1191574766da486157f4353ce1951240625e5225f9a2d17283c1ef3bffed397f5a44f0f1b0f4edfa3eef1e932fd0868daa4833e3eaf5314403430eddd3b1a7e5d4f16381111c5d8f122b948e6f000277c92b0b2ba9856f9689d3be42494afbc9dcd996c11b02c533010dc1a5e8c02c77239bdf47ceabdc4eecce7eb1b05336210e01da8dba3105e52938ff0cb9e0ba7be943395b696ebff1e414dffa97d5a460e31dfcea2bf29ee3896537a6343aa693031714a19c01799ea0c55187512401ba0de0b665124ab4983f4dc55891256861afef2cc1596250edfae450ac4968b8c452133744ea58a9739837fa4b2457169ca0133bbd6a7029acd13444b78e92d53d1a35c4bd3687fae63c17b7c805e231b466dbae820e4d105b22171ba7410d40e3fed09a8d16c2a3d5ff1b5656bdc64c14443746e5fcb0814ba8e06b2d34684bd85536c47c3c60f8db47d8acb7c77deaee65ba9c51f933d8ea6da263dd6b87dc264cf5125b10a5a9007fada57730080bc6ce66937c145f020ace97c3591e21bde2dc7bb1de367e1b4997886b6339555688da279d2fe74e18429979013d9a24216780135552e89a09f90ec3d7913edb8dea80fbf0be6ba8c1de1d453690ef586f1ab2cf78d084cc9f039c073278c0b03efcc119831e85e48be0015686aa93d2a279b6fed000a203a803140332ae9a4f7862e75801637b5eb049939e56b413170ddd1f232f8b14a90960d05a877cd8c2a80671b558954f89736c7a3614b5875b03df109860f9dd2c9e566cb9b657d05fd3cf51adbb585d6d65cc720177037999dba772ac916d7443ea36cc738c141fc417b4a87450c4b11818ec621e85b2886ad69f90f3c53a0f1c7c35cba9596d4f82f1d9398d1e5addd50c3469575807a285404161db6e4e7b1e19b5bfe1dadc3e3419767dd82cad24add64cad0227819a6fd976166d1a1aeda4d3d786b357a9ab636c2006c45a28b4ef4fdaf7f6c9010d0d21f9ba015f687935eae76ffcf27146aa81fcc9977c5925b8e6a09d168f495b673d2ab5b7a4202462ba17f1af613622409c12098393337d183bb818fb9e82c2e5eb6b27e8922790dfe8b9047635dbe03c749f43932797c95c470e070a29f6c246f4c8902fab04b55833935e81c29fbba2c3d0de734b731f27405eecb6fef0fc1f62de00776b06e9b4608610da0eaf68f38c6e433b991fbd799232ab4c9f33fd0c91bff9f79c7d6fa28f974749db75bccf20112f4afc660a8d72a4456063f660a55d0979f79844a4ffe09155f0036d51bad20d82b1604414579144fb84dcbb8c9b1f0fd059234fe4de4a4d735c840cd130556a2629f578c795c7d934f3f8075228042ad2f3536c64373af5c8b3adcf97d4e832e2d8117d7ec50152aa1d7f35c9941731afb87727483682d7d6a94e1d8ec14dfe3ee1dac93d578cddbce7b7a6997aa97e335de58635194d1e8ad77f9c1ba3f9145bc57a5826c9d67f31ba445934d3cf43dd5a3e9030aadc24f4cbc8ef4fbeee77955de69769e1dad0183e85ed7b0d2e8c5ffd03d6196a0fade10fc2fa5003418bbdf1eb1b56de594a268e0aef48a121bb0d7f1e6b3e9f5bc1187dfedf73cdeab83614c014c5c724746a7a3207ff179d26ddd25e3f5eab3e6f3e7e47c043d2c37a7b554af0b07b8a55bbb8d17ae6d28e160c8d2f44e37dcefc9c41007ee71cf3318eb7192eef379e2287df47f0bdb77a9d66fe41d01cae1a9b9078206a24be9b6d2479569517fdd76beaefa2aa1904ef635532c914c80cfc15e72fbde898d184f51b3d88cb9a855ee872fc2d65403c36605ddb5e5586502e8bc57dc069e2b1d750c113aadc3140e2a1234de9cbe1f1c5e413b88fea63433c1c6ee10f3e2a7eb741d1cf9f8146d1ca09e40e6198e21e4915fb9bb2a7585cb2029883fabf0392b27ea399c29416329d7ce028fd589fff8b0243a0c9ed5be3b42855530e7485ead8277f0f7424ed10e9c0e5e7e213ec61343342969ca514949dc14ad6af00c6646b46a602193e86e203be825ce81eb0b454d0d22b2c6f87b467c2cfa45535f35cbb3c2f82eb29c655001ab816ac587affc40536132962a1ee56a679233874ef08d6058a4d8cb19a28f0867f34959169b85d422396969928f94d6951d5b153c401c7b53fd425600a1a8732a75a1d8a9168cc5aa3bbb440c1d86352de2f6af1a96da81d82acbc2f9deb9dac629df7935104032d964907c90d326d2acbfad65ed9b59d0c802b325f5ac1ce869864363dd957ba8e7739644b125e3c358b0935e2f44f42ff9837b3289e5673a09049e4b9d29d3fef50f997951788a2664ba0d166670fce7de6e8be8d22081680148957a228685bd30eea7b71fbb386a96a9944a590e4fd9a9f5ea317c6b8f7e93da8a3692c8442afbdc991bb535e639ca43a91899e4f7b9890c996fc36a02b9476fb6d66165ecde119e6622c1cd6d2a9edf9a0c5775bc03ec8c282e3ce07d200481db706c1d70504217c462dc678c3b2b9a008f16a2386a888391f4b17a45694e0d6933db2fcdae1bcdc0018d5cecf2eeb5d43cc8c74e31be1fbccaa997262b64894eff9e1d8cb28f64a0523ed0451596807d0e5cbb15b25591dc0b37335a42ef29fd8a2accf5a94495cf98f500ecb10f80a653251b52da9c651bf5012b50273d38b6634d677e329114965d6b3f2c18453600975c8f8863f8df6241ff008dbc5a12ca36953ad44256f7338d0707390adb0f2918fddd9f715f319dcc134fc17401d8ef2937f68e41ab0e851c564a86efa47e30ddd4f50d45c8df54cd54917c7898a88591baff9837d316843d5eca5d08228a38790c81b28d28bb02ad92c33d461620811131de594e0cc309f4df0ccb3a8e47ea6344c85a6d77e9abb73c0779387a15cf67c98369b82990682e3d8f6509f17e5d7c2d0e91861f65e19d70c41bc267e887c64d2d5085255c648f8b79aae2f73726c6d33cbab47397f28562b4b881fad547b6866d917d49077d97458695c73777ff8d24744bb8d2a665c0a43166e99da66166ea91c8ad7981fbe5ef7becaf1b0eb79937d2b0b720de273c39f356247dc96d4b833e6f4ab8aa8d73a1f6624a1b4ed7ac99e36038e8cfce0173ec14463a86444bd6490d0a2e9bac5b64953d2b19d19724a3f49d44df6f63e7a33021cb7ff7fe6f9e4754e83fde0975d15e0bab514323e2bc7ffc2d589d828c042df3d62042b12e9c8978f78fa70dfe54a372be7c8c76777f2b01d200b903619e3c5caa4787d49015680498cb69a05d1f3142df988f888eab74d259208220b8faa6ada0d36737c8d5f43e163ba403613b8e55d484752c320f8a7ed8e9887ae2c12a61fed3073033a8b9fd062eebf4d0d2831d5b5719d0bc45986e08f1c3d491f8f18b8ff7cc17a3305e448f3feafca3f7263fb6d03db27e1878e06d5d9c1505a82cee6070f15ed7ce2003bb432ece8900bc19401934c7b34d87103f2382a7f2fbaf776e6f70d17d306b94f980576f9e85213f647d3f1c41748cb8dc25e69d9d253dc20f90cbe5e570a53082da0e2379dad0b81f49ba9b2b2ac22a324fbd1b4f5c1ee7a81a8592b85d2e2a231179c9f825faafb0df38d18c5e972c9d57c658bc52cc2394d813055246dbaf2fa8ec07db0fd65e566600d131675b16ba8ae087ee4fd204953eac31766a2be22aed057541ecebd94a9481733c4d80d5fb60cf6ea0fec7b14d9652daf604c7e83e1834b87d72b1359bdef4aa2cc01db878794396aff6c9b6f6d364619a2d75bc69387065132883d1d633635093dea1257944b0c687de49b233db6493e87b04de4e7bca1d756f9c66a430b443438f2f34105fff2b912daa64a87975a21f8e1052ba765abd8dfbb66720466f09cb1c721cf11091bf314206794f688ce6e975cb1a71d2fcabf3b389cf53635e9ec5c6879017d98486f790d986bc706f2905e035fbcf26a4fde78365dd3497eb8e8320af8e368e3a475297be3448e0bc73445eca6ebd37cb95fe7277d5dd619e2036b6a8b822c6cc92e3d2db6be1214f555ec19e76dfbb499104f427d0e586737113f4344ea4485427096419d34dc2b194ef51319244b10c6dc7e5887829c2b72e962d7fb72d25d595ca631e753d8b75b0ad8a21730c3bd6c0bd9ec5eaeffdd686ca73566e921047c01704213f399253bed9e6a0b17678131380afebf6de7b00d47c65b891855b7e61646475db4200d9da490c0fd949a06801c62016659f7e98635f9db58a0ebc49735b4e13f731a88092dd79e0131a9a8ea7ff7201e1ba58c745536b757b54123252a483125c9265a7f34da29242d473b8beacacec8f532dbf775f68e6343d53b249362218ea1bc19b6291d2cc147453ed2f77159322b86e678f9998bf52ebdce2f560ce9dbf012774772af25a1c2f91c55dbf4d4df1f6a75a1a21aaaa94b2bccfc44a0e19e31587f4d649d3059b29c592e08a4d42549673c52d4062588aecb4309ca4ab38b086a763b345f9c1479067e215cf8a682dc2c6b0192d52dfc558fb535c60e2421c55d03d57b4b979815f1e96c5e64dc7b3a0054031c0033a11332dcae705df55f912a795dbfc012ee999f7a7ef097d056438bfd85aac9108592fc2ceb27358af62d0279f61d41544bc0d389ad64401b6a5736eb52d153ff6e17e8d8b419278da114986e0f49c7584d77bd2003315e69cb31e482c778111d05f54d3399572b2949e4a4528e6b8598b21b9aa3f8519eeda974134c22811640780f75954b13938a1a861e8588fb2543b88edcb87e3db8eb8a9f4d3f176470fcc4606eccfe80868da1d56d9da0483002b948fb80bbb871bbc42977369dd0a8af3d63299ca540398465ff95276eb619065f1c4092cdf8bca004e09ff4d3536924a3bb788536688f6f9c35deeab261875e2202fc439f27f47195084f9956914f01622a28ba697a2217bbdc308aee38b0d4a8b5caefb0787c69306fa41c7dbdb6ba463cd88d04a8fac55785c81c7926175f4c9c2b9b5ceeb75a4043c21cc3f76a9c9e9e5a941beeb0767b2ef76b8408807e82be74393c2fb20898966d9d7bd1358f9679412a34b9dd040d384405554c35ab7717a9e9007080028a0847a29b4482472d6e07d27477686de21076a14ac8070c0929dd06d5217f6484aac7709cacca06a9d72131c6909c68e3e59485f01465c909856fd8bef04b4dfd96c81d5a7b09690d458148e51d7fc717dc4e3b5be3f6106ebecaf90e2867fff27b0c7758505775bc94c90bbacea357d3f9fb59b4109a80de1d9156fe93efb26119edcd556b65464e94a68c0a1ab4abe1cea6892362d645d6c495982a899ce2107e7a192d1be9ec7c502fc9cef4787ee082c13200722ae5422ce8bd7cb8e0dc88c1634f47db4ea710afc84b43e1b8392607c58c9f7e372ef2038e680ab11c4003dcecf85464a6fbe10a34bfeaa208d916c063d2e5bda2aec45daec665d8c0f3abe8ff55d1bb80d71133535b8dadd093097a2ab0a5412bc5a5adbace6ad072f243e2b07ebc41519ce41690e8a52d7f93a460b2e6fb66f89b39052ab3b668508cc666afb314ad37df62250b3d3cd4a77044a92390ae4dca13eb0c018ac9e62d62010bcb7b33a977b55ed3be6bd6ce8ea8fbb78ed52b7eeafeb177ed1d989b69b456c8d18664eb9015f599c05ba05de27ebc8fa021226bc9adfb8a190bc7334848d1caba619e2d28019d1d55fb057f85728aebcb2cc8a05928e117913edbfe0ca6c481f1b255f53a3edfb7bca76dcabad04574f9b2b8a72e3ba8ec80e4cd03f024455a58f7b82dd604a10c4a1908ae827e2062d9ace1ecc734ec429436c00b3ea0661e064d916512e9b342803e67f75922f062fa3b28c6fc8c0510072d515ade297276ef3ad7094d2d7c3307a7d97edd019baf62c027139413f82f899ea4e2f81e19f50935c4b77f5808c8af057d09e039fdaa4dc53119b395ec23547c63531ac9e68fdf7a9764c8e5ccb6b76d928d66a9bee441f2ca74b068b712cad1fb3849e0948be4952ae8022ed5e2ed34cb9788ee6c5dbc6408bb55d34a73d8c7ce6ad7b847f56227549622609d48720f732978f4752f27d4279aeae769a1bf9fd6abb4b8dd762475bfe261a977ef1e71f0a5889cf7b2807cfb2a277e8c862a73f2d25624b28843b4baf872304647529c8dc2cf920ddc69922d62806736171ed8e8881a3a7daca76653c5b5287e2c52963059e10596a14e5cb37edf915e9f8dde249aded91b9b63f760017ae03bd1b7b42d0eb28513f384fed773098120876b436d5dc65e150971bc572b7c28cb9ef9dbcfb75b9946edf0057146b93d338f24536222e33b735cfb5f63872d2f60d617e87f13854f0fe8142231498c074e03896ccff5def78a85b84fe15e603d320387119c510520859154183e5a6124f570337cd7c0b0b433b6df030031ae9379f0e8ecd8119905e535ba0aeb143f29f96d4b000a56ae86831b8d55639712e07d062e65c3c28d6a837c63e6f00f24828e916d7ca6bbbb323cf5156317c97c2b6790dcbceef41ac6255447bfc94c916e915f47c4faefd7c8c864b6e42cae3359d714a56150fac7dabf365663c2d3c617f52738e94f80615d846e72f65a059aa99968cfd737f55e8c5d1bab1a8ee299a714e38e6b024ceb87ad8cd7ec18a7744527558bb301745d2b419d31922ed720bfedf3963711d4c125f61bf4bf3e4157d45f3b4ff654e053dca169678d6ce7f0285d6210e92eff793c47510239c791dbf6df5d7a4a0eb5023eca1e930e86b42fae8b984d8f4d3fac250d0571a26399345becefe24a47a69ea71577e959c21521e7b88ec1cd5fbefe0b642339176e06532526548f9d4b91b9ff6ee81fea895f62eb9a8f355d3aafe71709401d481014911594a2e2a8e544b5984f0037246196e3eef7b25b9045fbb34785b1dc390c4901d4eab34df3b3680b1ee70afedf28ccf54dc7740967f02c7d698d9b89002e52271214dc08f0241b11ff9150946a92fe5e261d32e1248d362c6dadbebc63c6b1e8d55e5265b9df5ba1d4143b7f5679fd2d4070c7bbfd43389eca8f6805375db60ec546bf7f95344d77f4a73dba95a1e5436b2f4264dbfc812e457df2bd72b57aa1af6bd5bfecea36e9589b7431c816537d293a3511375afa300313cadfbca1cff1a24de0ba37cb9dfce75a341db8d275018f4143be13be34e4f5f3ac41ff007c5a56b4faf7930f0b0f2397c1f6fcc7ee2f3da5ff21260658b6b5cccaef4a83b52d786859e73d0f143a8ff053f1bc251da9d49b79ca110734f91de8e42306f9dea851fb7b5fb5bf8f34164c3944fc24c8d41cd1399e8341049ae527224e53f535e04cda5b4376ee3c4b91b1d8b22ed6c0b31ec0ae88fa7be937cffa68d38abbfef9ee466ed1a05a548a428eb3f86004f029e0ceaa43e423b879e7c69250d1f35a4759225b77fcb21344e08de9be10dd11d9cd2f884171fedd2b4b84ede9d91bc15502fe927c9f03f7a730be98514d7524d3629055c76f91f02ce27b60e9755a28468709d7d6e483084fcd2687f25f5669dc0c8cfdaef65aba4cc6644d5fc9888bebf984d8c7b114f0b15142f3b826894fd4a8eecd8b250b52ae5aa7d0f4bc339b6dda121f07658b1aaefd78e71e36a9c9e74405bcc33b5e0878164acea9e88f49befb8c5ebb87a0215357e75be95c9758cfa23735d07ef25671f4125b7dd8cce703c7bda1380d28beb9c2da759147e558532437ab802db1faf5e393431e3006b51dc3ca550beb6864fc261f079290972c3b6fe14fbdf9e1078bf1a0c78e27feddf64d912c5741bc8685876786a37c4137ff2c280e2ec4198dc5b1a7e06c9f6709eb603857bdf70f4767d03c3200a8eb9f25868f6b41729d8d7ac243d0c3d0756402cb83f26890af2a521ca01ae32f1a410f6a4c2793e9c8cd6a6e506148bff7254f84d2af9e7aa8a50979a5d2a2a031bc8388d367a658feb87e39d15ea104209d777e9bddc22196fb0209e7609189d36f7b29bce3ca7adc94f2ab5197b71d563162768cc7c83c15d588b1632a9e4a8c593555379b8a05270254ed53bfcff76773be2affc40e48436232da43ba84314ce616869a89908b9264ddf39d9a957fede8d6ab4afcb2bd3cfcd0a71a6a12cf6f22695ff9c19c3286f047e9aaf3f1d639f6e1dbf7599579edf42ecb68e7a3f91d002fb461a97eb5441ef4e0ecbdd4bd9c3b6c2813995fabebe09f5b8f747ebbe7e8cd0a335fadb23f63c18df1aee286656c6766febd6c647d150c7974b868aa06fb72e3106db8a431a2800e36a35b5c383ae6ac01352d132356780dd49496bda62d6937eba8188b12c392e5d62e7faf6898a3e0f3c2791783bce31d8d3ab2009e7a28d741870b4f6f7361a5f41157bf8fa129ee4aa50d4ca34937fd30282d1c0d2e16c2a6d0da3cd49f2584b3c9fb585382f52773f1351d8648203c7537e74bc6e511887606449f5d00b0722d7f8f2d59b87b448ea42a460f5a9e59e7514f2ced1d099e0053e2dd9d2bdb6f17f5faed89d8cf9e7f623a4be45a381fd743f354c2e60f738cc8d41ac4ebe455b2abc6c4ffac1253a7938a45afdfd83c16a73b0ad613433e6f3e789f12b7244bf5bf52dc430957d34dade61b6ff90b62b2e96d7bf37e7d09f02f0fe11a0a1b7e70a83d09e70429b3dfc6e9cc7fb0bd78f6b86fb62126bcbc8d536cd9e7f8e9c63779ba9aa44e8abb9709ca4ca0895588731cf29c8f05ac423a75b9c1d42b80bd4c4adf62875db4cf9a1b7209d981236c24a922c3d9cf01d9200d82e4e5a446b5433a7c7eac95c05569e4362f6a0cf3bd0d4eef95ea6f98f2edaa318336b1510ea975c70f6607ccab21042f6a1da5cc420ca8d841acf09485725fcd2d0c2b9f1555370b8b88bf749eff5a5953878f560f9f7844d3840726aa1273de1b88fc85f92d923f34d67014f1ab7cbc97376a1164ec74f64408a05987d11c8d055869e832950fa891aadfef04483f244c51585cd04c777ade5c4723bdc7e2045ac45a9cbb94f5741f251ab7c63fb4b41f495c2d633bd8ad41530d365d1b8304ec01b897ad8032436bd09a857193213fbcb895bc39d760862e2ac3622f3de076186e89da79a65a6b800a83b9ec66bb42b9ec8a0622d27ea91729ec2d171975958de7613dd789df21b89e47e5192ec206ba66498d12b000541493913c0eecc4737af4d81679a39ad70565f071097fe8e02d2fc6cc2e7b0f09e8d4656e2ed473074b121093dc36274ecf4208727d376fe5887768ee7f783b99dc4b9a5ad2d78385f539515eb5c7cb514b989c19effd95c0dd436bcad50bb024d32b77f3f52e917e92cfc11b39faa6949d68c9f07777e93d9aead9e9c074d427d36e899e98b2bbf3ef13207a7cd18873304587eacab33a7eba06098eaf23c63d8b556403e2cef6e48fe21e6601459971ed5122a5b6ad2e79b5cd0458f6b0e55a3cfccf52958afc870495ae39559c1c6545ab5812dcfd65ce9001f104a10a7012bc59e347f9678a362a03b50f3e5e5f69195ee62723b93d9635a9901e7a1a7d13f817be7d99497fa67c4b1b64ce058963a6c76d8de4cc5df637c6fb69c99cceaf42dfcaced3bbffd1ef0f430af2f0123f7579ccd075b00b9242a1caf89e9ddff8615e8f4abdffd1d3dde95e67f0e7ef501fb572e70666ed58cad08b581e2da24e5246695d657e6d089a3f13c099ef86a3e86dada796b1ae6b534d01c5e8cca8434becb021f59a3ed212739acafbb0f1ccf8f78c608027165f3417b8be89f21af35c7bfac12065b484a651deae44679a79a7e70c09a6a54a64e0b6f6d4a23be17d303fc9e88b6e8031c8fcf4d905612cdd6b6f753c228e3946e464de716968db4512a7ce0f652ae69ceb41bf779f4ebe7af7f3585d3fc27913604bb03bdf8c15310765eb85386beff40164b3b4a221262ebf8382f402353aa0c79485f948c78cf9076543617f7f2d8d23b271388672101c640f333dc375dc2e7b584bf696473d124ab5595ce0cb4734220591424ff1a893a9b06ac78c489f13c35afb4320360a6b9115ea91510e1312864f80c6dd4a3f17ec533c9919e986bd8b8dc46862a08a6b9822d0809b08636516ae45377af4cc778710d6c780a73a92e0db9710e701acf9e147f5fdff0ac5203d10011a7e55673c0bd5cffe592844a9d56fa4462ff8364a469166f5d99f80901d92318ab2b63bd24964a094ae6bee99cee061c160c323184da152d44c2796a67bed2e4df48c8fa12a5f60716dd59637f2df55e46683158ca340c1359ddeed849fa772d8154f75f7c72855b580fcd9f67af108835ef2de01cdfdc9ed49cc4d314f24f538fb5291629044e8a77e6c92b4f76dde10d3598269b7b3d69d22df11fe6be70320df2aa1f11723e2e384e09ab03b8bb2a3dfc5fcf062d6d6833b42d98fd42bf78ab5bce71da236e4bdda282aa2cff6f609e1bf1f6f0dd62b1713d11719a4524e2a89267164e571345899d8a99e07eb704381ba3af6b2bdc6aec32243852a96f68080e95154e98db1510826bbc256815af41a5b983fea7a8bfb150bfa20f2c143046206bb3abeb68712e34d4b7717c84926c6f770e044b2bf18529d226ac2695ed34487b1638a1aa847dfbb1776c78ff115b668078e84185568bdd4649068786b18a1e8f190687caafc069daa8b6d3c98d2727bc2771ed9e14482410bd9a838d82d829f15355c0405df8fc73f4c390c40481eb4f1b2a2e8fb7d524bc5c85c3f2b0472ce1689fb97a2641f6e7808dbf0654f25d09d4456270879ac8a6a50ec469474fe84845e76989e4e9eee42c69f353c47de7dcedfa8e1b1a3d7f1cc0ca1a56c79421c72c820929252b6c19e24da0b4e8d72fdae0f272d7fcdd4c53f9e2be45eb2678c31a519a29ecddcfe4c4fecc42dc493f9474848e00ba1b33c9d9e36381a5df09050277ac0f8894271d9b90a0bcbb8a0021198ee7b71ee96307cce3a19a931226b038aaf1ed172ec4290d85a7c23f46b33263a5f65314c6cb0737697173bd55014ba2b228db5a4cd1438a5571739e9f8896a5a5ddcf25625d6b3e50c7b15cb898e100c6f13c84c7842b44cc6a8a2f465faec7bf419b00313a15373601bf22a8a89a808019f898f158825df206b7d865c8ace6c527707b30f8d8862987216b04644bed9db1086466dced137515eb28c77a45ee933732bdf66e34b6ad0c8849f0c8ef6126dea5af4bedd84063bc5deb057dbb59502ccb050b5c0ea50c0b27afbcb7aa5f5e92bfea02f5fce5962596df985cb0d9eade86da5ef92f2d322a77aee001f28930569f8179c42ad8d1602d969c2d7cbf6c57fd5bb6f2471285b88157b7c00d4290b26cb66858175c0ea00b53a48b7232df6b6d11a254dea43b99948a25668878356798e7c61a3357a6a7e0fa493023860025a2b4f6e31b105031c51cdf697433fd7fc7f4677e52511b10cf5bf6cf48343f69b8150ca53f5843b7a558bb8525652dba13127f78b5a6e4e752245dc34fde7e96465d9a73388d7045188927eab0ca2925fe4c5b4c12c2644a7db69177797966afaf27900d4af96e0b10a4c92bf15625ed362d705121627764e1d91592af66424475d8960b3ac86cc336cc227c6223639f1ea73fab950c48f5d851178bc9edd197d7765403d0accdba3aa61c01dd6db521bfcdfcaf2d905b13e7ba719745538df457c078718f846d5eac3da7cdf9f2dc296346a8b58b9e7dffa9ea5ccce6027659fb51958a2a5a551ee4985c401ebecae4798f69509072b64c811cc086f509481c1a802892743e2cb61b97c236d9e8410c244dcf4c8fa5ae6979db9e7c6d746694f9d3b54f6c3310c3b0e178bbcc95c58c060e0736c3ae943694aa8a3b74752813d6bb217516cdcbe749224496badc167ed24bf3757f0e1940792f84052d3f071bd1b032d5ec8200cc5cdd154fccc0749a447ee2826a2fdb4502efe739701273322ca5cc3fc7e2758ad073c7c6b2faf015ffe608ced7c0c66c6143cf1dae55ba581f3ddfe51c4ae383c0524cca94b7311e4648b934460900cb2723a415f91cb085da4009bdaa99d5f88980e3b7e8bd1d189269da6da54c28282541b3b39883b60611be8cb7a4c9d52c6683470856b187fb5e8b5ec6316654755e033bc0cc08745d48255f7d0717bc6176e3cd4af2316b18950ea6a4679b28ee48c298a2451b344c2e70d508fc73a9d93476cf725e20e98c91c6d9aee943974b6f5b4871cb5b5bd04cef12d9107c21792f59ff916631a72d98b0d845bd098de8f56133577e6798203f9266482223490344b712cc7f23d2e775f139efc4b139a50eea6e3764bd2b02e10d542b3125bcfe7a9b05fd7375ac5f588d8ac564ab0ee4f13eb6c2409a70481d914c839528e54edce9c351599f45fea59f13c39109a0cc7acfa86370eaa02b74fb9a6928352ec83f2ee71a9c534e4fc4b949468bd2a844b20ad0962b34c88ee0dc346cd75251bea1371e7d3575828830cf810496c4d3f569de783cd6eeaafac5149c4b7267a4409de873ea2cafbbd759435dd722cdb6dc54e030018b4dcccedaf3ff905a3741223a6ffd5ed88e1691a381486323f5ecd83442a22fae8453bdd2a16a6c94e8488534c8ac60d98559f7516b8305cdd6900abdd45871b4b3724b290f86845fc847a48bb65c53165106914728b54d7ea30b42356783df0b2a25245fe759bcfa49b5f4f30147353173ca5b1334c69cd6a5d921d00f118614af294c506ddda7aec9cc973d89e4697128ef35df7546db767cdc320229a400e38c63c38f0742c4e6895e418d2ef75507fba5451eed8bc71777db18edfeb3ed955753c1a6337490fdd35f55c052fabfe636982d81b243e5b8f3eeef2790190c37c0fef4e58fbdffec0f35131d1119ab969bc032498f1a30c1e3b3885e1e529f6000c24f36d81980af6b043438dfaf3cdb7adf06fc45d9a9c3c60003966555bc8107235cc2fcaa91276eab4093491ca4dc2a25f879842b624b89700e06d632094de40351c5a3096db37621b8cd66cf9ba4bf1a275806cde9d5fe782b2f8571c64ba70f08c2df91d7f6ee5ca481531ae85d57edc82d9952e2c77dff08d369d754b5da1d58acb7dd8fdf506d53425e1f8e49f7ac4a1a0d0d00d49b8ea624efd445633b774995c0144514b3d4e0b846a11a6a4a43c0899859c6f8dc30adc1bcfbef1c76ff20f93041e78761d6e252747482c4cc55976a2a9e9f43de22d2fa866aa02105d277ab9b091215615283545c0f87f6f590e719ac49b3fd789d6a61fb99a34648e6ab4adbe8729a4353eb8258419c9e6e0ce9f9d89282eab8b4804786e8baa19a8f283063772dc8e75fab376d9f82e2fc1e7c622d50ee72c986968ac7aea9c56017f075bfff6ffa2a93897c458a1b57b8d98a7062cb466367adbad491e7dddf00dc9b82a0bcecf4f0445d3e7b765bc2211f763f7f67c2e1102d3edbd1d3fc98b5c16acc1b1112c033577a9a806c150b46c80e7ef33a26bb694d04669dc741dac9913230570e01ccbbad052ac8cdb368f7266bb4049cd8c3826dfa12912ce3e21fdafe0992b6944a1d152f09a95e0aff8339afb0206344803956ffb66de48abf65ae6fe2fb94fc5daddaf1559bc891ab06de52a264ddb3dc1bdf148449fd013404c44a65e71d5a93bed500e0544f9ed1234ce860f626641ffc208122502ae611b23f54e09827bdc2d4050585cb675fb52b03e8e788ac781f6cc53d9ddc0f61416be6f4004a25be7fb9a96b92875426abf9dc588708f9f0214870f645a98b8bb7c965f3ea7895e109628b5c58ca92bf95d7e8cd910dc8fc5a46c8a73fbe5bee9aa84b2489039539646e1989c7ffc63c8c1ab16eb105f98821344ae85812eb09d2835ed13e37632006bd7ee3698b4209fd790ae08652465fe7927f129f18988df424532bdf243ebd021ae13c0cc348f6f0430204650f954224569738363ae6c8a4def7bcf17b5814c8f34b095a9fa36dae913ecb92bd072a1f1463105a81ead4395f9f694ba4250619bad74878bc5049ff810ea21e96f7b6b721bdf9ba61a69121bfd0e14610b1c6912afca0dc0dbb7926a786e49b072d88929f865a5d05ceda698e9513cdfc79c58814224697bc26dfb73a8f771e66a6b797aeb67d473313ed8705bda10b81ef683aecaae2d895369c395d020588828505a5747990540d54345debebaf2476519f8f5919c0f42e131b0a636f79c7b46d131904f5d835229f4305115cf4ad6831ed87286b14a4d8560f8d4e5df7e6408dfd7af5ea4b3704e0631088fef14cb8881aaeec5abcfa330060aa1d2b769e8c32548bf1e88f8e1738249d65e5348c5fd039ba81a16f06af1336d2112ebae9b2dc66a8fe894b5bc6c8d4bb36f4d4ef35c4729cf189b3fab3fb81777dfbd645787971158f20f9af267fc0428237aeaee514af5af6dd211b130118520e158bd6acaad2cf097c7b9e2fd61b1ce4b8d9c94db01f96791e2ec359f59272f72aea82fe1048645938639895ae6392996a1ad23c73de9a9613cafc6718ea8ca9d9d4a76d9e322bcea89322ff275ada09cf9f6d1932147319aa8d859b63eabca984508268edf662a3580c9858aa86678522a0aaf8921d6567000892678603d47f888b88443c3cb5581b928f75959bd27e3875b5796bfffeadc934bae0740a24b58fe656cd9b7d6b2fb7ff36f4c6ce04fe6de7169b2252e5eabfbf036a8b194e74720b8a4a677a151f82465f81acf9752892519ddd1cef0d9cc7359f9ac962ed37351c9abca7b107b76a888493b0170f5e2ed061056fa2bc9d39ef43fa4a474ad3b70de5c68c2dc67b49526b3b0ae1ea470c8b696e13599938f909d8e9b1ab4f9ba3a7e6ccc26d9cfe243630243f34582d053c01906c9405ae86919876edae3a9cbf0f28bb9a8af92a554c1f26e4dfa48386d0566b39d2c4d8d6c528ef3206f21d2d231ae87177c5ceb59e39873bdb70887779c9fbac5406e4e73c7e23f67892045e2d16e0655ec8917b280604ec74f679627320e6f17fb58e1ec62314141e0c0c57570fe689511942f141f29f1cc6f11d94d75ff3cf0177e3ff5030b97d9a8432de314c448186dd408e262c8f4513a841b879990289fa26c64662e97a2638b5977afdc14258dc696aca05b5fd911d602aff48fff0f375332a6b543303adce8cc034ff382483b60080ddcc01d7241cc471392447dc2767523c6ff828fbea81008215256fc6b774ef18db585574b1f92c1571deac7f739856bdd8c5e5862fd20986c9929034b71746a0756ccca38aeab9f87cc6b9920e760b18b99835337040f44cb1ecb619c3b2d531610cb804099b10cc71391f0dfb7d4c97b605636227d3d060d24c1ca489353d1e1c51364333fd9acfaa14f7eac7af141fc8a151c088bb5c19d190d0c3b48a04cddc9ebce27096ef3d68c719efb1638a561dadaf1db4151c4ab17cbc9fcc08cf4757250599209e26d228cd4c06dd82c49ffd56715255878eaa74f7eca96637dd10e363fbc2f029d31d964ad2c7ff8e16e95a4209a8900ae7cd8c036ff304696e4a72181ff166f004c6b21325e5c78b8f64139abc24c9e734bc9e9357ec3bd94cfd3c60aa95a4c690a182d96abd0218a78b6860c927c15bdd7bc649dc2cc2ee5d630807381a636ad9fe90db7358a5e0bfbb877760eb94ff88b981521727eca0562bdf2b6a02bb3cda7be5dcbebf79c14b7e9856655515b1422352b87f62b739dbfb8dbbfeda09811311980998b061793bf756ffa2856ecb26b17e4a3248f203079e3d1468b2be678d08dbfbba5924f28571251f5092328a2698cd0116a31cb386cf455713158342d229650c03cd4b6c52405ae12b93dc1211fd13f253815656fb0f3d562ab29233d0fd43a4bccca6d6052cef650905549341cdb6e2ed6ae2857adff1ca45dddc62532eaa1f4b48b2daf4f39f29e0d8a5198a57ceb4222795530e879c8263542b8562766a510010c8bbd17ab8951255b9d269665e40b287a9e578eb882bfa397abce9a3ca985ed5c9a687fc258ab90b591c62f5b7cecbdff54d44f1886dc1bcc1c1efd7daa3af24f995fed1f91331ec1b53581b10da788d9fbb0bf1e34c1a427754eeb370036ab156d39a1688812da5569c00f87d55142791c8770c4f8410c4d1b5cde0b61885a2bd7ba1f7ea4f28079b9f090c93539200d97b564a6a753d8c58b5930fd3f321ae7e4191eb34fbf4bbccac42d2d560108534776411df3c53813c26077c8572c75c2826e7403e1a4ba45d48228b39354f73efa2662a11c8e4e4b9895af3956cd33f9f34282ca8e42648b2753fade19d29b0aa3d1506ff844bbf1fbac0149cccace9ac6797cf287920a5a40e3666eccb903befb2e75f6dcb22d65f6a5d6ff10a450dc9600b755c61d4a0c8e1f5b1a4d8546406e2ee3b3678abefd589ea65863c21f62dcafb797150cc5da5d9da0efcadb257e6882f25b6044dc918baeb426af00e62d471f408fb96e83391d305c55a8b9fe9779e7bca73c6c00a146b88cce7d06a6cc723fc1f4caf67929341539595fddf306b28ce28a4a491d395b13ce7b5e88196de98acd1355a0c9953ce59c9db553618539890a345865a219a2ab32c05f79644dde14ba2a5f4c1db2b2a405e987a4266cdaef72ed555cc5edb860944f76626a2b5aa9b1166c4890021413c6ea0ed65aa35c24d2cbe26c13e44a6770591c172a7c022ae658f812b2f433982351da8559af295cba6dbb64fd7da3d02346f5b08f09aab8953cfdfdf23eb436473663e32f9c8fad79e7d6c2bbe1441c6a7ff15b0ef044b5bb15666f17942780425a65c2dee685260a3c6874391c624bd4a41be19566a1daf824a07ac36f94e5f06e580d072ba0a37808210f3afe7952af13ebb6253351f499f2c1dcd54aa72fb4b52e364e70b8920260c846871e23e1168e7691190a8ac577bb4efac11753649180011b80b3762a3c363053fc05929e1b8c38b90ccef8025dfa7eac5a100a6a0af2b7636491d773df46c6d33d0b823deb7bad441bd12db82236b7f27cd8f9398a482c40342d5f6a7742fcdbe8969e907b44584dcd17923b3d29b18104a43da6e37c7ae42d93b9400db57def072b25ed3cef909b40db380a9f9636e02bea553016f6f0033130af10f4b9fddf5250afbe7b950717afb24fd6e6923e133b955ce8358e6d6c8652db7fb464ddb6d9cbff62107398e7e8253f639d1684dd108fe7983076e53d24ff54887fc74c37ee891eca72939e9357133dcf82ce182f97655fe0d4dec1da6f2d3b6a47eeb3cdf4fe10f191de16e45b3d44376c3ae77194b2ad7e8e2ef54c6e0277da64293a4508d09ddbead1e3ce9fe07a7011eca08ae1e3cad29e945990cf27874e41778da628f14cb0e59fb7f0a82b2cd85510dea02616ef6cbf6edc14db9f3c1e58a471712df454d9a270f3196449480b00c5d44ccec1222b26fde28053ed2dda20fee142a37d85dbcf0b9f3694bc956cedc4c1da18c76e5eab7ae8097e9b36e2d2968913bcb2d06d58179b52c036c485e1e98474dd225ddd6ef4348fae1f9d31a1a75f1bd8dcdc17f38c9d28711385121091094e8112de9325f9ff438c2ce6a97f656560c3c41d139b21459a3475e2f56051c3f1b6029e186257db0a631248da0686e8162a7e7e96748c16e5adbff2eb2584fc8063e560adc6d4bc569a33f4e23d1597b2490ccd3761c81edb924b2f5b13f4b7cf72feb0aee296ec1340a6d6661c55b07ccf94ae44daf5116cdc50d9059bd1a45d8b32b62942fb3d692ebd76dc7e93e1810141b8ba2270c5fb2ce6ab4c58d22907c82a43e2c000fa3cb86a0296a4365ea04805d4760006c2de03fa6d643e34f42f20a32861b77015e43eccca06aa5b51d3e13d2527a39f4b5549aaf889d09c370def29c25a9082f3457fe86b04873038ae052eb067265c32f604717334541a2a163b365f2df4e656ce50b8da80c40f01126734daebf8a873439bfa4cfbcdf403b7029e311183186acbd2663114c42392106f58264ee6e60932fd483ae8416e8ee4a643722cd5910bf04b3a6a35a405beee21beddffc24bb1134e98016edca2b94595b756085e055e34a4d744a2c4743ba8d247a7347e16663743adb0c0194e738048cf53e6fada09f544401b178fdff73e15fa1b52bf0c93a18573e2e1565a668c0b3c1e56b2d7eb3b7b2668caabdc22e287af47152997bf44278dbb9edcb1fda21832120570bc8a2b9715dad4acbf8835dc874dcd45e512c3dd981434b5fa4b59beaacdea395e4afdb2af773bd8d44b8da80374a02ba6d8d10c9f7a6c5da49d30a7099468de350da61dcc0dd36a24e3dfcd795132e2502ed232eb76f698fb6c5049207512c467b6b6f2678329084474bf6129ce503a7a2bf8fc029473f7dd11176f9c95b8af28d3329af6c094b89e9daf4bb0ec3a4cda798d359471391fe36b5d7ab75ed00f30313b4768ad2a826556ed2b3f1404ad00733e8f2d5b3e3ed28c05d20e1e9c6c9306d26816e78e0fe0a637a20293b3645eb822f3a104c77448eff2b8f2f0b9f03601030ae2e372368e4fe99e744b23fbc0778bfbba30ef7ea9fad613af3c0dde86ee8be4cc26db085e35d3477c194399432ef693708dd00677c75ef2ea9aa38b107ec28c490c3b8b6786bdca217cc5daa6302b6d0d8d1ae58a4cc9f1b969f54f70c30babecea24927072a9b480bc1db3c3821679cd8105e046f58eb895a8f12f5a160e7b4bc9f1070f8ca8c648c8b06cdfd370c604530b95f47e8c0fa7c1d3a779f5217131677c8b8d00f31fb707ab39d05bc2a20bdfc6b7d8b0e0b3e12e9fdadeff8a21c8f3b83379ff2d0c4b228e469043c555343f00f2bba5b66ef9cefc290d6ef614fe848dc7f94198efda5cec40d3c342520a78ecfdbc1d0c1e56c4ff6e301174dbc4f34a695c96b4fef79fcd359a67394df616d94d45187b7516d6302c5a79a10043056b63b8516310169185aa4a3a66e37808a5f200ecf7062d4a1525e5c099242864061a983183a74c81111c7d337b8a5e7c6b8a39d0a0b687f00cf982ced2a73a6c2fccb2dfb3b962dae76985c341d419d4d612da9fcb8e5c51035bac16eaae9b199433f340505845698ad45c3030236b69e19e6c55ed4b636b70d37fca3e5c027a8060c863350d4144e8f7e06225c3c852aea5425b3b84a4314742f73d9652d5188c081c5c2ad809c1d5fbf446511837f2aff756d62404db658767f2a5200f3688cbebafec88e4cf734f92b7717f4123e714c1c75297fcb70f16fd20d520ed6069195caf7a7699411191672e435d4d7a41baf8085e057f982ea648d96f58b8b44957c25a95923311c43e6fa02093b2fbf1b84d72bff28826fbbe67501865c15e1bef9fdb1dd30b871e9d561272b8d8bd9c72a01f5aeb59517ac9c77a77b7c014d599e6fbefdc5c5b82b62c481b60820b681291e1d68a75aa4b4c3e53f41718be1793359b294687d93d53a7ba64db42dbde21dd97c073990a6b0f18fdf2fc6c2cdc837f2ba27cfde1b010641ed3b67a7222a685414228ebe85f0f7a5aefd69d2088aa79cc367baace855cd73e59d8032ca6fbbab535bc6ed57588ce98b665e5dbb042814edd3f63afe9755669fd79172ee2db232bae131fbc3893c04f74c3de72a310be85091960ba2f2036fc517ccbc414d52222faae76dd9e1849aa853338f041d37d7f6400f84a3891dd882d756380d0074e743bfe6c286f3e76eb6fc6fb24e44fa2655a16526965597ebb35737015341e04d19894daf18aa986bfacbd0b4d2dde53cedd6d25e492efb1a0b4ceb74edac5a0e1d19de1fec26729ab0af695c98ba567d916eb0b6f1da50aa1cd9bd55fcae8524dd24ea5d879c9b016a9577639af6c4ea11ea7e479a81d2c94df6a95a478fbf94056a219f3de2bd124cdade8230c5b9dbb493c6f8dd42fa511ac7b964075b1a048b4ab1eafd4c5dca4d800bcf9fd305d79b1155fffef5d5b8dc791d4d87810b6c77de381239b4b9f214061c857ce39ba4048ad8ff9fe836e1aee623db8952d2acb4266e3dc9e9b050ded9f263a6796340ca7a7c9d014c83612e18c1a054071dd521c85258e9ed8e28e49a806685c5f61ba706472fbe3d3caf666c05cc63767da5656309c3d088c06e224d12ef0db0d644a579310c71bf43fe47a14d738aa0ddfe114719e003b979a81478a572ad5b1b24dafd151cd4de57c36a7aa64d0600aca616be67abb3ed4d1bc90f31dc975481f13a7f1e9387878c1b3478a8ba48a5fa0440d78bcc0bb2299c0b2bceedf2156e7615f01c346c70f77fbbeb66abcf12d1e25c4c45ebbc50ab562c3c73c649f2e3eaf55827dd0529ea03a82ccd52a6c2608182a7502bcd7e965ec071aa6ee762478e2efd0bb6585411b4fcdbb82783132e3b73ef7837fddf29e991c249cd2f068a537937b85a82c36e8b75b1680583805edae37e5d42ac3757a25e96f99b202e8efa4237eb67af3fc6d2af4a3218811f810bef6cc23f968c58d3f9411e3e0ebe83d552bc9833a2a56e488ca03d063ced187afc5375e7f939fd28c691907dbfe9b4afcaa2f04a8595eef77300976efa31e3c70fbecf394ddaf06ffd75aa683aff5fbfaa2fa6678a523ba3ba061f21e141ad89b754f16f2f72620896a3b966ec8b64d60056b1931dbf9c0eb7a98694407920a25746e54e6ede16369a72b95885784a0f8a85de2b24c56ec972cbbd64e4a6bd1a99b41bd557eb18be67eb6f608df40e4e8f975c1130f000bb150f1c79b08a5743d0b8ea18ce427eaf16cb761eadea7d8ea07229c8e7532f4e14f9f66a83ebd8c635463e25658d8954e372369b6d1b380e4cbb5967efe23baaa0e5d51bab00170e41b61b76f133bb9d771590dadf260dd944cb56abbf8593dc73d5d18a7437a92b75fcede0006a539067c7c317fe3b1bee92d85d3bbfe939699ed6965508af01e085c0ea0ecf593c4a5ffd4409b4db89ab498e3</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>图形学笔记</title>
    <link href="/2025/06/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
    <url>/2025/06/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1id="计算机图形学期末预习复习">计算机图形学期末<del>预习</del>复习</h1><!-- > 复习资料已上传至[njubox](https://box.nju.edu.cn/d/7bbbcbb2bef8413c9f5b/). > 这是一份由lhj和fjz共同整理的计算机图形学复习文档.## 样卷分析2021——2022年样卷围绕各个算法展开，涉及直线中点画线算法、直线裁剪算法、多边形扫描转换方法、旋转变换矩阵以及Hermite形式的参数三次多项式曲线.--><h2 id="线画图元生成算法">线画图元生成算法</h2><h3 id="画线算法">画线算法</h3><p>画线，即将线段数字化为一组离散整数位置的过程。场景中的直线段通常由其两<strong>端点</strong>的坐标位置来定义，通过特定算法计算得到中间各点的位置并将颜色值存放到帧缓存的相应坐标位置，待视频控制器从帧缓存读出写入的颜色值并绘制于屏幕。</p><h4 id="dda算法">DDA算法</h4><p>从一个端点出发，以 <span class="math inline">\(\delta_x\)</span>（或<spanclass="math inline">\(\delta_y\)</span>）为步长，逐个计算各点坐标，对于<span class="math inline">\(y=mx+b\)</span>:</p><ul><li><span class="math inline">\(|m|&lt;1\)</span>: 以单位 <spanclass="math inline">\(x\)</span> 间隔取样.若从左端点出发，设置 <spanclass="math inline">\(\delta_x=1\)</span> ，则 <spanclass="math inline">\(y_{k+1}=y_k+m\)</span> ;若从右端点出发，设置 <spanclass="math inline">\(\delta_x=-1\)</span> ,则 <spanclass="math inline">\(y_{k+1}=y_k-m\)</span>.</li><li><span class="math inline">\(|m|&gt;1\)</span>: 以单位 <spanclass="math inline">\(y\)</span> 间隔取样.若从下端点出发，设置 <spanclass="math inline">\(\delta_y=1\)</span>，则 <spanclass="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>;若从上端点出发，设置 <spanclass="math inline">\(\delta_y=-1\)</span>,则 <spanclass="math inline">\(x_{k+1}=x_k-\frac{1}{m}\)</span>.</li></ul><h4 id="bresenham画线算法">Bresenham画线算法</h4><p>通俗来讲，Bresenham画线算法每次生成两个可能的像素位置，并从中选择一个更接近线路径的，相较于DDA中大量的浮点数运算，Bresenham算法使用整数增量，win！</p><p>以正斜率小于1的直线扫描转换过程为例，我们来思考Bresenham算法做了什么.假如在第k步我们已经确定了要显示的像素在<span class="math inline">\((x_k,y_k)\)</span> ，那么 <spanclass="math inline">\(y_{k+1} \in \{y_k,y_k+1\}\)</span> .我们需要衡量<span class="math inline">\(y_k,y_k+1\)</span>谁距离目标直线更近，于是我们计算 <spanclass="math inline">\(d_l,d_u\)</span>, 考虑到在 <spanclass="math inline">\(x_k+1\)</span> 处直线上 <spanclass="math inline">\(y\)</span> 坐标实为 <spanclass="math display">\[y=m(x_k+1)+b\]</span> , 那么我们有 <spanclass="math display">\[d_l=y-y_k=m(x_k+1)+b-y_k\]</span> 以及 <spanclass="math display">\[d_u=y_k+1-m(x_k+1)-b\]</span>,只需作差并判断正负我们就可知哪个像素点距离目标直线更近了：<spanclass="math display">\[d_l-d_u=2m(x_k+1)-2y_k+2b-1\]</span>. 又由于<span class="math inline">\(m=\frac{\Delta y}{\Delta x}\in(0,1)\)</span> ，我们希望避免浮点数运算，将上式乘上 <spanclass="math inline">\(\Delta x\)</span> ,于是我们就发明了决策变量：<span class="math display">\[p_k=\Deltax(d_l-d_u)=2\Delta y x_k -2 \Delta x y_k +c \]</span> ，其中 <spanclass="math inline">\(c=2\Delta y+(2b-1)\Delta x\)</span>. 同样的，在第<span class="math inline">\(k+1\)</span> 步，我们也有 <spanclass="math display">\[p_{k+1} = 2\Delta y x_{k+1} -2 \Delta x y_{k+1}+c \]</span>, 作差得 <span class="math display">\[p_{k+1}-p_k = 2\Deltay (x_{k+1}-x_k) -2 \Delta x (y_{k+1}-y_k) = 2\Delta y -2 \Delta x(y_{k+1}-y_k) \]</span>. 当 <spanclass="math inline">\(p_k&gt;0\)</span>,我们有 <spanclass="math inline">\(d_l&gt;d_u\)</span>, <spanclass="math inline">\(y_{k+1}=y_k+1\)</span> ， 有 <spanclass="math display">\[p_{k+1}-p_k = 2\Delta y -2 \Delta x \]</span>,否则有 <span class="math display">\[p_{k+1}-p_k = 2\Delta y\]</span> .直接计算 <span class="math display">\[p_0=\Delta x (d_l-d_u)=2\Deltay-\Delta x\]</span>. 至此我们发明了Bresenham画线算法!</p><blockquote><p><span class="math inline">\(0&lt;m&lt;1\)</span> 时的 Bresenham画线算法：</p><ol type="1"><li>输入线段的两个端点，并将左端点存储在 <spanclass="math inline">\((x_0, y_0)\)</span> 中；</li><li>将 <span class="math inline">\((x_0, y_0)\)</span>装入帧缓存，画出第一个点；</li><li>计算常量 <span class="math inline">\(\Delta x, \Delta y, 2\Deltay\)</span> 和$ 2y - 2x$，并得到决策参数的第一个值: <spanclass="math display">\[p_0 = 2\Delta y - \Delta x \]</span></li><li>从 <span class="math inline">\(k=0\)</span> 开始，在沿线路径的每个<span class="math inline">\(x_k\)</span> 处，进行下列检测：</li></ol><ul><li>如果 <span class="math inline">\(p_k &lt;0\)</span>，下一个要绘制的点是 <span class="math inline">\((x_k+1,y_k)\)</span>，并且 <span class="math display">\[p_{k+1} = p_k + 2\Deltay \]</span></li><li>否则，下一个要绘制的点是 <span class="math inline">\((x_k+1,y_k+1)\)</span>，并且<span class="math display">\[p_{k+1} = p_k +2\Delta y - 2\Delta x \]</span></li></ul><ol start="5" type="1"><li>重复步骤 4，共 <span class="math inline">\(\Delta x-1\)</span>次。</li></ol></blockquote><p>下面我们考虑一般的Bresenham画线算法.注意到xy平面各种八分和四分区域间的对称性:</p><figure><img src="/image/cg/bresenham_line.png"alt="各区域的Bresenham画线算法" /><figcaption aria-hidden="true">各区域的Bresenham画线算法</figcaption></figure><ul><li>斜率绝对值决定取样方向.<ul><li>大于1：<span class="math inline">\(y\)</span> 轴方向取样.</li><li>小于1：<span class="math inline">\(x\)</span> 轴方向取样.</li></ul></li><li>起始端点决定直线生成方向（也即相应坐标值增量的正负）.<ul><li>生成方向与坐标轴相同则增量为坐标值增量为正.</li><li>否则为反.</li></ul></li></ul><h3 id="圆生成算法">圆生成算法</h3><p>下面我们延续Bresenham画线算法的思想，尝试画圆.</p><p>如同画线算法，我们在每一步中以<strong>单位间隔</strong>取样,从两候选像素中找出距离目标圆更近的一个.对于圆心在<span class="math inline">\((x_c,y_c)\)</span> 半径为 <spanclass="math inline">\(r\)</span> 的圆来说，我们可以使用算法计算圆心在<span class="math inline">\((0,0)\)</span> 且半径同为 <spanclass="math inline">\(r\)</span>的圆的像素坐标，再经过简单的平移变换得到目标圆的像素坐标.因此，方便起见，算法只考虑圆心位于原点的圆.考虑到圆的对称性，我们只需要考虑第一象限中从<span class="math inline">\(x=0\)</span> 到 <spanclass="math inline">\(x=y\)</span> 的圆弧段（八分圆），在正 <spanclass="math inline">\(x\)</span>方向取单位步长，其他七个根据对称性求得.</p><p>首先定义圆函数 <span class="math display">\[f_c(x,y) = x^2+y^2-r^2\]</span>, 则任何点 <span class="math inline">\((x,y)\)</span>和圆的位置关系都可根据 <span class="math inline">\(f_c(x,y)\)</span>大于、小于或等于0来判断.下面定义决策参数 <spanclass="math display">\[p_k=f_c(x_k+1 , y_k - \frac{1}{2} )=(x_k+1)^2+(y_k-\frac{1}{2})^2-r^2\]</span>.</p><figure><img src="/image/cg/circ1.png"alt="沿圆路径取样位置xk+1上候选像素间的中点" /><figcaptionaria-hidden="true">沿圆路径取样位置xk+1上候选像素间的中点</figcaption></figure><p>如图所示，若 <span class="math inline">\(p_k&lt;0\)</span>则中点位于圆内，显然扫描线 <span class="math inline">\(y_k\)</span>上的像素更接近与目标圆，我们没理由不选择它；否则我们将选择位于 <spanclass="math inline">\(y_k-1\)</span> 的像素点.</p><p>惊喜的是，依靠增量运算，我们并不需要每次都进行讨厌的平方运算，考虑<spanclass="math display">\[p_{k+1}=f_c(x_{k+1}+1,y_{k+1}-\frac{1}{2})\]</span>，与<span class="math inline">\(p_k\)</span> 作差得 <spanclass="math display">\[p_{k+1}-p_k=2(x_k+1)+(y_{k+1}^2-y_k^2)-(y_{k+1}-y_k)+1\]</span>.</p><p>当 <span class="math inline">\(p_k&lt;0\)</span>，我们有 <spanclass="math inline">\(y_{k+1}=y_k\)</span> , <spanclass="math display">\[p_{k+1}-p_k = 2(x_k +1)+1=2x_{k+1}+1\]</span>; 当<span class="math inline">\(p_k&gt;0\)</span>，我们有 <spanclass="math inline">\(y_{k+1}=y_k-1\)</span>, <spanclass="math display">\[p_{k+1}-p_k =2x_{k+1}+1 - 2y_k -2=2x_{k+1}+1 -2y_{k+1} \]</span>, 而 <span class="math inline">\(2x_{k+1}\)</span> 和<span class="math inline">\(2y_{k+1}\)</span>的求值也可以通过增量的方式得到 <spanclass="math display">\[2x_{k+1}=2x_k+2,2y_{k+1}=2y_k-2\]</span>.对圆函数在起始位置<span class="math inline">\((x_0,y_0)=(0,r)\)</span>求值，就得到了初始决策参数 <spanclass="math display">\[p_0=f_c(1,r-\frac{1}{2}) =\frac{5}{4} -r\]</span> .</p><p>至此，我们发明了中点圆算法！</p><blockquote><p>中点圆算法： 1. 输入圆的半径 $ r $ 和圆心 <spanclass="math inline">\((x_c,y_c)\)</span>，并得到圆周（圆心在原点）上的第一个点：<br /><span class="math display">\[  (x_0, y_0) = (0, r)  \]</span></p><ol start="2" type="1"><li><p>计算决策参数的初始值：<br /><span class="math display">\[  p_0 = \frac{5}{4} - r  \]</span></p></li><li><p>从 $ k = 0 $ 开始，在每个 $ x_k $ 位置进行以下检测：<br /></p></li></ol><ul><li>如果 $ p_k &lt; 0 $，则下一个点为 <spanclass="math inline">\((x_{k+1}, y_k)\)</span>，并更新决策参数：<br /><span class="math display">\[p_{k+1} = p_k + 2x_{k+1} + 1\]</span><br /></li><li>否则，下一个点为 <span class="math inline">\((x_{k+1}, y_k -1)\)</span>，并更新决策参数：<br /><span class="math display">\[p_{k+1} = p_k + 2x_{k+1} + 1 - 2y_{k+1}\]</span><br />其中，$ 2x_{k+1} = 2x_k + 2 $ 且 $ 2y_{k+1} = 2y_k - 2 $。</li></ul><ol start="4" type="1"><li><p>确定在其他七个八分圆中的对称点。</p></li><li><p>将每个计算出的像素位置 <span class="math inline">\((x,y)\)</span> 平移到圆心 <span class="math inline">\((x_c, y_c)\)</span>的圆路径上：<br />$ x = x + x_c, y = y + y_c $</p></li><li><p>重复步骤 3 到步骤 5，直到 $ x y $。</p></li></ol></blockquote><h3 id="椭圆生成算法">椭圆生成算法</h3><p>还是依靠Bresenham算法的思想，我们现在开始尝试画椭圆.</p><p>类似中点圆算法，给定参数 <span class="math inline">\(r_x,r_y\)</span>和 <span class="math inline">\((x_c,y_c)\)</span>，首先确定以原点为中心的标准椭圆上的点 <spanclass="math inline">\((x,y)\)</span> ， 然后将这些点平移到以 <spanclass="math inline">\((x_c,y_c)\)</span> 为中心的椭圆上.如果希望显示不在标准位置的椭圆，只需要饶中心坐标旋转并对长轴和短轴重新定向.</p><p>考虑到椭圆的对称性，我们只需要在第一象限确定各像素点的位置.具体的，中心椭圆算法将以斜率为-1为界限，分成两部分应用于第一象限，如下图所示.在斜率绝对值小于1的区域在 <span class="math inline">\(x\)</span>方向取单位步长，在斜率绝对值大于1的区域在 <spanclass="math inline">\(y\)</span> 方向取单位步长来处理这个象限.</p><figure><img src="/image/cg/ellipse1.png" alt="椭圆处理的区域" /><figcaption aria-hidden="true">椭圆处理的区域</figcaption></figure><p>定义椭圆函数 <spanclass="math display">\[f_e(x,y)=r_y^2x^2+r_x^2y^2-r_x^2r_y^2\]</span> ,我们令椭圆函数作为中点算法的决策参数，帮我们在两候选像素位置之间做决定.</p><p>具体的，从 <span class="math inline">\((0,r_y)\)</span> 开始，在<span class="math inline">\(x\)</span>方向上取单位步长直到区域1和区域2的分界处，然后转换成 <spanclass="math inline">\(y\)</span>方向的单位步长，从而覆盖第一象限中的剩余曲线段.为了判定我们在哪个区域，每一步都需要检测曲线的（切线）斜率值，椭圆的斜率可由曲线方程求导得到<span class="math display">\[\frac{dy}{dx}=-\frac{2r_y^2x}{2r_x^2y}\]</span> ， 而交界区域位置有 <spanclass="math inline">\(dy/dx=-1\)</span> ,从而有<spanclass="math display">\[2r_y^2x=2r_x^2y\]</span> ,也即当 <spanclass="math inline">\(2r_y^2x \geq 2r_x^2y\)</span>的时候，移出区域1进入区域2.</p><p>考虑区域1，如下图所示. 我们有 <spanclass="math display">\[p1_k=f_e(x_k+1,y_k-\frac{1}{2})=r_y^2(x_k+1)^2+r_x^2(y_k-\frac{1}{2})^2-r_x^2r_y^2\]</span>.当 <span class="math inline">\(p_1k&lt;0\)</span> 中点位于椭圆内，选择<span class="math inline">\(y_k\)</span> 上的像素更接近椭圆，否则选择<span class="math inline">\(y_k-1\)</span> 上的像素.</p><figure><img src="/image/cg/ellipse2.png"alt="椭圆轨迹上取样位置xk+1处候选像素中点" /><figcaptionaria-hidden="true">椭圆轨迹上取样位置xk+1处候选像素中点</figcaption></figure><p>计算下一取样位置的决策参数，<span class="math display">\[p1_{k+1}=f_e(x_{k+1}+1,y_{k+1}-\frac{1}{2})=r_y^2[(x_k+1)+1]^2+r_x^2(y_{k+1}-\frac{1}{2})^2-r_x^2r_y^2\]</span> 从而 <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2(x_k+1)+r_y^2+r_x^2[(y_{k+1}-\frac{1}{2})^2-(y_k-\frac{1}{2})^2]\]</span>.</p><p>当 <span class="math inline">\(p1_k&lt;0\)</span> , <spanclass="math inline">\(y_{k+1}=y_k\)</span> , 有 <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2x_{k+1}+r_y^2\]</span> .当<span class="math inline">\(p1_k \geq 0\)</span> ， <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2x_{k+1}+r_y^2-2r_x^2y_{k+1}\]</span>.</p><p>事实上，计算增量只需要我们进行加减运算，这是因为 <spanclass="math inline">\(2r_y^2x\)</span> 和 <spanclass="math inline">\(2r_x^2y\)</span> 的值也可以通过增量得到.</p><p>在起始位置处，我们有 <spanclass="math display">\[2r_yx^2=0,2r_x^2y=2r_x^2r_y\]</span>， 决策参数<spanclass="math display">\[p1_0=r_y^2-r_x^2r_y+\frac{1}{4}r_x^2\]</span>.</p><p>对于区域二的分析和区域一类似，不同的是<strong>取样方向</strong>.</p><blockquote><p>中点椭圆绘制算法</p><ol type="1"><li><strong>输入参数</strong>：输入 <spanclass="math inline">\(r_x\)</span>、<spanclass="math inline">\(r_y\)</span> 和 <span class="math inline">\((x_c,y_c)\)</span>，得到中心在原点的椭圆的第一个点：</li></ol><p><span class="math display">\[  (x_0, y_0) = (0, r_y)  \]</span></p><ol start="2" type="1"><li><strong>区域1决策参数初值</strong>：</li></ol><p><span class="math display">\[  p1_0 = r_y^2 - r_x^2 r_y + \frac{1}{4} r_x^2  \]</span></p><ol start="3" type="1"><li><strong>区域1每个 <span class="math inline">\(x_k\)</span>位置处，<span class="math inline">\(k = 0\)</span>开始循环测试</strong>：</li></ol><ul><li><p>若 <span class="math inline">\(p1_k &lt;0\)</span>，选择像素：<span class="math inline">\((x_k+1, y_k)\)</span>且：</p><p><span class="math display">\[p1_{k+1} = p1_k + 2r_y^2 x_k + r_y^2\]</span></p></li><li><p>若 <span class="math inline">\(p1_k &gt;0\)</span>，选择像素：<span class="math inline">\((x_k+1,y_k-1)\)</span> 且：</p><p><span class="math display">\[p1_{k+1} = p1_k + 2r_y^2 x_k + 2r_y^2 - 2r_x^2 y_k + r_y^2\]</span></p></li><li><p>其中：</p><p><span class="math display">\[2r_y^2 x_{k+1} = 2r_y^2 x_k + 2r_y^2  \]</span></p><p><span class="math display">\[2r_x^2 y_{k+1} = 2r_x^2 y_k - 2r_x^2\]</span></p></li><li><p><strong>循环终止条件</strong>：<span class="math inline">\(2r_y^2x \geq 2r_x^2 y\)</span></p></li></ul><ol start="4" type="1"><li><strong>区域1最后点 <span class="math inline">\((x_l, y_l)\)</span>计算区域2参数初值</strong>：</li></ol><p><span class="math display">\[  p2_0 = r_y^2 (x_l + 1/2)^2 + r_x^2 (y_l - 1)^2 - r_x^2 r_y^2  \]</span></p><ol start="5" type="1"><li><strong>区域2每个 <span class="math inline">\(y_k\)</span>位置处，<span class="math inline">\(k = 0\)</span>开始循环测试</strong>：</li></ol><ul><li><p>若 <span class="math inline">\(p2_k &gt;0\)</span>，选择像素：<span class="math inline">\((x_k, y_k -1)\)</span> 且：</p><p><span class="math display">\[p2_{k+1} = p2_k - 2r_x^2 y_k + r_x^2\]</span></p></li><li><p>否则，选择像素：<span class="math inline">\((x_k + 1, y_k -1)\)</span> 且：</p><p><span class="math display">\[p2_{k+1} = p2_k + 2r_y^2 x_k + 2r_y^2 - 2r_x^2 y_k + r_x^2\]</span></p></li><li><p>与区域1相同的 x 和 y 增量计算。</p></li><li><p><strong>循环终止条件</strong>：至 <span class="math inline">\(r_y= 0\)</span></p></li></ul><ol start="6" type="1"><li><p><strong>对称</strong>：确定其它三个像素对称点。</p></li><li><p><strong>平移</strong>：将每个像素位置 <spanclass="math inline">\((x, y)\)</span> 平移到中心在 <spanclass="math inline">\((x_c, y_c)\)</span>的椭圆轨迹上，并按坐标值画点：</p></li></ol><p><span class="math display">\[  x = x + x_c, \quad y = y + y_c  \]</span></p></blockquote><h3 id="线画图元生成小结">线画图元生成小结</h3><figure><img src="/image/cg/summary1.png" alt="线画图元生成小结" /><figcaption aria-hidden="true">线画图元生成小结</figcaption></figure><h2 id="填充图元生成算法">填充图元生成算法</h2><p>除点、直线段和曲线外，另一种描述图形组成部分的有用结构是使用某种颜色或图案进行填充的区域.</p><p>填充图元的表示方式分为顶点表示和点阵表示.顶点表示用多边形的顶点坐标来描述图形.例如，一个三角形可以通过三个顶点的坐标来定义.而点阵表示用位于多边形内部的像素集合来描述图形，即实际显示的图像.</p><blockquote><p>ds: 填充的核心任务是将多边形的顶点表示转换为点阵表示.</p></blockquote><p>填充图元（区域）可以根据填充内容分为以下三种基本模式：</p><ol type="1"><li>颜色边界的空心区域<ul><li>特点：仅显示区域的边界轮廓（如多边形边线），内部保持与背景色一致（不填充）。</li><li>应用：适用于需要突出形状轮廓的场景，如线框模型、示意图。</li></ul></li><li>实颜色填充的实心区域<ul><li>特点：用单一颜色填充区域内部，边界可以包含在内（边界与内部同色）或单独指定颜色。</li><li>应用：常见于纯色图形（如按钮、色块）。</li></ul></li><li>指定图案或设计图形填充的图案区域<ul><li>特点：用自定义图案（如纹理、渐变、图像）填充区域内部。</li><li>应用：适用于需要复杂视觉效果的对象（如游戏贴图、艺术设计）。</li></ul></li></ol><blockquote><p><strong>实颜色</strong>（SolidColor）是指用单一、均匀的颜色值填充一个区域，没有任何渐变、纹理或透明度变化。它是与“图案填充”或“渐变填充”相对的概念。</p></blockquote><h3 id="扫描转换填充算法">扫描转换填充算法</h3><p>输入多边形顶点信息，以扫描线与多边形边界的交点为界限，求出内部各个像素，输出多边形点阵表示.</p><figure><img src="/image/cg/scantrans.png" alt="处理扫描线" /><figcaption aria-hidden="true">处理扫描线</figcaption></figure><p>依次处理每条扫描线，计算其与多边形边的交点，将交点沿扫描线按横坐标值升序排列，自左到右对交点配对，并对交点坐标取整处理，给每对交点间扫描线区段的像素点设置填充颜色，核心问题是<strong>扫描线与多边形边界求交</strong>以及<strong>边界及交点的存储管理</strong>.</p><h4 id="扫描线与区域边界求交">扫描线与区域边界求交</h4><p><strong>直线的连贯性</strong>是指直线穿越两条相邻扫描线时斜率不变.我们将利用连贯性来进行交点的增量计算.</p><p>考虑边界 <span class="math inline">\(y=mx+b\)</span>. 扫描线间 <spanclass="math inline">\(y\)</span> 坐标变化为 <spanclass="math inline">\(y_{k+1}-y_k\)</span> ， 则当前扫描线和边界交点的值<span class="math inline">\(x_{k+1}\)</span>可由前一条扫描线上和边界的交点值来计算,即 <spanclass="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>.</p><p>可是这还不够，<span class="math inline">\(\frac{1}{m}\)</span>是浮点数，我们讨厌浮点数运算，我们希望增量计算是整数计算.</p><p>于是我们将斜率 <span class="math inline">\(m\)</span> 转化成两整数比<span class="math inline">\(\frac{\Delta y}{\Deltax}\)</span>，则我们可以把增量 <span class="math inline">\(1/m\)</span>的计算变成整数运算.</p><p>一种方法是<strong>直接舍入取整</strong>，我们维护一个计数器 <spanclass="math inline">\(k\)</span>，初始化计数器为0，对于每条新的扫描线，计数器增加<span class="math inline">\(\Delta x\)</span> , 若 <spanclass="math inline">\(k\geq \Delta y\)</span>, 交点 <spanclass="math inline">\(x\)</span> 值增加1，<spanclass="math inline">\(k-=\Delta y\)</span>.</p><p><strong>例子：</strong> 假设有一条边从(1,1)到(6,4)： - Δx = 5 (6-1) -Δy = 3 (4-1) - 初始交点x=1</p><table><thead><tr><th>扫描线y</th><th>计数器操作</th><th>计数器值</th><th>是否产生新交点</th><th>交点x</th></tr></thead><tbody><tr><td>1</td><td>初始</td><td>0</td><td>否</td><td>1</td></tr><tr><td>2</td><td>+5</td><td>5</td><td>5≥3: 是</td><td>2</td></tr><tr><td></td><td>-3</td><td>2</td><td></td><td></td></tr><tr><td>3</td><td>+5</td><td>7</td><td>7≥3: 是</td><td>3</td></tr><tr><td></td><td>-3</td><td>4</td><td>4≥3: 是</td><td>4</td></tr><tr><td></td><td>-3</td><td>1</td><td></td><td></td></tr><tr><td>4</td><td>+5</td><td>6</td><td>6≥3: 是</td><td>5</td></tr><tr><td></td><td>-3</td><td>3</td><td>3≥3: 是</td><td>6</td></tr><tr><td></td><td>-3</td><td>0</td><td></td><td></td></tr></tbody></table><p>另一种方法是<strong>细化取整法</strong>，依旧维护一个计数器 <spanclass="math inline">\(k\)</span>，将其初始化为0，对于每条扫描线，计数器增加 <spanclass="math inline">\(2\Delta x\)</span> ，若 <spanclass="math inline">\(k\geq \Delta y\)</span> ,令交点 <spanclass="math inline">\(x\)</span> 值加一，<spanclass="math inline">\(k-=2\Delta y\)</span>.</p><p><strong>例子：</strong> 同样以(1,1)到(6,4)为例：</p><table><thead><tr><th>扫描线y</th><th>计数器操作</th><th>计数器值</th><th>是否产生新交点</th><th>交点x</th></tr></thead><tbody><tr><td>1</td><td>初始</td><td>0</td><td>否</td><td>1</td></tr><tr><td>2</td><td>+10</td><td>10</td><td>10≥3: 是</td><td>2</td></tr><tr><td></td><td>-6</td><td>4</td><td>4≥3: 是</td><td>3</td></tr><tr><td></td><td>-6</td><td>-2</td><td></td><td></td></tr><tr><td>3</td><td>+10</td><td>8</td><td>8≥3: 是</td><td>4</td></tr><tr><td></td><td>-6</td><td>2</td><td>2≥3: 否</td><td></td></tr><tr><td>4</td><td>+10</td><td>12</td><td>12≥3: 是</td><td>5</td></tr><tr><td></td><td>-6</td><td>6</td><td>6≥3: 是</td><td>6</td></tr><tr><td></td><td>-6</td><td>0</td><td></td><td></td></tr></tbody></table><h4 id="区域边界顶点的求交处理">区域边界顶点的求交处理</h4><p>如下图所示，扫描线 <span class="math inline">\(y1\)</span>穿过一个顶点(共享顶点的两条边位于扫描线的同侧)，它与偶数条边相交，沿扫描线<span class="math inline">\(y1\)</span>的相交点正确地分辨出了内部像素分布；扫描线y穿过一个顶点(顶点的两条相交边位于扫描线的异侧)，与五条多边形边相交.因此，必须要作一些额外的处理才能确定正确的内部点（偶数次变换才正确）.</p><figure><img src="/image/cg/jiaodian.png" alt="区域边界顶点的求交处理" /><figcaption aria-hidden="true">区域边界顶点的求交处理</figcaption></figure><p>一个方法是计算相关边与扫描线的相对位置或拓扑关系.我们顺（逆）时针跟踪多边形边界，观察从一条边经顶点移到另一条边时端点<span class="math inline">\(y\)</span> 坐标的变化. + 若 <spanclass="math inline">\(y\)</span>坐标单调增加或减小，穿过该顶点的扫描线与多边形边界的交点数计为1 +否则，交点数计为2</p><p>另一个方法是将特殊顶点分离处理.如下图所示，我们缩短多边形某些边，以分离应计为1个交点的顶点.具体的，以顺（逆）时针方向处理整个多边形边界上的非水平边。在处理每条边时检测<strong>该边与下一条非水平边是否有单调递增或单调递减的端点y值</strong>.假如有，可将较低一条边缩短，以保证对通过连接两条边公共顶点的扫描线仅有一个交点生成：+ 当两条边的端点 <span class="math inline">\(y\)</span>值增加时，<strong>当前边</strong>较高端点 <spanclass="math inline">\(y\)</span> 值减去1. + 当端点 <spanclass="math inline">\(y\)</span>值单调递减时，<strong>紧随边</strong>较高端点的 <spanclass="math inline">\(y\)</span> 值减去1 .</p><figure><img src="/image/cg/fenli.png" alt="特殊顶点分离处理" /><figcaption aria-hidden="true">特殊顶点分离处理</figcaption></figure><h4 id="数据结构">数据结构</h4><p>我们使用<strong>有序边表</strong>和<strong>活化边表</strong>两个数据结构.</p><p>如下图所示，有序边表是按边下端点 <spanclass="math inline">\(y\)</span>坐标对非水平边进行分类的指针数族，旨在排除一些不必要的求交测试.对每条边按最小 <span class="math inline">\(y\)</span>值排序，存储在一个相应编号的扫描线位置（Y桶）,对某条特定扫描线，以从左到右的次序对边排序.在处理边时，可以缩短某些边以解决共享顶点问题.表中每个节点包括该边最大y值，下端点x值以及边斜率的倒数.</p><figure><img src="/image/cg/youxu.png" alt="有序边表" /><figcaption aria-hidden="true">有序边表</figcaption></figure><p>而活化边表由与当前扫描线相交的多边形边组成，它记录多边形<strong>边沿扫描线的交点序列</strong>.对于第 <span class="math inline">\(k\)</span>条扫描线，活化边表可从有序边表中生成： + 将Y桶中对应于当前扫描线以下的类<span class="math inline">\(c (c=1,2,…,k-1)\)</span>的所有边插入活化边表，删除满足 <spanclass="math inline">\(y_{max}&lt;y_k\)</span> 的边，其它边的x域根据<span class="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>确定交点.活化边表中的每个节点包含该边最大 <spanclass="math inline">\(y\)</span> 值、与扫描线交点的 <spanclass="math inline">\(x\)</span> 坐标值和边斜率倒数.</p><blockquote><p>ppt上写的是“其它边的x域根据 <spanclass="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>确定交点”我感觉不太对...如果有问题请向我反馈.</p></blockquote><h3 id="区域填充算法">区域填充算法</h3><p>区域填充从区域的一个内点（称为“种子点”）开始，赋予指定的颜色，然后将该颜色扩展到整个区域，是对区域重新着色的过程（改变区域的颜色或者以图像填充），对内点表示的区域进行填充为泛滥填充，而对边界表示的区域进行填充为边界填充.</p><p>区域填充算法要求区域是连通的.这个要求是自然的，因为只有在连通区域内，才有可能将种子点的颜色扩展到区域内的其它点.</p><p>区域连通性可分为4连通、8连通和16连通.</p><p>一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的4连通区域或4-邻域 <span class="math inline">\(N_4(p)\)</span>定义为(下图中标 <span class="math inline">\(r\)</span> 的像素)： <spanclass="math display">\[N4(p)={r|d_4(p,r)=1} \]</span>,即任取区域内两点，在该区域内，通过上、下、左右四个方向的运动，这两点相互可达。区域内像素距离定义为曼哈顿距离<span class="math display">\[d_4(p,r)=|x_p-x_r|+|y_p-y_r|\]</span>.</p><figure><img src="/image/cg/n4.png" alt="4-邻域" /><figcaption aria-hidden="true">4-邻域</figcaption></figure><p>一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的8连通区域或8-邻域 <span class="math inline">\(N_8(p)\)</span>定义为(图中标 <span class="math inline">\(r\)</span> 的像素)：<spanclass="math display">\[N_8(p)={r|d_8(p,r)=1}\]</span>,即任取区域内两点，通过水平、垂直、两个对角线八个方向的运动，这两点相互可达。区域内像素距离定义为棋盘距离<span class="math display">\[d8(p,r)=max(|xp-xr|, |yp-yr|)\]</span>.</p><figure><img src="/image/cg/n8.png" alt="8-邻域" /><figcaption aria-hidden="true">8-邻域</figcaption></figure><p>显然，一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的8-邻域 <span class="math inline">\(N_8(p)\)</span> 是它的4-邻域 <spanclass="math inline">\(N_4(p)\)</span> 和它的对角邻域 <spanclass="math inline">\(N_D(p)\)</span> 的并集.</p><p>一个像素 <span class="math inline">\(p(x_p,y_p)\)</span>的16连通区域或16-邻域 <span class="math inline">\(N_{16}(p)\)</span>定义为 <span class="math display">\[N_{16}(p)= N_8(p)\cup N_k(p)\]</span> 即任取区域内两点，通过十六个方向的运动相互可达.其中，马步(或骑士Knight)邻域 <span class="math inline">\(N_k(p)\)</span>定义为 <span class="math display">\[N_k(p)={r|d_k(p,r)=1}\]</span>.马步距离是国际象棋棋盘上马从一格运动到另一格所需步数计算，也是网格上两点间最短k-通路的长度.</p><figure><img src="/image/cg/n16.png" alt="16-邻域" /><figcaption aria-hidden="true">16-邻域</figcaption></figure><p>一个4连通区域也可以看作是8连通区域，但它作为4连通区域和8连通区域的边界是不同的(4连通比8连通约束紧).</p><ul><li>8连通区域中，由于区域内的两个像素可以通过对角线相通，因此区域边界上的像素不能通过对角线相连，否则填充会溢出到区域外（欠约束）.所以8连通区域的边界必须是4连通.</li><li>4连通区域，其边界像素为4连通或8连通都可以.</li><li>8连通区域能用来填充更复杂的图形.</li></ul><p>考虑了连通性，我们来思考内外点测试.</p><p>区域填充必须从一个内点开始，因此需要区分区域的内点和外点.简单多边形的内点是容易区分的，但复杂多边形较困难.关于内外点测试我们有<strong>奇偶规则</strong>和<strong>非零环绕数规则</strong>.对于标准多边形和其它简单形状，非零环绕数规则和奇偶规则给出相同的结果.但对于复杂形状，两种方法会产生不同的内部和外部区域,非零环绕数规则比奇偶规则更通用.</p><p>奇偶规则又称射线法，做法是从位置p到对象坐标范围以外远距离画一射线（不与顶点相交），并统计沿该射线与区域各边的交点数目：</p><ul><li>假如与这条射线相交的多边形边数为奇数，则p是内部点；</li><li>否则，p是外部点.</li></ul><p>环绕数是指多边形边以逆时针方向环绕某一特定点的次数，而二维物体的内部点具有环绕数为非零值.</p><p>非零环绕数规则:</p><ul><li>将环绕数初始化为零，再假想从任意位置P画一射线(不与多边形任何顶点相交)</li><li>当从P点沿射线方向移动时，对在每个方向上穿过射线的边计数：<ul><li>当多边形从右到左穿过射线时，环绕数加1</li><li>当多边形从左到右穿过射线时，环绕数减1</li><li>所有穿过的边都计数后的环绕数值决定P的相对位置</li></ul></li></ul><p>那我们怎么计算环绕数呢？</p><p>叉乘法：将从 <span class="math inline">\(P\)</span> 点出发的射线向量<span class="math inline">\(u\)</span> 与穿过射线的每条边的边向量 <spanclass="math inline">\(e\)</span> 叉乘</p><ul><li>假如对某一特定边，积 <span class="math inline">\(u×e\)</span> 的元素<span class="math inline">\(z\)</span>为正，那么，该边从右到左穿过射线，环绕数加1</li><li>否则，该边从左到右穿越射线，环绕数减1</li></ul><p>点积法：建立一个垂直于 <span class="math inline">\(u\)</span> 且从<span class="math inline">\(P\)</span> 沿 <spanclass="math inline">\(u\)</span> 方向看是从右到左指向的向量.</p><ul><li>假如垂直向量与边向量的点积 <span class="math inline">\(v •e\)</span> 为正，那么，该边从右向左穿越射线，环绕数加1</li><li>否则，该边从左至右穿越射线，环绕数则减1</li></ul><p><strong>递归边界填充</strong>：从区域种子点开始，根据内部像素连通性检测相邻位置与边界颜色不同的像素，用填充颜色涂色；递归扩展到整个区域，直到检测完区域边界内的所有像素.</p><p><strong>扫描边界填充</strong>：通过沿扫描线填充水平像素段来代替处理4连通或8-连通相邻点.从种子点开始，首先填该像素所在扫描行的连续像素段,然后将相邻扫描线上（上下扫描线）各段的起始/末尾位置进栈，这些水平段分别被用区域边界颜色显示的像素包围.从栈顶逐步取出开始点/末点(先进后出)，填充该水平段像素并重复上述过程.</p><p><strong>泛滥填充</strong>：区域内部用单一颜色定义的区域填充. +递归填充：种子点开始，按像素颜色及连通性，递归检测和扩展区域内部像素，将填充颜色赋给这些像素，直到所有内部点均着色.+ 扫描转换填充：从每个水平区间的第一个位置开始，按扫描线逐步将区域内扫描线上像素颜色替换为填充颜色，直到所有内部点均被着色.</p><h3 id="扫描转换vs区域填充">扫描转换vs区域填充</h3><figure><img src="/image/cg/scanvstc.png" alt="扫描转换对比区域填充" /><figcaption aria-hidden="true">扫描转换对比区域填充</figcaption></figure><h3 id="图像填充算法">图像填充算法</h3><p>填充图元有两大类方式：</p><ul><li>均匀着色区域<ul><li>扫描填充图元</li><li>区域填充图元</li></ul></li><li>图形填充区域<ul><li>位图不透明方式</li><li>位图透明方式</li><li>像素图填充方式</li></ul></li></ul><p>图像填充区域与均匀着色区域的差异在于：每个像素的颜色如何确定.</p><ul><li>均匀着色区域：像素的颜色由用户指定.</li><li>图像填充区域：像素的颜色从图像种获得.<ul><li>区域内某像素：首先查询它对应位图或像素图中的像素单元，再根据填充方式以合适的像素颜色值显示该像素单元.</li></ul></li></ul><p>我们将图像分为<strong>位图</strong>和<strong>像素图</strong>两大类.位图是只有0/1两种值的二值图像，有两种填充方式：透明方式和不透明方式.<strong>透明方式</strong>只覆盖1对应的像素（前景色），0对应的像素保持原样.<strong>不透明方式</strong>1用前景色，0用背景色，全部覆盖.而像素图是多值图像（如RGB彩色图像），只有不透明方式,也即直接使用图像本身的颜色值覆盖. 但是我们可以用像素图模拟位图行为：</p><ul><li>可以按位图的两种方式来解释像素图：<ul><li>不透明方式：把像素值视为0/1，1-&gt;前景色，0-&gt;背景色</li><li>透明方式：把像素值视为0/1，1-&gt;前景色，0-&gt;保持原样</li></ul></li><li>或者直接按像素图本身的颜色值显示</li></ul><p>通常来说，用来填充区域的图像较小，不足以填充整个区域，于是我们有了铺瓦式填充.我们使图像在水平和垂直方向上周期性排列，直到所定义的区域全被不重叠的图像所覆盖.</p><p>关于图像填充效果，ppt讲了两类，个人感觉还算清楚，此处直接放图.</p><figure><img src="/image/cg/xiaoguo.png" alt="填充效果" /><figcaption aria-hidden="true">填充效果</figcaption></figure><h2 id="基本几何变换">基本几何变换</h2><h3 id="二维几何变换">二维几何变换</h3><h4 id="平移与旋转">平移与旋转</h4><p>将物体沿直线路径从一个坐标位置到另一个坐标位置重定位，原始位置 <spanclass="math inline">\((x,y)\)</span> 加上平移距离 <spanclass="math inline">\(t_x,t_y\)</span> 即可得到一个新的坐标位置 <spanclass="math inline">\((x&#39;,y&#39;)\)</span>，有 <spanclass="math display">\[P&#39;=P+T\]</span>.</p><ul><li>直线段：平移两端点然后重画端点间线段.</li><li>多边形：平移各顶点坐标，生成新的多边形.</li><li>圆或椭圆：平移中心坐标并在新位置重画图形.</li><li>曲线：平移定义曲线的坐标位置，用新的坐标位置重构曲线.</li></ul><p>物体沿着 <span class="math inline">\(xy\)</span>平面内圆弧路径重定位，指定旋转基准点 <spanclass="math inline">\((x_r,y_r)\)</span> 和 旋转角 <spanclass="math inline">\(\theta\)</span> , 逆时针旋转为正,绕通过基准点且垂直于 <span class="math inline">\(xy\)</span>平面的旋转轴旋转.</p><p>首先考虑基准点为坐标原点时的转换方程，有 <spanclass="math inline">\(x&#39;=x cos\theta - y sin\theta,y&#39;=xsin\theta + ycos\theta\)</span>. 旋转矩阵为 <spanclass="math display">\[\begin{bmatrix}cos \theta &amp;-sin\theta\\sin \theta &amp; cos\theta\\\end{bmatrix}\]</span></p><p>而围绕任意基准点，有 <span class="math display">\[x&#39;=x_r+(x-x_r)cos\theta -(y-y_r)sin\theta\\y&#39;=y_r+(x-x_r)sin\theta +(y-y_r)cos\theta\]</span></p><p>依旧是刚体变换.</p><h4 id="缩放与错切">缩放与错切</h4><p>相对于原点的缩放：</p><p><span class="math display">\[x&#39;=x \cdot s_x, y&#39;=y\cdot s_y\]</span></p><p>也即</p><span class="math display">\[P&#39;= SP\]</span> ,其中$ S=<span class="math display">\[\begin{bmatrix}s_x&amp;0\\0&amp;s_y\end{bmatrix}\]</span><p>$.</p><p>相对于固定点 <span class="math inline">\((x_f,y_f)\)</span> 的缩放，<span class="math display">\[x&#39;-x_f = (x-x_f)s_x\\y&#39;-y_f = (y-y_f)s_y\]</span> 有 <span class="math display">\[x&#39; = xs_x+x_f(1-s_x)\\y&#39; = ys_y+y_f(1-s_y)\]</span>.</p><p>错切变换会使物体形状发生变化，错切过的物体由相对滑动的内部夹层组成.</p><figure><img src="/image/cg/cuoqie.png" alt="相对x方向的错切" /><figcaption aria-hidden="true">相对x方向的错切</figcaption></figure><p>相对于 <span class="math inline">\(x\)</span> 轴 <spanclass="math inline">\(x\)</span> 方向的错切: <spanclass="math display">\[x&#39;=x+sh_x \cdot y, y&#39;=y\]</span></p><p>相对于 <span class="math inline">\(y=y_{ref}\)</span> 轴 <spanclass="math inline">\(x\)</span> 方向的错切: <spanclass="math display">\[x&#39;=x+sh_x \cdot (y-y_{ref}), y&#39;=y\]</span></p><p>相对于 <span class="math inline">\(x=x_{ref}\)</span> 轴 <spanclass="math inline">\(u\)</span> 方向的错切: <spanclass="math display">\[x&#39;=x, y&#39;=y+sh_y \cdot (x-x_{ref})\]</span>.</p><h4 id="齐次坐标">齐次坐标</h4><p>用 <span class="math inline">\(n+1\)</span> 维表示 <spanclass="math inline">\(n\)</span> 维, 用 <spanclass="math inline">\((x_h,y_h,h)\)</span> 表示 <spanclass="math inline">\((x,y)\)</span> ,这能帮我们把所有的几何变换方程表示为矩阵乘法，通过左乘变换矩阵实现复合变换.</p><figure><img src="/image/cg/qici.png" alt="变换的齐次坐标表示" /><figcaption aria-hidden="true">变换的齐次坐标表示</figcaption></figure><h4 id="对称反射变换">对称/反射变换</h4><ul><li>关于 <span class="math inline">\(x\)</span> 轴 、 <spanclass="math inline">\(y\)</span> 轴 、 原点的反射.</li><li>ppt提了嘴关于 <span class="math inline">\(xy\)</span>平面任意直线，但没给出变换矩阵.</li></ul><h4 id="仿射变换">仿射变换</h4><p>二维仿射变换允许图形在两个方向上任意伸缩，但仍保持平直性和平行性.</p><p>变换公式 <span class="math display">\[x&#39;=a_{xx} x+a_{xy} y+b_x\\y&#39;=a_{yx}x+a_{yy}y+b_y\]</span>.</p><p>上述变换都是仿射变换的特例,任何常用的仿射变换都可表示成上述五种变换的组合.</p><h3 id="三维几何变换">三维几何变换</h3><h4 id="平移与缩放">平移与缩放</h4><p>在二维层次加上 <span class="math inline">\(z\)</span>坐标就很自然得到了三维变换.</p><figure><img src="/image/cg/3dts.png" alt="三维平移与缩放" /><figcaption aria-hidden="true">三维平移与缩放</figcaption></figure><h4 id="旋转">旋转</h4><p>旋转的扩展就没有那么简单了，这是因为二维旋转只需要考虑沿垂直于 <spanclass="math inline">\(xy\)</span>平面的旋转轴而三维空间中可选择空间任意方向作为旋转轴，大多数软件将三维旋转作为绕三个坐标轴的二维旋转的复合变换来处理.</p><p>绕 <span class="math inline">\(z\)</span> 轴旋转变换矩阵 <spanclass="math display">\[\begin{bmatrix}cos \theta &amp;-sin\theta&amp;0&amp;0\\sin \theta &amp;cos\theta&amp;0&amp;0\\0 &amp;0&amp;1&amp;0\\0 &amp;0&amp;0&amp;1\\\end{bmatrix}\]</span></p><p>绕 <span class="math inline">\(x\)</span> 轴旋转变换矩阵 <spanclass="math display">\[\begin{bmatrix}1 &amp;0&amp;0&amp;0\\0&amp;cos\theta&amp;-sin\theta&amp;0\\0 &amp;sin\theta&amp;cos \theta&amp;0\\0 &amp;0&amp;0&amp;1\\\end{bmatrix}\]</span></p><p>绕 <span class="math inline">\(y\)</span> 轴旋转变换矩阵 <spanclass="math display">\[\begin{bmatrix}cos \theta &amp;0&amp;sin\theta&amp;0\\0 &amp;1&amp;0&amp;0\\-sin\theta &amp;0&amp;cos \theta&amp;0\\0 &amp;0&amp;0&amp;1\\\end{bmatrix}\]</span></p><p>绕任意三维轴的变换矩阵通过复合变换得到 + 平移旋转轴至穿过坐标原点 +旋转轴绕某坐标轴旋转使其于另一坐标轴重合 +根据指定旋转角求出绕坐标轴的旋转矩阵 +将旋转轴变回原位置，得到逆矩阵序列.</p><figure><img src="/image/cg/any3dr.png" alt="绕任意三维轴旋转一般步骤" /><figcaption aria-hidden="true">绕任意三维轴旋转一般步骤</figcaption></figure><blockquote><p>计算机图形学（第三版）有详细介绍</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>remote-ssh-to-wsl</title>
    <link href="/2025/04/11/remote-ssh-to-wsl/"/>
    <url>/2025/04/11/remote-ssh-to-wsl/</url>
    
    <content type="html"><![CDATA[<blockquote><p>本文参考自知乎，原文链接为https://zhuanlan.zhihu.com/p/357038111.</p></blockquote><p>最近希望能通过VScode的Remote-SSH插件来远程访问位于寝室Windows主机上的WSL，但是考虑到处于校园网环境，Windows主机的IP地址是动态分发的且<del>一直开机并不现实</del>，因此可能每次使用远程访问时都要重复操作，为避免遗忘，遂记录于此.</p><ol type="1"><li>在WSL2下重装ssh</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get remove openssh-server<br>sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>编辑sshd_config文件，修改几处配置</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/ssh/sshd_config<br><br>+++ Port 22<br>+++ PermitRootLogin <span class="hljs-built_in">yes</span><br>+++ PasswordAuthentication <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编辑hosts.allow</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts.allow<br><br>+++ sshd: ALL<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>重启ssh服务</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo service ssh --full-restart<br><br>sudo systemctl <span class="hljs-built_in">enable</span> ssh <span class="hljs-comment">#设置开机自启</span><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>进行端口转发</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ifconfig <span class="hljs-comment">#在WSL，查看ip地址</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># in Win : 管理员cmd</span><br>netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=22 connectaddress=xxx.xxx.xxx.xxx connectport=22<br><br>netsh interface portproxy show all <span class="hljs-comment">#查看已设置的转发</span><br>netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=22 <span class="hljs-comment">#删除某一转发</span><br>netsh interface portproxy reset <span class="hljs-comment">#重置所有转发</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>cmd下查询Windows的内网IP地址</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ipconfig<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>通过Remote-SSH进行连接</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh root@xxx.xxx.xxx.xxx <span class="hljs-comment">#root可换成对应用户名</span><br></code></pre></td></tr></table></figure><blockquote><p>Windows防火墙设置默认会关闭22端口，需要开放防火墙设置：<code>Win+R</code>键入<code>control firewall.cpl</code>，新建入站规则即可.</p></blockquote>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Happy-Birthday!</title>
    <link href="/2025/04/04/Happy-Birthday/"/>
    <url>/2025/04/04/Happy-Birthday/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5d4e8e15c921a904d779959554b2a0dd66504dc711ed4ebe1801f68cac2e75ff">10d79030e8222445804370796b90fca1b3149e2c2a0f36d6b4ea04e548758c2111af2b8f18804544ae7edb4f8d5e33e48fc2a9e5d9e9f70e011ebca3a0dafa9769cd7daa121cdd45e0c91ba3361a09d36de5c6e0fb770a3ed9dd4c90afdc474230ef1020e3f05616cf54411d130d330d0a4ce5198ef3f64941d5c9594d0dc0a6122e77f4437062fb68ea3e7e79b2b82b9b48604a51b072c920e858bc130b529d5cb22b633e42c6ad6a697b6db93e9586058e36b1865c3d3280101deda27938cfc3ff9926d9d79cdc8a4f9144c8a06a72d6c84672c15d0832a35644787f1f8b9ee7c4ef6b4617227f33c68880d33652e2b9b118b97bde873f5554112119329d3f88a36ea527fe07c7f75d2c70ccefb3e288a05a8d5b234df5f5f0d2a9cda0660f3c0fe41ad418601cb0398b757ed0192b9231545d014692a6e872a64971e402f9deee6ace0e80ee062e884bd36370c13d7290527cc0416df2a64debc6eb01ac49e696d905a188a5f85e495d1c1c63cc1003a263b5c8f48636aa860bfbc14cad80794cf7be3eac3926ef77c5ff34d1db09a5c4c1a31026772936aeb5cc0b01802499103d5a73c60d9755c4ce9588bdb016f1c7a7ccdc0756d6cea85416691ad0b9fd355cc637ec21e6953928aecad5cd034deb0cd194df35af0569bb174ef50e69a10be1011f42a6b49b2bb0da289c783630cdcc9c0b918613e1fd939d7054e5a240ab9d1c55a27b72e030114ac122ac727df6377387fc56d40c93a65c5a6e31e27e9e83bcb7781de4a68b880fce78aa075ea4c2e3f2730eb23f00f828bf015e24a138249fbc153cad4cbc801682b1b508a6074bbd2a20df884d6d3d397d489d8103349f6857534038d63cf03b21e8742801da36bff61bc7db8f7555bbcd5c233bb635b32856025bc385a8db7683d1c3e178ae58447b78818562ac1c6830dc979841f242014ebee71eaabf499b4ff6a8eb0e22f1770a1ac0cc2d81081a10e5ea5ccb028e24161bd2bef71d7804588e4a94e4327b1afb98066c44a4f595068d2f7803038e0775df8593a07eaad1dd34e49eb98a1bb0376bde504709a6e51532ea20383567e16164fe55925936a279a88b1416d4a59accdccc9b11d151f81f9e308e8451113ac945f4aa509d05d582d9a7480b02d011307cf13abcbeffd333ceeedeffae655337e805e819eff7e00893a53a557104bdc77ad4edb1af7771f6468b624385ba5863eafc9f7eaff889b6af08aa237e54441fcbb40b63332e6f800d1f4d37d9a5ae97178386fe1ad920a30f47ce63ecdb01312dc37c834bea162f6e730f672ccf3fab55aa551a96c15de0d9c4707ef6b81d49e67e09973de7ec94ca608ab649a35037dc838d7b1ca9678b156d3c423ac2ed6806b66fd5ff428b15e3031e4a1025a8399e646af4d45ba72f8d16236dc06e6d353a811a1b9668b45be0c23d4383bf7013171d6fac360d276b20ab92539f1aeb074e45f040a5b96b927dea99f5b2111759b563c5aa55561b07351397221ff8ee1bdd36bfc4eb9961f11a49f0fcf8fcae9d53dec8d22fb804a80ebd1885ee3b65b1d2b458f43031ecd3d581fbbe7d361d2c993c9720784388ef669898dfc2dad805eb20f537276d4e963d1747bfcdefae7ed9ebc0633c02b43bfb7dc9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Win安装“动手学深度学习”</title>
    <link href="/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/"/>
    <url>/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/</url>
    
    <content type="html"><![CDATA[<p>课程网站上的<ahref="https://zh.d2l.ai/chapter_installation/index.html">安装说明</a>已经很friendly了，但是并未列出Windows下的安装教程，谨在此记录我是如何在Win11下进行安装的.</p><h2 id="安装配置-miniconda">安装配置 Miniconda</h2><p>根据自己使用的python版本，在<ahref="https://repo.anaconda.com/miniconda/">miniconda</a>官网中选择对应的版本即可，如笔者使用的是<code>python 3.9</code>，则选择了<code>Miniconda3-py39_24.11.1-0-Windows-x86_64.exe</code>来下载并双击安装.</p><ul><li>建议勾选 Register Miniconda3 as my default Python 3.9...</li><li>不要忘记设置环境变量</li></ul><p>详细安装教程可参见<ahref="https://www.bilibili.com/opus/509341163774622170">bilibili</a>.</p><h2 id="其余即可参照课程网站">其余即可参照课程网站</h2>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>生日快乐</title>
    <link href="/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
    <url>/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
    
    <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="eee754c680eee422755caa7629bf38031c9061637af1d9456d14c46fefceb82a">10d79030e8222445804370796b90fca1b3149e2c2a0f36d6b4ea04e548758c216c4f8b959fb5a2e4b286d076935415b6f0cdcf9e45f7294fc1e8b64cbc9380b3fe6487b2928a50342d05240db2caa35730dbb529bcc971a81652b3114321186ac79b1ecd9b95b4d8af574ecafaf902dd1cbca9697f1d3bb19746e3856145feeeb87114c2fe1d38a7856c22de22b34243a6d2c4f7ba1aca75e07b9da9838b071a16fd10387eb0db1d7778a621b36ea5c78bf0a7edba408b0a8d10d9f935292e294755990afd8f95b5c4cdc9b9993b21ac9fbf4ec994a8e762644a4eb4b6fca0342c855f1458eb8f9ffd947d55744c1a52044da75d3fcdb6716e661aa984a8f1d9234b5373cd1c347829812e01f0d0003b60610339d954448218226ec58ab9f0553a5a26ce57b9c40a5a0676355ce1157244924371f1623bee26ec46883ed60e139901d839cb35b3bbacac99bd0a32baaac5dfc8dd4c49e466b2d5b8cbaace0c0a36e0a0777bd98113acdf7af01737ea7f73f187a82cebf3ddbe544ff77749785399da7ffcfb65fbe1b2c2986ac0f0ba7dccadb0f871d3b0722f416e00ceb3709a64743fdc5ea6f76e018976de732b3e74adcf5f841e2e8e3594f9de30f57c9586b5a656b027904f3e1c8c4f0595f78c76b9d13a5d4aabcdf45ae62c0a06008ff1ca3deaef08b5236bdf64abb9fb07e8f09c2ab6f41fee57abc17e8664c7376bf8cd7ead7c606a699b496ebae5cd59c673318f29b2f595d363a967b94ea17ab72758d4de468858aa228c5dc1f5f95733d6d711b625b38d0f80eb9e58425ca8317614ba38197687af7f56b48296b289f04e816342073bdfb2393c8cc282c8d8ca9e2e9caae9e0ab604cf498313e4dc1b62ad28b42329117faec1bc3def578d6e20df8f5afaa2a5783af5aab5ce83f0194f732fe77f3f3b64105b9610e92e6013f65112c5ed58a2c7e36d738b7df75494c154a77c35b60d176b43cc8ac6eefccd55f033c6e167da696e86b42e4052f0522eb5b0827c8de001d1b38ceb7b8057b96037ad19d56a6c19ec04674312dae33efd9447846ec56cd7868dc5a93178979c22ee8708b3d72e08613e069408fa3f80922e297a9f5378239ca653132ee7edc6da005e3de65793f8c4983994eeffb89757434fb23ff747b3d5037598a7d310e1ac24f196bb4d84fb006f7ac67f39ce17709816c3fdac776ba5c4f30d942f2ff9e6390c4c0c381e47dcd0fe90726f1ba9e4f468abdc35d1f79aca9f47dd6ecdf8693727f8cddb3b3c95b139d693d84b561ffb1a1d163cf6e3ec35acad436a462322a938e24070375c44352aa0214dc61f2fac8df4f72de6983fe3d1d139275346e82732a16b7e93d514d3064c7ceea3070a03bbb7e70918245ad1d773896bdd17b4174de19bf5e4d4951501ec03dc083821a53c6d06e2631ed6e04c10d8b06cfb1f63799d868e4056d67459491c52b38092e5dfe8d436fa561efc75f139c2cf804c9a5293981ab297b8da1570fb2d961d392059861f6e941edf4688850eae78c1fd7c964d16ba51bfed11c0a7864fd9b92fa16246feeac091da290bf2223e6889a2b514d83124222b97481ea5ead8f93fbcc0675e9e93ffdcfa6c93ff761ac3df6ea504cd531313f1c1de75eea3018a15100</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CRYPTO</title>
    <link href="/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
    <url>/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
    
    <content type="html"><![CDATA[<h2 id="消息认证">消息认证</h2><ul><li>消息认证的必要性</li><li>MAC<ul><li>定义</li><li>正确性与安全性要求</li><li>使用</li></ul></li><li>构造 secure MACs<ul><li>定长</li><li>CBC-MAC处理长消息</li></ul></li><li>AE<ul><li>定义</li><li>CCA安全</li><li>不可伪造加密</li><li>构造AE</li></ul></li></ul><h3 id="消息认证的必要性">消息认证的必要性</h3><p>安全的对话要确定消息发送方的身份和以及消息未被串改，仅加密在很多时候并不能确保这些.</p><h3 id="mac">MAC</h3><p>给我们的消息打一个tag！</p><h4 id="定义">定义</h4><p>消息认证码，即 MAC 是一个 PPT 算法组成的三元组 <spanclass="math inline">\(\Pi=(Gen,Mac,Vrfy)\)</span>: + 密钥生成算法: <spanclass="math inline">\(k \leftarrow Gen(1^n) , |k| \geq n\)</span>. +标签生成算法：<span class="math inline">\(t \leftarrow Mac_k(m)\ or\ t:= Mac_k(m), m\in \{0,1\}^*\)</span>. + 确定性的认证算法：<spanclass="math inline">\(b := Vrfy_k(m,t) , b=1 \ iff.\ m\ is\valid\)</span>.</p><h4 id="正确性与安全性要求">正确性与安全性要求</h4><p><strong>正确性</strong>：正确生成的MAC要被认可，即 <spanclass="math display">\[\forall n, k \leftarrow Gen(1^n), \forall m\in\{0,1\}^*, Vrfy_k(m,Mac_k(m))=1\]</span></p><p>当 <span class="math inline">\(Mac\)</span>是确定性算法时，一种典型的认证方法是重新计算tag并进行比对.</p><p><strong>安全性</strong>通过消息认证试验 <spanclass="math inline">\(Mac-forge_{\mathcal{A},\Pi}(n)\)</span> 来定义：1. <span class="math inline">\(k \leftarrow Gen(1^n)\)</span>对敌手保密. 2. 给 <span class="math inline">\(\mathcal{A}(1^n)\)</span>调用 <span class="math inline">\(Mac_k(\cdot)\)</span> 的能力，<spanclass="math inline">\(\mathcal{A}\)</span> 查询若干次，最终输出 <spanclass="math inline">\((m,t)\)</span>. 记 <spanclass="math inline">\(\mathcal{Q}\)</span> 为 <spanclass="math inline">\(\mathcal{A}\)</span> 所查询消息的集合. 3. <spanclass="math inline">\(\mathcal{A}\)</span> 成功也即 <spanclass="math inline">\(Mac-forge_{\mathcal{A},\Pi}(n)=1\)</span> 当且仅当<span class="math inline">\(Vrfy_k(m,t)=1 \wedge m \notin\mathcal{Q}\)</span>.</p><p>一个 MAC 是 secure 当且仅当 对于任何一个PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , 都存在可忽略的函数 <spanclass="math inline">\(negl\)</span> ，使得 <spanclass="math display">\[Pr[Mac-forge_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>secure保证了一个敌手不可能为一个先前未认证的<strong>新消息</strong>生成一个合法的tag, 但是并未保证敌手不能为已经认证的消息生成一个<strong>新的合法tag</strong>, 于是有了 strongly secure</p><p>消息认证试验 <spanclass="math inline">\(Mac-sforge_{\mathcal{A},\Pi}(n)\)</span> : 1.<span class="math inline">\(k \leftarrow Gen(1^n)\)</span> 对敌手保密.2. 给 <span class="math inline">\(\mathcal{A}(1^n)\)</span> 调用 <spanclass="math inline">\(Mac_k(\cdot)\)</span> 的能力，<spanclass="math inline">\(\mathcal{A}\)</span> 查询若干次，最终输出 <spanclass="math inline">\((m,t)\)</span>. 记 <spanclass="math inline">\(\mathcal{Q}\)</span> 为 <spanclass="math inline">\(\mathcal{A}\)</span> 所查消息和对应tag对的集合. 3.<span class="math inline">\(\mathcal{A}\)</span> 成功也即 <spanclass="math inline">\(Mac-sforge_{\mathcal{A},\Pi}(n)=1\)</span>当且仅当 <span class="math inline">\(Vrfy_k(m,t)=1 \wedge (m,t) \notin\mathcal{Q}\)</span>.</p><p>一个 MAC 是 strongly secure 当且仅当 对于任何一个PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , 都存在可忽略的函数 <spanclass="math inline">\(negl\)</span> ，使得 <spanclass="math display">\[Pr[Mac-sforge_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>显然典型的使用确定性的 secure 的 MAC 天然就是 strongly secure 的.</p><h4 id="如何使用-mac">如何使用 MAC</h4><p>What if Alice needs to send a message in Q, (i.e. was sentpreviously)? + Directly applying the MAC would cause repeated messagesto be rejected. + One can append a unique timestamp or nonce to eachmessage.</p><h3 id="构造-secure-的-mac">构造 secure 的 MAC</h3><h4 id="定长-mac">定长 MAC</h4><p>如果有函数 <span class="math inline">\(l\)</span> 使得对于任意 <spanclass="math inline">\(k \leftarrow Gen(1^n)\)</span>, <spanclass="math inline">\(Mac_k\)</span> 仅对 <spanclass="math inline">\(m\in \{0,1\}^{l(n)}\)</span> 上的消息有定义.</p><p>使用PRF！</p><p>令 <span class="math inline">\(F\)</span> 是 PRF . 对长为 n的消息定义一个定长的 MAC： + Mac : 输入密钥 <spanclass="math inline">\(k\in \{0,1\}^n\)</span> 和消息 <spanclass="math inline">\(m\in\{0,1\}^n\)</span>,输出标签 <spanclass="math inline">\(t:=F_k(m)\)</span>. + Vrfy: 输入密钥 <spanclass="math inline">\(k\in \{0,1\}^n\)</span> 消息 <spanclass="math inline">\(m\in \{0,1\}^n\)</span> 和标签 <spanclass="math inline">\(t\in\{0,1\}^n\)</span>,输出1当且仅当 <spanclass="math inline">\(t=F_k(m)\)</span>.</p><p>若 <span class="math inline">\(F\)</span> 是 PRF ，上述构造就是一个对长度为n的消息的 secure fixed-length MAC.</p><h4 id="处理长消息定长">处理长消息（定长）</h4><p>basic CBC-MAC: <span class="math inline">\(F\)</span> 是一个 PRF ，以及长度函数 <span class="math inline">\(l\)</span> + Mac : 输入 <spanclass="math inline">\(k \in \{0,1\}^n, m\in \{0,1\}^{n\cdotl(n)}\)</span> + 将 <span class="math inline">\(m\)</span> 分成 <spanclass="math inline">\(l(n)\)</span> 个长度为 <spanclass="math inline">\(n\)</span> 的块, + <spanclass="math inline">\(t_0:= 0^n\)</span>,对 <spanclass="math inline">\(i\)</span> 从 1 到 <spanclass="math inline">\(l(n)\)</span>, <span class="math inline">\(t_i :=F_k(t_{i-1} \oplus m_i)\)</span> + 输出 <spanclass="math inline">\(t_l\)</span> + Vrfy : 输入 <spanclass="math inline">\(k\in \{0,1\}^n, m, t\)</span>,输出1当且仅当 <spanclass="math inline">\(|m|=n\cdot l(n) \wedge t=Mac_k(m)\)</span>.</p><figure><img src="/image/crypto/basic-cbc.png" alt="basic-cbc mode" /><figcaption aria-hidden="true">basic-cbc mode</figcaption></figure><p>仍然仅能处理定长的消息！！！</p><h3 id="ae">AE</h3><p>消息的安全性和真实性都要！</p><h4 id="定义-1">定义</h4><p>一个私钥加密方案是 AE 的如果其是 CCA-secure 并且 unforgeable.</p><h4 id="cca安全">CCA安全</h4><p>CCA安全由CCA indistinguishability experiment <spanclass="math inline">\(PrivK_{\mathcal{A},\Pi}^{cca}(n)\)</span> 定义：1. <span class="math inline">\(k\leftarrow Gen(1^n)\)</span> 2.给敌手调用 <spanclass="math inline">\(Enc_k(\cdot),Dec_k(\cdot)\)</span>的权限，敌手输出 <span class="math inline">\(m_0,m_1\)</span>. 3. 加密<span class="math inline">\(c\leftarrowEnc_k(m_b),b\overset{\$}{\leftarrow}\{0,1\}\)</span>,将 <spanclass="math inline">\(c\)</span> 发送给敌手. 4. 敌手调用 <spanclass="math inline">\(Enc_k(\cdot),Dec_k(\cdot)\)</span>，但不允许直接调用 <span class="math inline">\(Dec_k(c)\)</span>，输出<span class="math inline">\(b&#39;\)</span>. 5. <spanclass="math inline">\(PrivK_{\mathcal{A},\Pi}^{cca}(n)=1\)</span>当且仅当 <span class="math inline">\(b=b&#39;\)</span>.</p><p>私钥加密方案 <span class="math inline">\(\Pi\)</span> 是 <spanclass="math inline">\(CCA-secure\)</span>的当且仅当对于任意PPT的敌手均有 <spanclass="math display">\[Pr[PrivK_{\mathcal{A},\Pi}^{cca}(n)=1]\leq\frac{1}{2} + negl(n).\]</span></p><p>可延展性（malleable) 在不知道 <span class="math inline">\(m\)</span>的前提下构造其密文. CCA安全推出了不可延展性.</p><h4 id="不可伪造性">不可伪造性</h4><p>不可伪造加密试验 <spanclass="math inline">\(Enc-Forge_{\mathcal{A},\Pi}(n)\)</span>: 1. <spanclass="math inline">\(k\leftarrow Gen(1^n)\)</span> 2. 敌手有调用 <spanclass="math inline">\(Enc_k(\cdot)\)</span> 的权限， 最终输出一个密文.3. <span class="math inline">\(m:=Dec_k(c)\)</span> ， <spanclass="math inline">\(Enc-Forge_{\mathcal{A},\Pi}(n)=1\)</span> 当且仅当密文合法且 <span class="math inline">\(m\)</span> 没被查过.</p><p>私钥加密方案 <span class="math inline">\(\Pi\)</span> 是 unforgeable当且仅当对于任意PPT的敌手均有 <spanclass="math display">\[Pr[Enc-Forge_{\mathcal{A},\Pi}(n)=1]\leq  negl(n).\]</span></p><h4 id="构造ae">构造AE</h4><p>加密后验证！</p><figure><img src="/image/crypto/encrpt-then-authenticate.png"alt="encrpt-then-authenticate" /><figcaption aria-hidden="true">encrpt-then-authenticate</figcaption></figure><p><span class="math inline">\(\Pi_E\)</span> 是CPA安全的，<spanclass="math inline">\(\Pi_M\)</span> 是strongly secureMAC,那么上述构造是AE.</p><h2 id="哈希函数及其应用">哈希函数及其应用</h2><ul><li>哈希函数<ul><li>加密哈希函数</li><li>定义域扩展</li><li>例子</li></ul></li><li>MAC 和 Hash<ul><li>使用哈希函数扩展 MAC 的定义域</li><li>使用哈希函数构造 MAC</li></ul></li><li>哈希函数的应用</li><li>针对哈希函数一般攻击</li></ul><h3 id="哈希函数">哈希函数</h3><p>将长串映射到短串！！！</p><h4 id="加密哈希函数">加密哈希函数</h4><p>能在加密应用中使用的符合密码学要求的哈希函数，一般满足如下要求： +collision resistant: It is difficult to find two different messages<span class="math inline">\(m\)</span> and <spanclass="math inline">\(m′\)</span> such that <spanclass="math inline">\(hash(m) = hash(m′)\)</span>. + “completelyunpredictable” (a.k.a. <strong>random oracles</strong>): The hashfunction is indistinguishable from a random mapping.</p><h5 id="抗碰撞哈希函数">抗碰撞哈希函数</h5><p>我们将键控哈希函数 <span class="math inline">\(H\)</span>视为一个以密钥 <span class="math inline">\(s\)</span> 和字符串 <spanclass="math inline">\(x\)</span> 为输入的函数 <spanclass="math inline">\(H^s(x)=H(s,x)\)</span>.</p><p>这儿的密钥 <span class="math inline">\(s\)</span>通常并不是随机采样出来的，而是由密钥生成算法 <spanclass="math inline">\(Gen\)</span> 生成的.此外，密钥 <spanclass="math inline">\(s\)</span> 并不保密...</p><p>输出长度为 <span class="math inline">\(l\)</span>的哈希函数是这么一对 PPT 的算法 (Gen,H), 满足: + <spanclass="math inline">\(s \leftarrow Gen(1^n)\)</span> + <spanclass="math inline">\(H\)</span> 以密钥 <spanclass="math inline">\(s\)</span> 和串 <spanclass="math inline">\(x\in\{0,1\}^*\)</span> 为输入，输出串 <spanclass="math inline">\(H^s(x) \in \{0,1\}^{l(n)}\)</span>.</p><p>如果 <span class="math inline">\(H^s\)</span> 仅对定长 <spanclass="math inline">\(l&#39;(n)&gt;l(n)\)</span>的输入有定义，我们就称之为定长哈希函数，也叫compression function.</p><h5 id="碰撞检测试验">碰撞检测试验</h5><p>The collision-finding experiment <spanclass="math inline">\(Hash\text{-}coll_{\mathcal{A},\Pi}(n)\)</span>: 1.<span class="math inline">\(s \leftarrow Gen(1^n)\)</span> 2. 给敌手<span class="math inline">\(s\)</span>, 敌手输出 <spanclass="math inline">\(x,x&#39;\)</span> 3. <spanclass="math inline">\(Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1\)</span>当且仅当 <span class="math inline">\(H^s(x)=H^s(x&#39;)\)</span></p><p>一个哈希函数 <span class="math inline">\(\Pi=(Gen,H)\)</span>是抗碰撞（collision resistant）的当且仅当对任意PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> ,都有<spanclass="math display">\[Pr[Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>我们有时候省略掉 <span class="math inline">\(Gen\)</span> ，直接称<span class="math inline">\(H\)</span> 或 <spanclass="math inline">\(H^s\)</span>为抗碰撞哈希函数.此外，在实践中，有很多非键控抗碰撞哈希函数.</p><p><strong>更弱的抗碰撞</strong> + 2nd p.r. 给一个均匀随机的 <spanclass="math inline">\(x\)</span>，找 <spanclass="math inline">\(x&#39;\)</span> 使得 <spanclass="math inline">\(H^s(x)=H^s(x&#39;)\)</span>. + p.r.给一个均匀随机的 <span class="math inline">\(y\)</span>, 找 <spanclass="math inline">\(x&#39;\)</span> 使得 <spanclass="math inline">\(y=H^s(x&#39;)\)</span>.</p><p><span class="math display">\[ c.r. \Rightarrow 2nd\ p.r. \Rightarrowp.r.\]</span></p><h4 id="定义域扩展">定义域扩展</h4><p>使用定长的 c.r. 哈希来构造对任意长度的哈希.</p><p>Merkle-Damgard Transform: + “Partition and Padding”. + <imgsrc="/image/crypto/Partition_and_Padding.png"alt="Partition and Padding" /> + “Chained-Compressing”. + <imgsrc="/image/crypto/Chained-Compressing.png"alt="Chained-Compressing" /></p><blockquote><p>If (Gen, h) is collision resistant, the (Gen, H) is also collisionresistant. Pf. 考虑 <span class="math inline">\(|x|=|x&#39;|\)</span> 和<span class="math inline">\(|x|\neq|x&#39;|\)</span> 两种情况.</p></blockquote><h3 id="mac-与-哈希">MAC 与 哈希</h3><h4 id="hash-and-mac">Hash and MAC</h4><p>至此，我们有对定长消息做认证的MAC，也有将任意长度的串映射到定长串的Hash，二者的结合注定发生奇妙的化学反应.</p><p>令 <span class="math inline">\(\Pi=(Mac,Vrfy)\)</span> 是对长度为<span class="math inline">\(l(n)\)</span> 的消息的 MAC , <spanclass="math inline">\(\Pi_H=(Gen_H,H)\)</span> 是输出为定长 <spanclass="math inline">\(l(n)\)</span> 的哈希函数, 构造一个MAC <spanclass="math inline">\(\Pi&#39;=(Gen&#39;,Mac&#39;,Vrfy&#39;)\)</span>适用于任意长度的消息： + Gen': 输入 <spanclass="math inline">\(1^n\)</span> ，均匀选择 <spanclass="math inline">\(k\in\{0,1\}^n\)</span> , 运行 <spanclass="math inline">\(Gen_H(1^n)\)</span> 得到 <spanclass="math inline">\(s\)</span> , 密钥 <spanclass="math inline">\(k&#39;:=&lt;k,s&gt;\)</span>. + Mac': 输入密钥<span class="math inline">\(&lt;k,s&gt;\)</span> , 和任意长度的消息<span class="math inline">\(m\in\{0,1\}^*\)</span> , 输出 <spanclass="math inline">\(t \leftarrow Mac_k(H^s(m))\)</span>. + Vrfy':输入密钥 <span class="math inline">\(&lt;k,s&gt;\)</span> , 消息 <spanclass="math inline">\(m\in\{0,1\}^*\)</span> , tag <spanclass="math inline">\(t\)</span> , 输出1当且仅当 <spanclass="math inline">\(Vrfy_k(H^s(m),t)=1\)</span>.</p><p>如果 <span class="math inline">\(MAC\)</span> 是secure的 , 且 <spanclass="math inline">\(\Pi_H\)</span> 是抗碰撞的，那么上述构造是对任意长度的消息的一个secure的MAC.（Pf.两种情况分别规约到c.r.Hash和secure MAC上）</p><h4 id="hmac">HMAC</h4><figure><img src="/images/HMAC.png" alt="HMAC" /><figcaption aria-hidden="true">HMAC</figcaption></figure><h3 id="针对哈希的一般攻击">针对哈希的一般攻击</h3><p>由鸽巢原理，找 <span class="math inline">\(2^{l+1}\)</span>个值总能找到碰撞 <span class="math inline">\(\Theta(2^l)\)</span>,有没有可能少找一些期望有一定概率找到呢？</p><p>生日问题： &gt; If q people are in a room, what is the probabilitythat two of them have the same birthday?</p><p>若 <span class="math inline">\(y_1,...,y_q\)</span> 是从 <spanclass="math inline">\(\{1,...,N\}\)</span> 中均匀抽取的，当 <spanclass="math inline">\(q=\Theta(N^{1/2})\)</span> 时，有接近 1/2的概率存在碰撞.</p><blockquote><p>The above imply that a hash function with n-bit output is limited ton/2 bits of security.</p></blockquote><h2id="单向函数与硬核谓词hard-core-predicates">单向函数与硬核谓词(Hard-CorePredicates)</h2><ul><li>单向函数</li><li>OWF候选名单</li><li>硬核谓词<ul><li>任意OWF的硬核谓词</li></ul></li><li>使用OWF构造PRG</li></ul><h3 id="单向函数">单向函数</h3><p>什么是OWF？ + easy to compute + hard to invert</p><p>我们给出OWF的<strong>形式化定义</strong>.一个函数 <spanclass="math inline">\(f:\{0,1\}^* \rightarrow \{0,1\}^*\)</span> 是<strong>one-way</strong> 如果满足以下两个条件： 1. Easy to compute :存在PPT的算法 <span class="math inline">\(M_f\)</span> 来计算 f(多项式时间内可计算) 2. Hard to invert: <spanclass="math inline">\(\forall PPT \mathcal{A} ,Pr_{x\overset{\$}{\leftarrow}\{0,1\}^n}[\mathcal{A}(1^n,f(x))\inf^{-1}(f(x))]\leq negl(n)\)</span>.</p><p>注意，此处的 <spanclass="math inline">\(x\overset{\$}{\leftarrow}\{0,1\}^n\)</span>是均匀选取的，并且我们只要求给出原象，不求给出 <spanclass="math inline">\(x\)</span> 本身.</p><p>我们当然也有inverting experiment <spanclass="math inline">\(Invert_{\mathcal{A},f}(n)\)</span>: 1. 均匀选取<span class="math inline">\(x\in\{0,1\}^n\)</span> , 计算 <spanclass="math inline">\(y:=f(x)\)</span> 2. 敌手以 <spanclass="math inline">\(y\)</span> 为输入， 输出 <spanclass="math inline">\(x&#39;\)</span> 3. <spanclass="math inline">\(Invert_{\mathcal{A},f}(n)=1/ iff./f(x&#39;)=y\)</span></p><p>Hard to invert: 对任意PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , <spanclass="math inline">\(Pr[Invert_{\mathcal{A},f}(n)=1]\leqnegl(n)\)</span>.</p><h3 id="owf的候选名单">OWF的候选名单</h3><p>事实上，我们并不知道是不是真的有OWF:(但是我们还是有些候选函数，至少我们至今没有发现PPT的算法来invert它们...</p><ul><li>整数分解</li><li>子集和问题</li><li>离散对数问题</li></ul><h3 id="硬核谓词hard-core-predicates">硬核谓词(Hard-CorePredicates)</h3><p><span class="math inline">\(f(x)\)</span> 是OWF意味着我们无法从 <spanclass="math inline">\(f(x)\)</span> 中还原出 <spanclass="math inline">\(x\)</span>, 但并不意味着 <spanclass="math inline">\(f(x)\)</span> 不会泄露 <spanclass="math inline">\(x\)</span> 的信息，就比如 <spanclass="math inline">\(f(x_1||x_2)=x_1||g(x_2)\)</span>.</p><p>我们定义函数 <span class="math inline">\(f\)</span> (不一定是OWF)的硬核谓词 <span class="math inline">\(hc:\{0,1\}^*\rightarrow\{0,1\}\)</span> 如果 <span class="math inline">\(hc\)</span>可以在多项式时间内计算，并且对任意PPT的 <spanclass="math inline">\(\mathcal{A}\)</span> 有 <spanclass="math display">\[Pr_{x\overset{\$}{\leftarrow}\{0,1\}^n}[\mathcal{A}(1^n,f(x))=hc(x)]\leq1/2 + negl(n)\]</span>.</p><p>这儿的 <spanclass="math inline">\(x\overset{\$}{\leftarrow}\{0,1\}^n\)</span>依然是均匀选取的.另外，我们没要求函数 <spanclass="math inline">\(f\)</span> 一定是OWF.</p><h4 id="任意owf的硬核谓词">任意OWF的硬核谓词</h4><p><strong>Goldreich-Levin Theorem</strong>: Assume one-way function(resp. permutation) exists. Then there exists a one-way function (resp.permutation) <span class="math inline">\(g\)</span> and a hard-corepredicate <span class="math inline">\(hc\)</span> of <spanclass="math inline">\(g\)</span>.</p><figure><img src="/image/crypto/Goldreich-Levin-Theorem.png"alt="Goldreich-Levin Theorem" /><figcaption aria-hidden="true">Goldreich-Levin Theorem</figcaption></figure><p>这里的 <span class="math inline">\(r\)</span> 是均匀随机选取的.</p><h3 id="使用owf构造prg">使用OWF构造PRG</h3><p>令 <span class="math inline">\(f\)</span> 是一个one-waypermutation，<span class="math inline">\(hc\)</span> 是 <spanclass="math inline">\(f\)</span> 的硬核谓词，那么 <spanclass="math inline">\(G(s)=f(s)||hc(s)\)</span> 是一个 PRG 扩展因子为<span class="math inline">\(l(n)=n+1\)</span>.</p><p>下面开始叠叠乐！</p><p>如果有一个 扩展因子为 <span class="math inline">\(n+1\)</span>的PRG，那么对任意多项式 <span class="math inline">\(poly\)</span>，存在PRG <span class="math inline">\(\hat{G}\)</span> 扩展因子为 <spanclass="math inline">\(poly(n)\)</span>.</p><figure><img src="/image/crypto/polyPRG.png" alt="polyPRG" /><figcaption aria-hidden="true">polyPRG</figcaption></figure><h2 id="数论与密码学困难度假设">数论与密码学困难度假设</h2><h3 id="基础知识">基础知识</h3><p>带余除法唯一表示：<span class="math display">\[a \in \mathbb{Z} , b\in \mathbb{Z}_+ , \exists \ unique\ q,r \in \mathbb{Z}, s.t.\ a=qb+r,\0\leq r\leq b.\]</span> <strong>最大公因数</strong> <spanclass="math display">\[a,b\in \mathbb{Z}_+, \exists X,Y \in \mathbb{Z},\s.t.\ Xa+Yb=gac(a,b).\]</span> 此外，<spanclass="math inline">\(gcd(a,b)\)</span> 是满足上述方程的最小正整数.</p><blockquote><p>欧几里得算法与拓展欧几里得算法.</p></blockquote><p>对大于等于1的整数 <span class="math inline">\(b,N\)</span> , <spanclass="math inline">\(b\)</span> 在模 <spanclass="math inline">\(N\)</span> 意义上有逆元当且仅当 <spanclass="math inline">\(gcd(b,N)=1\)</span>.</p><blockquote><p>拓展欧几里得算法.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>    x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>  y -= a / b * x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>群</strong>是一种代数结构，由一个集合 <spanclass="math inline">\(\mathbb{G}\)</span> 和定义在集合上的二元运算 <spanclass="math inline">\(\circ\)</span> 构成，满足: + 封闭性 + 结合律 +有逆元 + 有单位元 <img src="/image/crypto/group.png" alt="group" /></p><p>$N=_i p_i^{e_i} $ , 其中 <span class="math inline">\(p_i\)</span>是不同的素数， <span class="math inline">\(e_i\geq 1\)</span>, 那么有<span class="math inline">\(\phi(N)=\Pi_ip_i^{e_i-1}(p_i-1)\)</span>.</p><p><spanclass="math inline">\(g^0\overset{def}{=}1,g^{-m}\overset{def}{=}(g^{-1})^m\)</span>.</p><p>令 <span class="math inline">\(\mathbb{G}\)</span> 是有限群 <spanclass="math inline">\(m=|\mathbb{G}|\)</span> ,则 <spanclass="math inline">\(\forall g \in \mathbb{G} ,g^m=1\)</span>.</p><p><strong>Fermat-Euler Theorem</strong> <spanclass="math inline">\(\forall N&gt;1, a\in Z_N^* ,a^\phi(N)=1\ mod\N.\)</span></p><blockquote><p>Fermat-Euler Theorem 在计算模下求幂和非素性检测有用</p></blockquote><h3 id="中国剩余定理">中国剩余定理</h3><p>常用来解同余方程.</p><figure><img src="/image/crypto/CRT.png" alt="CRT" /><figcaption aria-hidden="true">CRT</figcaption></figure><blockquote><p>from <ahref="https://oi-wiki.org/math/number-theory/crt/#%E5%BC%95%E5%85%A5">OI-Wiki</a></p></blockquote><p>群论下的中国剩余定理：</p><figure><img src="/image/crypto/gCRT.png" alt="gCRT" /><figcaption aria-hidden="true">gCRT</figcaption></figure><p>求逆：</p><figure><img src="/image/crypto/crt-eg3.png" alt="crt-eg3" /><figcaption aria-hidden="true">crt-eg3</figcaption></figure><figure><img src="/image/crypto/crt-eg3-.png" alt="crt-eg3—" /><figcaption aria-hidden="true">crt-eg3—</figcaption></figure><h3 id="factoring-assumption">Factoring Assumption</h3><p><strong><spanclass="math inline">\(GenModulus(1^n)\)</span></strong>: + 输出 <spanclass="math inline">\((N,p,q)\)</span> + <spanclass="math inline">\(N=pq\)</span> + 除可忽略的概率 <spanclass="math inline">\(negl(n)\)</span> 外，<spanclass="math inline">\(p,q\)</span> 均为 <spanclass="math inline">\(n-bit\)</span> 素数.</p><p><strong>The factoring experiment</strong> <spanclass="math inline">\(Factor_{\mathcal{A},GenModulus}(n)\)</span>: 1.<span class="math inline">\((N,p,q) \leftarrow GenModulus(1^n)\)</span>2. 给 <span class="math inline">\(\mathcal{A}\)</span> <spanclass="math inline">\(N\)</span> , 要其输出 <spanclass="math inline">\(p&#39;,q&#39;\)</span> 3. <spanclass="math inline">\(Factor_{\mathcal{A},GenModulus}(n)=1\)</span> iff.<span class="math inline">\(N=p&#39;q&#39;\)</span>.</p><p><strong>Factoring is hard relative to GenModulus</strong> if for allPPT algorithms <span class="math inline">\(\mathcal{A}\)</span> thereexists a negligible function <span class="math inline">\(negl\)</span>such that <spanclass="math display">\[Pr[Factor_{\mathcal{A},GenModulus}(n)=1]\leqnegl(n).\]</span></p><p><strong>FactoringAssumption</strong>就是假设存在这么一个<strong>GenModulus</strong>使factoring是hard的.</p><h3 id="rsa-problem">RSA problem</h3><p><span class="math inline">\(GenRSA(1^n)\)</span> : + 输出 <spanclass="math inline">\((N,e,d)\)</span> + <spanclass="math inline">\(N\)</span> 是两个 <spanclass="math inline">\(n-bit\)</span> 素数的乘积 + <spanclass="math inline">\(gcd(e,\phi(N))=1, ed=1\ mod\ \phi(N)\)</span></p><p>The RSA experiment <spanclass="math inline">\(RSA-inv_{\mathcal{A},GenRSA}(n)\)</span>: 1. <spanclass="math inline">\((N,e,d)\leftarrow GenRSA(1^n)\)</span> 2. 均匀选取<span class="math inline">\(y\in \mathbb{Z}_N^*\)</span>. 3. 给 <spanclass="math inline">\(\mathcal{A}\)</span> <spanclass="math inline">\((N,e,y)\)</span> , 输出 <spanclass="math inline">\(x\in \mathbb{Z}_N^*\)</span> 4. <spanclass="math inline">\(RSA-inv_{\mathcal{A},GenRSA}(n)=1\)</span> iff.<span class="math inline">\(x^e=y\)</span>.</p><p><strong>The RSA problem is hard relative to GenRSA</strong> if forall PPT algorithms <span class="math inline">\(\mathcal{A}\)</span>there exists a negligible function <spanclass="math inline">\(negl\)</span> such that <spanclass="math display">\[Pr[RSA-inv_{\mathcal{A},GenRSA}(n)=1]\leqnegl(n).\]</span></p><p><strong>RSAAssumption</strong>就是假设存在这么一个<strong>GenRSA</strong>使RSAproblem是hard的.</p><h3 id="循环群">循环群</h3><figure><img src="/image/crypto/cyclic_group.png" alt="cyclic_group" /><figcaption aria-hidden="true">cyclic_group</figcaption></figure><h3 id="离散对数问题">离散对数问题</h3><p>对于 <span class="math inline">\(h\in \mathbb{G}\)</span> , <spanclass="math inline">\(\mathbb{G}\)</span> 是一个循环群, 存在唯一的 <spanclass="math inline">\(x\in Z_q, q=|\mathbb{G}|\)</span>, 使得 <spanclass="math inline">\(g^x=h\)</span>, 我们称 <spanclass="math inline">\(x\)</span> 是 <spanclass="math inline">\(h\)</span> 的离散对数 w.r.t <spanclass="math inline">\(g\)</span> , 写作 <spanclass="math inline">\(x=log_g\ h\)</span>.</p><p>离散对数问题就是求解一个在循环群上均匀抽取的元素的离散对数，可定义为以下试验.</p><p>The discrete-logarithm experiment <spanclass="math inline">\(DLog_\{\mathcal{A},\mathcal{G}\}\)</span>: 1.<span class="math inline">\((\mathbb{G},q,g)\leftarrow\mathcal{G}(1^n)\)</span>, 其中 <spanclass="math inline">\(\mathbb{G}\)</span> 是循环群, <spanclass="math inline">\(q=|\mathbb{G}|,\overline{||q||=n}\)</span>, <spanclass="math inline">\(g\)</span> 是生成元. 2. $h $ 3. 给 <spanclass="math inline">\(\mathcal{A}\)</span> 输入 <spanclass="math inline">\(\mathbb{G},q,g,h\)</span> , 其输出 <spanclass="math inline">\(x\in \mathbb{Z}_q\)</span>. 4. <spanclass="math inline">\(DLog_\{\mathcal{A},\mathcal{G}\}=1\)</span> iff.<span class="math inline">\(g^x=h\)</span>.</p><p>We say that <strong>the discrete-logarithm problem is hard relativeto <span class="math inline">\(\mathcal{G}\)</span> </strong>if for allPPT algorithms <span class="math inline">\(\mathcal{A}\)</span> thereexists a negligible function <span class="math inline">\(negl\)</span>such that <span class="math display">\[Pr[DLog_\{\mathcal{A},\mathcal{G}\}=1]\leq negl(n) .\]</span></p><p>离散对数假设就是假定存在这么一个 <spanclass="math inline">\(\mathcal{G}\)</span>.</p><h3 id="d-h-problem">D-H Problem</h3><p>The <strong>computational</strong> D-H (CDH) problem: Given <spanclass="math inline">\(g\)</span>, <spanclass="math inline">\(g^x\)</span> and <spanclass="math inline">\(g^y\)</span>, can you compute <spanclass="math inline">\(g^{xy}\)</span>?</p><p>The <strong>decisional</strong> D-H (DDH) problem: Given <spanclass="math inline">\(g\)</span>, <spanclass="math inline">\(g^x\)</span>, <spanclass="math inline">\(g^y\)</span>, and g^{xy}, can you differentiate<span class="math inline">\(g^{xy}\)</span> from a uniform random groupelement <span class="math inline">\(g^z\)</span>?</p><p>The D-H assumptions are assumptions that there exists instances ofCDH/DDH problem which are hard.</p><blockquote><p>Closed related to the discrete-logarithm problem, but <strong>notknown</strong> to be equivalent.</p></blockquote><h2 id="密钥管理与公钥加密变革">密钥管理与公钥加密变革</h2><h3 id="kdc">KDC</h3><p>A secure key-distribution protocol using a KDC:</p><figure><img src="/image/crypto/Needham-Schroeder.png"alt="Needham-Schroeder" /><figcaption aria-hidden="true">Needham-Schroeder</figcaption></figure><h3 id="d-h-key-exchange-protocol">D-H key-exchange protocol</h3><p>D-H key-exchange protocol 的构造如下，其中 <spanclass="math inline">\(\mathbb{G}\)</span> 是循环群, <spanclass="math inline">\(q=|\mathbb{G}|,||q||=n\)</span>, <spanclass="math inline">\(g\)</span> 是生成元$:</p><figure><img src="/image/crypto/D-H-exchange.png" alt="D-H-exchange" /><figcaption aria-hidden="true">D-H-exchange</figcaption></figure><p><strong>安全性</strong>：我们把脚本协议双方来往的所有信息记录下来丢给敌手，如果敌手在此加持下无法区分真正的密钥和一个随机抽取的假密钥，那么协议应该是安全的。具体的：</p><figure><img src="/image/crypto/KE.png" alt="KE" /><figcaption aria-hidden="true">KE</figcaption></figure><p>A key-exchange protocol <span class="math inline">\(\Pi\)</span> issecure in the presence of an eavesdropper if for all PPT adversaries<span class="math inline">\(\mathcal{A}\)</span> there is a negligiblefunction <span class="math inline">\(negl\)</span> such that <spanclass="math display">\[ Pr[KE^{eav}_{\mathcal{A},\Pi}(n) = 1] ≤ 1/2+negl(n).\]</span></p><figure><img src="/image/crypto/KEsecure.png" alt="KEsecure" /><figcaption aria-hidden="true">KEsecure</figcaption></figure><blockquote><p>我们在这儿使用了KE试验的变体，证明时将DDH问题规约到KE上来.</p></blockquote><h2 id="公钥加密">公钥加密</h2><h3 id="定义-2">定义</h3><p>公钥加密方案是一个PPT算法的三元组(Gen,Enc,Dec),其中Gen生成一对密钥(pk,sk),Enc使用公钥pk进行加密,Dec则使用私钥sk进行解密.具体的<strong>定义</strong>见下图：</p><figure><img src="/image/crypto/public-key_encryption.png"alt="public-key_encryption" /><figcaption aria-hidden="true">public-key_encryption</figcaption></figure><h3 id="安全性">安全性</h3><h4 id="cpa">CPA</h4><p>在下图所定义的EAV试验中，敌手 <spanclass="math inline">\(\mathcal{A}\)</span> 是被给予了 <spanclass="math inline">\(pk\)</span>的，以及试验中的加密采用了公钥加密方案，除此之外和私钥加密时定义的EAV试验是一样的。但是正由于敌手被给予了<span class="math inline">\(pk\)</span>，而加密方案又是公开的，因此敌手相当于得到了Enc的权限，从而一旦secure天然就有CPA-secure.</p><figure><img src="/image/crypto/pubeav.png" alt="pubeav" /><figcaption aria-hidden="true">pubeav</figcaption></figure><p>同样我们有根据试验所定义的<strong>安全性</strong>.</p><figure><img src="/image/crypto/Pub-secure.png" alt="Pub-secure" /><figcaption aria-hidden="true">Pub-secure</figcaption></figure><p>如果一个公钥加密方案是CPA-secure，它对多消息加密天然也是CPA-secure的.</p><p>此外，定长的CPA-secure加密可以推出任意长的CPA-secure加密(切成定长块，和多消息加密差不多了就).</p><h4 id="cca">CCA</h4><p>私钥当然是不能给敌手的，因此敌手还是以神谕基的形式调用Dec.</p><figure><img src="/image/crypto/CCA-secure.png" alt="CCA-secure" /><figcaption aria-hidden="true">CCA-secure</figcaption></figure><p>我们当然也有基于试验的安全性定义.</p><figure><img src="/image/crypto/CCA-secure-def.png" alt="CCA-secure-def" /><figcaption aria-hidden="true">CCA-secure-def</figcaption></figure><p>如果一个公钥加密方案是CCA-secure，它对多消息加密天然也是CCA-secure的.但是我们无法将定长CCA安全方案推广到任意长了，因为敌手完全可以打乱顺序进行解密...</p><h3 id="杂交加密">杂交加密</h3><figure><img src="/image/crypto/hybrid-encryption.png"alt="hybrid-encryption" /><figcaption aria-hidden="true">hybrid-encryption</figcaption></figure><p>KEM: 一个黑盒，输入公钥，为私钥加密生成对应的私钥和私钥密文.</p><p>DEM: 也就是公钥加密.</p><blockquote><p>A key-encapsulation mechanism (KEM) is a public-key primitive thatefficiently generates an encryption key for the private-key encryption kand its ciphertext c in a hybrid encryption scheme. Accordingly, theprivate-key encryption scheme is called a data-encapsulation mechanism(DEM) here.</p></blockquote><figure><img src="/image/crypto/KEM-DEM.png" alt="KEM-DEM" /><figcaption aria-hidden="true">KEM-DEM</figcaption></figure><h3 id="cdhddh-based-encryption">CDH/DDH-Based Encryption</h3><p>The El Gamal encryption scheme is described in the following:</p><figure><img src="/image/crypto/El-Gamal-encryption.png"alt="El-Gamal-encryption" /><figcaption aria-hidden="true">El-Gamal-encryption</figcaption></figure><p>安全性：</p><figure><img src="/image/crypto/El-Gamal-encryption-secure.png"alt="El-Gamal-encryption-secure" /><figcaption aria-hidden="true">El-Gamal-encryption-secure</figcaption></figure><blockquote><p>构造一个完全随机的 <span class="math inline">\(&lt;g^y,g^z\cdotm\)</span> 来证明.</p></blockquote><p>El Gamal encryption 不是CCA安全的！！！具有延展性(<spanclass="math inline">\(&lt;c_1,c_2&gt;,&lt;c_1^2,c_2^2&gt;\)</span>).</p><h3 id="rsa">RSA</h3><h4 id="plain-rsa">Plain RSA</h4><figure><img src="/image/crypto/RSA-key-generation.png"alt="RSA-key-generation" /><figcaption aria-hidden="true">RSA-key-generation</figcaption></figure><figure><img src="/image/crypto/plain-RSA-encryption-scheme.png"alt="plain-RSA-encryption-scheme" /><figcaption aria-hidden="true">plain-RSA-encryption-scheme</figcaption></figure><p>plainRSA不是CPA安全的.事实上任何确定性的公钥加密算法都不会是CPA安全的！此外，我们无法通过RSAassumption来证明其安全性...</p><h4 id="padded-rsa">Padded RSA</h4><figure><img src="/image/crypto/Padded-RSA.png" alt="Padded-RSA" /><figcaption aria-hidden="true">Padded-RSA</figcaption></figure><figure><img src="/image/crypto/PKCS.png" alt="PKCS" /><figcaption aria-hidden="true">PKCS</figcaption></figure><h2 id="数字签名机制">数字签名机制</h2><p>TBD</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CRYPTO</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>成长的短视</title>
    <link href="/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/"/>
    <url>/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/</url>
    
    <content type="html"><![CDATA[<p>小百合系版"有像我一样不会写代码的cser么?"回复节选</p><ul><li>我们都是活生生的人,从小就被不由自主地教导用最小的付出获得最大的得到,经常会忘记我们究竟要的是什么. 我承认我完美主义,但我想每个人心中都有那一份求知的渴望和对真理的向往,"大学"的灵魂也就在于超越世俗, 超越时代的纯真和理想--我们不是要讨好企业的毕业生, 而是要寻找改变世界的力量. -- jyy</li><li>教育除了知识的记忆之外, 更本质的是能力的训练, 即所谓的training.而但凡training就必须克服一定的难度, 否则你就是在做重复劳动,能力也不会有改变. 如果遇到难度就选择退缩,或者让别人来替你克服本该由你自己克服的难度,等于是自动放弃了获得training的机会, 而这其实是大学专业教育最宝贵的部分.-- etone</li><li>这种"只要不影响我现在survive, 就不要紧"的想法其实非常的利己和短视:你在专业上的技不如人, 迟早有一天会找上来,会影响到你个人职业生涯的长远的发展; 更严重的是,这些以得过且过的态度来对待自己专业的学生,他们的survive其实是以透支南大教育的信誉为代价的 --如果我们一定比例的毕业生都是这种情况, 那么过不了多久,不但那些混到毕业的学生也没那么容易survive了,而且那些真正自己刻苦努力的学生, 他们的前途也会受到影响. -- etone</li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>名师导学期中</title>
    <link href="/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/"/>
    <url>/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/</url>
    
    <content type="html"><![CDATA[<h1id="关于高效寻找适用于锂-空气电池催化剂的思考">关于高效寻找适用于锂-空气电池催化剂的思考</h1><h2 id="介绍研究背景和现状">介绍研究背景和现状</h2><h3 id="研究背景">研究背景</h3><p>煤、石油、天然气等化石能源的日益枯竭，以及化石燃料燃烧带来的诸多环境问题，迫使人们寻求、开发清洁高效的可再生能源和储能系统。锂-空气电池（<spanclass="math inline">\(Li-O_2\)</span>电池）以金属锂作为负极，从空气中直接获取氧气进行正极反应而无需将氧气存储在电池内部，具有非常高的理论比能量(约<spanclass="math inline">\(11140Wh·kg^{-1}\)</span>)，这一数值非常接近汽油的理论比能量（约<spanclass="math inline">\(13kWh·kg^{-1}\)</span>）。这使得锂-空气电池在新能源汽车领域有着较好的应用前景，受到了人们的广泛关注。相关领域经过多年发展，针对锂-空气电池的研究逐渐深入，成果显著，锂-空气电池也是被视为极具应用前景的下一代储能系统之一，但锂-空气电池体系仍存在一些亟待解决的技术问题。</p><h3 id="研究现状">研究现状</h3><p>依据工作环境和介质条件的不同，当前被研究最多的锂空气电池主要是有机电解液、有机-水组合电解液以及全固态电解质三种类型。</p><p>有机体系锂-空气电池的结构相对简单，符合经典的摇椅式电池结构，能量密度最高、体系最为稳定。其选择溶解有钾盐的有机溶剂为电解液，如醚、烯酯等。放电时，氧气在正极被还原并与电解液里的<spanclass="math inline">\(Li^+\)</span>结合，金属锂在负极被氧化生成 <spanclass="math inline">\(Li^+\)</span>进入电解液。虽然正极的反应方式容易使人们联想到氢氧燃料电池，但与氢氧燃料电池不同的是，锂-空气电池放电会产生锂的绝缘难溶氧化物，可能会使空气通道被阻塞、电池极化增大从而导致放电提前终止，从而影响放电容量。另外，由于金属锂的活泼性，空气中的水、二氧化碳等诸多成分都会造成金属锂的腐蚀，影响电池寿命。事实上，已经有研究报道了水分子（相对湿度）对有机锂-空气电池的影响：水分子会使得放电容量有所增加，但会对电池的循环性能和倍率性能造成负面影响<spanclass="math inline">\(^4\)</span>。除此之外，有机体系锂-空气电池还存在着充放电过程空气正极过电位过大、充放电效率低等问题，对催化剂的性能、催化剂的稳定性提出了较高的要求，这也是当前许多研究人员正在关注、研究的重要课题。</p><p>为解决有机体系中正极反应会生成绝缘难溶氧化物问题，周豪慎教授研究组首先提出有机-水组合电解液型锂-空气电池。在这种锂-空气电池里，<spanclass="math inline">\(LiOH\)</span>水溶液和有机电解液分别与电池的正负极接触，二者用<spanclass="math inline">\(LISICON\)</span>隔开。研究表明，该类型电池可连续放电<spanclass="math inline">\(500h\)</span>以上，比容量高达<spanclass="math inline">\(50000mAh·g^{-1}\)</span>。在后续研究中，研究人员针对<spanclass="math inline">\(LISICON\)</span>在碱性环境不稳定等问题进行了改进，进一步提高了电池的稳定性与能量密度。另外，在组合电解液型电池的基础上，研究人员还提出了液流型锂-空气电池。有机-水组合电解液和液流型锂-空气电池都解决了有机电解液型电池中存在的正极产生绝缘氧化物影响电池性能的问题，更为接近燃料电池，同时使电池受空气中其他成分影响大幅减小，持续放电能力增强<spanclass="math inline">\(^4\)</span>。但此类型电池对隔膜材料的稳定性和离子电导率提出了较高要求，仍存在较大过电位损失这一问题。</p><p>事实上，虽然锂-空气电池理论能量密度高，应用潜力巨大，但还无法真正实现商业化，仍有诸多问题亟待解决：</p><ul><li>正极充放电过程有较大的过电位</li><li>实际容量要比理论容量低</li><li>循环过程中的容量衰减较大</li></ul><h2 id="提出重要科学问题">提出重要科学问题</h2><p>当前的锂-空气电池的空气正极在充放电过程中均存在有较大的过电位问题，这使得空气正极被视作限制锂-空气电池发展的一大重要因素，寻找合适的催化剂可能有效缓解、甚至解决这一问题。事实上，为解决这一问题，早有国内外研究人员对不同相中的氧还原反应深入研究，试图找到廉价、高效、稳定的催化剂材料<spanclass="math inline">\(^5\)</span>。既然寻找催化材料如此重要，我们是否有方法加速寻找适用于锂-空气电池的催化剂材料？</p><h2 id="对问题的分析和研究">对问题的分析和研究</h2><p>当前计算机技术飞速发展，机器学习已在诸多领域有了广泛应用，例如机器学习已成为高效预测蛋白质功能的有效手段，在酶功能预测领域有了广泛应用<spanclass="math inline">\(^1\)</span>。而酶本身是一种高效的有机催化剂，是否也可以利用机器学习等计算机技术帮助我们高效设计、寻找高效稳定的催化剂材料来有效解决锂-氧气电池存在的过电位问题呢？本文余下内容旨在讨论机器学习等计算机技术协助寻找、开发合适的催化剂材料助力锂-空气电池发展的可能性与展望。</p><p>首先是利用机器学习来加速寻求高效稳定的催化剂材料的可能性。机器学习等数据科学能够为研究人员提供了快速灵活的预测框架，在材料研发等领域展现出极大的应用前景。</p><p>在电池领域，机器学习已有诸多应用。锂离子电池能量密度高，循环次数多，广泛应用于移动设备和电动汽车领域。但锂离子电池的寿命难以预测，使得对人们不得不花费大量的时间与成本做破坏性实验来得到某种电池的寿命数据。这就导致在用户的实际应用中，由于缺乏电池的剩余寿命数据，无法准确制定电源计划。另外，锂离子电池的剩余电量甚至也无法通过传统方法来精准预测。而随着人工智能技术的发展，研究人员发现可以利用深度学习等技术很好的解决这些问题。人们只需要提供电池使用一段时间的相关数据，就可利用机器学习技术，参照过去得到的数据信息，精准预测电池的剩余寿命和剩余电量<spanclass="math inline">\(^2\)</span>。与我们论题更为相关的电池材料方面，机器学习也已经在发挥重要作用。各种材料具有复杂的不同的性质，当人们采用不同的材料组合时，这些材料的性质相互影响叠加在一起才能决定电池的实际性能。人工穷举所有的材料组合显然是个难以完成的任务，而机器学习技术可以利用计算机的计算、存储能力，通过学习过去已有的实验资料高效而准确的筛选材料组合，从而大幅提高研发效率<spanclass="math inline">\(^2\)</span>。</p><p>在催化剂领域，机器学习也早已有了广泛的应用。除去上文提及的对酶的结构、功能的预测外，机器学习在无机催化领域也发挥着巨大的作用。温室效应的加剧是人们不得不面临的一个问题便是对<spanclass="math inline">\(CO_2\)</span>的处理。二氧化碳的电还原便是实现二氧化碳回收的重要方法之一。和锂-空气电池类似，此技术需要寻找高性能的电催化剂。近些年，诸多研究者利用大数据来辅助新型催化剂的开发，提高了开发效率，降低了开发成本，加速了二氧化碳电还原技术的发展<spanclass="math inline">\(^2\)</span>。此外，机器学习在搜寻新型双钙钛矿氧化物光催化剂领域也起到了重要的加速作用<spanclass="math inline">\(^3\)</span>。</p><p>锂-空气电池的空气正极通常包括防水层、集流体、催化层等部分<spanclass="math inline">\(^4\)</span>。多数情况，开发可有效降低锂-空气电池过电位的催化材料可以视为开发合适的电池材料的一个子任务。由上述介绍，我们知道机器学习已经在催化化学领域和电池材料领域有了广泛而重要的应用，利用机器学习等技术来加速研发适用于锂-空气电池的高效、稳定催化材料显然也是可能的。</p><h2 id="结果讨论与展望">结果讨论与展望</h2><p>正如上文所述，利用机器学习技术加速开发合适的正极催化材料来有效缓解、解决锂-空气电池充放电过程中的较大过电位问题是可能的。机器学习等方法相当依赖训练数据，为了得到更好的预测结果，除了需要选择、开发更合适的算法之外，还需要建立、完善相应的数据库，已加强训练效果。此外，选择、开发合适的算法涉及到学科交叉，这意味着数据科学研究者和自然科学家之间需要进行充分的对接。最后，机器学习方法不应与理论分析分离。由于机器学习归根结底是依靠训练数据进行猜测，在未训练到的方面是不可靠的，纵使在已经得到充分训练的领域，在对其结果进行应用前也应对进行相应理论分析和实验研究，方能放心使用。</p><p>综上所述，相信借助机器学习技术的辅助能使锂-空气电池技术加速发展，从而推动能源技术发展，进而助力人类社会可持续发展。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>池燕飞, 李春, 冯旭东. 机器学习在蛋白质功能预测领域的研究进展[J].生物工程学报, 2023, 39(6): 2141-2157.</li><li>许建兵, 李翰实, 谭济民, 等. 机器学习在固体氧化物燃料电池, 锂电池,CO2 电还原催化剂中的研究进展[J]. 硅酸盐学报, 2022, 50(11).</li><li>万新阳, 章烨辉, 陆帅华, 等.机器学习加速搜寻新型双钙钛矿氧化物光催化剂[J]. 物理学报, 2022.</li><li>童圣富, 何平, 张雪苹, 等.基于有机和组合电解液的锂空气电池研究进展[J]. 电化学, 2015, 21(3):234.</li><li>王迪, 乔羽, 邓瀚, 等. 锂-空气电池研究进展与表征方法[J]. 催化学报,2019, 40(s1): 217.</li></ol>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Review for Principles of Marxism</title>
    <link href="/2023/12/19/Review-for-Principles-of-Marxism/"/>
    <url>/2023/12/19/Review-for-Principles-of-Marxism/</url>
    
    <content type="html"><![CDATA[<h1 id="马原复习">马原复习</h1><blockquote><p>搬运自本人大一下马原复习文档</p></blockquote><h2 id="马克思主义">马克思主义</h2><ul><li><strong>马克思主义</strong>：由马克思和恩格斯创立，并为后继者所不断发展的科学理论体系，是关于科学社会以及人类思维发展的一般规律的学说，是关于社会主义必将代替资本主义最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。</li><li><strong>马克思主义的基本组成部分</strong>：马克思主义哲学、马克思主义政治经济学、科学社会主义。</li><li><strong>创立</strong>：三大先进思潮是德国古典哲学、英国古典政治经济学、英法空想社会主义。</li><li><strong>特征</strong>：科学性、人民性、实践性、发展性。</li></ul><h2 id="物质">物质</h2><ul><li><strong>物质</strong>：是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，不依赖我们的感觉而存在，为我们的感觉所复写、摄影、反映。</li><li><strong>哲学基本问题</strong>：一、存在和思维、物质和意识谁为本源的问题，即何者为第一性的问题（产生了唯物和唯心）；二、存在和思维、物质和意识是否具有同一性的问题，即思维能否正确反映存在，人能否认识和正确认知世界的问题（产生了可知论和不可知论）。</li><li><strong>马克思理论意义</strong>：坚持唯物主义一元论（非唯心一元or二元论），坚持能动的反映论和可知论，批判不可知论，体现了唯物论和辩证论的统一，克服形而上学唯物主义的缺陷，体现唯物主义自然观和历史观的统一，为彻底的唯物主义奠定了理论基础。</li><li><strong>物质和意识的相互作用</strong>：1.意识是人脑的机能和属性，是客观世界的主观映像，物质对意识的决定作用表现在意识的本质和起源上：意识在内容上是客观的，在形式上是主观的，体现了主观与客观形式的统一。2.物质决定意识，意识对物质具有反作用，这种反作用是意识的能动作用，表现在：第一，意识具有目的性和计划性；第二，意识具有创造性；第三，意识可以指导实践改造客观世界；第四，意识可以调控人的行为和生理活动。</li><li><strong>意识与人工智能</strong>：人工智能是人的意识能动性的一种特殊表现，是人的本质力量的对象化和现实化。人工智能不能超越人类。第一，人类意识是知情意的统一体，而人工智能只是对人类的理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形态。第二，社会性是人类意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性。第三，人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力。</li></ul><h2 id="实践和认识">实践和认识</h2><ul><li><strong>科学实践观的意义</strong>：1.克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础；2.建立了科学的、能动的、革命的反映论，实现了人类认识史上的变革；3.在人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础；4.为人类能动的认识和改造世界提供了基本的思想方法和工作方法。</li><li><strong>实践对认识的决定作用</strong>：实践是认识的来源，是认识发展的动力，是认识的目的，是检验认识真理性的唯一标准。</li><li><strong>实践的本质</strong>：是人类能动的改造世界的社会性的物质活动，具有客观实在性、自觉能动性和社会历史性三个基本特征。</li><li><strong>实践的结构</strong>：实践主体、实践客体、实践中介。</li><li><strong>实践的过程</strong>：实践目的的确定、主体通过中介或手段作用于客体、实践结果的检验和评价。</li><li><strong>认识的本质</strong>：主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。唯心主义认识路线否认认识是人脑对客观世界的反映，认为认识先于人的实践经验。旧唯物主义认识论以感性直观为基础，把人的认识看成消极的、被动的反映和接受外界对象，是直观的、消极被动的反映论。</li><li><strong>真理</strong>：是标志主观和客观相符合的哲学范畴，是对客观事物及其规律的正确反映。</li><li><strong>谬误</strong>：所谓谬误，是同客观事物及其发展规律相违背的认识，是对客观世界及其发展规律的歪曲反映。</li><li><strong>价值</strong>：价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义。</li><li><strong>真理与谬误的关系</strong>：第一，二者相互对立；第二，二者的对立是相对的，它们在一定条件下能够相互转化；第三，真理和谬误的对立统一关系表明，真理总是同谬误相比较而存在、相斗争而发展的。实践是检验真理的唯一标准。</li></ul><h2 id="人类社会的发展规律">人类社会的发展规律</h2><ul><li><strong>社会存在</strong>：社会存在是指社会物质生活条件，是社会生活的物质方面，主要包括自然地理环境、人口因素和物质生产方式。</li><li><strong>唯物史观和唯心史观</strong>：马克思主义产生之前，唯心史观占据统治地位。</li><li><strong>社会意识</strong>：是社会存在的反映，是社会生活的精神方面，社会意识是人们进行社会物质交往的产物。</li><li><strong>社会存在和社会意识的辩证关系</strong>：1.社会存在决定社会意识。社会意识是对社会存在的反映，并反作用于社会存在，社会存在的变化发展决定社会意识的变化发展；2.社会存在是社会意识的内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映；3.社会意识具有相对独立性，社会意识有时会落后于社会存在，有时会先于社会存在而变化发展；4.社会意识对社会发展具有能动的反作用，落后的社会意识对社会的发展起到阻碍作用，先进的社会意识可以正确预见社会发展方向和趋势，对社会的发展起到积极的推动作用。</li><li><strong>生产力</strong>：生产力是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量。</li><li><strong>基本要素</strong>：劳动资料、劳动对象、劳动者</li><li><strong>生产关系</strong>：人们在物质生产过程中形成的不以人的意志为转移的经济关系。</li><li><strong>生产力和生产关系的相互作用</strong>：生产力和生产关系是社会生产不可或缺的两个方面。第一，生产力决定生产关系。第二，生产关系对生产力具有能动的反作用。生产关系和生产力的相互作用是一个过程，表现为二者的矛盾作用。二者的矛盾运动规律的原理有重要的理论和现实意义：1.否定了单纯以道德为评判历史功过的是非标准的思想体系；2.是马克思主义政党指定路线方针和政策的重要依据。</li><li><strong>经济基础</strong>：是指由社会一定发展阶段的生产力所决定的生产关系的总和。</li><li><strong>上层建筑</strong>：建立在一定经济基础上的意识形态以及与之相适应的制度、组织和设施。</li><li><strong>阶级</strong>：在历史上一定的社会生产经济体系中所处地位不同的集团。</li><li><strong>人类社会的基本矛盾</strong>：生产力和生产关系、经济基础和上层建筑之间的矛盾。</li><li><strong>经济基础与上层建筑的关系</strong>：相互影响，相互作用。经济基础决定上层建筑；上层建筑对经济基础具有反作用；经济基础与上层建筑的相互作用构成二者的矛盾运动；经济基础和上层建筑之间的内在联系构成了上层建筑一定要适应经济基础状况的规律。</li><li><strong>社会形态的内涵</strong>：社会形态是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。社会形态包括社会的经济形态、政治形态和意识形态，是三者具体的历史的统一。</li><li><strong>社会基本矛盾</strong>：1.生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量。2.生产力是社会进步的根本内容，是衡量社会进步的根本尺度。3.社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展。</li><li><strong>主要矛盾和基本矛盾</strong>：社会基本矛盾和社会主要矛盾。二者不是同一概念，也不是同一层次。社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展；社会主要矛盾是社会基本矛盾的具体体现。</li><li><strong>科学技术在社会发展中的作用</strong>：1.科技革命是推动经济和社会发展的强大杠杆：对生产关系产生了深刻影响，对生产方式产生了巨大影响，促进了思维方式的改变；2.科学技术能够通过促进经济和社会发展造福于人类。</li><li><strong>阶级斗争</strong>：是社会基本矛盾在阶级社会的直接体现，是阶级社会发展的直接动力。</li></ul><h2 id="资本主义">资本主义</h2><ul><li><strong>劳动二重性</strong>：1.具体劳动：生产一定使用价值的具体形式的劳动；2.抽象劳动：人的脑力和体力耗费。3.二者在时间和空间上统一，是统一劳动过程不可分割的两个方面；另一方面，反映劳动的不同属性（具体to自然抽象to社会）。</li><li><strong>商品二因素</strong>：使用价值和价值。对立统一：对立表现在二者相互排斥不可兼得，统一表现在作为商品必须同时具有使用价值和价值两个因素。</li><li><strong>商品经济</strong>：不是从来就有的，而是在一定历史条件下，作为自然经济的对立物而产生和发展的。</li><li><strong>资本原始积累</strong>：以暴力手段是生产者和生产资料分离，资本迅速集中于少数人手中，资本主义得以迅速发展的历史过程。</li><li><strong>资本总公式和商品交换之间的矛盾</strong>：按照等价交换原则，交换不能创造新价值，而资本总公式表明资本在流通过程中创造了新价值，关键在于劳动力成为商品。</li><li><strong>剩余价值</strong>：剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值。</li><li><strong>绝对剩余价值</strong>：是指在必要的劳动时间不变的条件下，由于延长工作日的长度或提高劳动强度而生产的剩余价值。</li><li><strong>相对剩余价值</strong>：是指在工作日长度不变的条件下，通过缩短必要劳动时间而延长剩余劳动时间所生产的剩余价值。</li><li><strong>资本积累</strong>：把剩余价值转化为资本，或者说，剩余价值的资本化。</li><li><strong>劳动力成为商品的基本条件</strong>：劳动者在法律上是自由人，能把自己的劳动力当作自己的商品来支配，劳动者没有其他生产资料，没有生产资料来源，因而不得不一靠出卖劳动力为主。</li><li><strong>资本主义基本矛盾</strong>：生产社会化和生产资料资本主义私人占有之间的矛盾。</li><li><strong>资本主义经济危机的本质特征</strong>：生产过剩（一种相对过剩）。</li></ul><h2 id="资本主义发展和趋势">资本主义发展和趋势</h2><ul><li><strong>垄断</strong>：指少数资本主义大企业为了获得高额利润，通过相互协议或者联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制。垄断是从自由竞争中形成的，是作为自由竞争的对立面产生的，但是，垄断并不能消除竞争，反而使竞争变得更加复杂和剧烈。垄断没有消除产生竞争的经济条件；垄断过程需要通过竞争来维持；社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产全部包下来。</li><li><strong>经济全球化的表现</strong>：生产全球化、贸易全球化、金融全球化。</li><li><strong>动因</strong>：科学技术的进步和生产力的发展为经济全球化提供了坚实的物质基础和根本的推动力；跨国公司的发展为经济全球化提供了适宜的企业组织形式；各国经济体制的变革和国际经济组织的发展为经济全球化提供体制和组织保障。</li><li><strong>影响</strong>：1.积极作用：为发展中国家提供先进技术和管理经验，提供更多的就业机会，推动发展中国家的贸易发展，促进发展中国家跨国公司的发展。2.消极作用：发达国家和发展中国家在经济全球化过程中的地位和收益不平等，加剧了发展中国家的环境污染，一定程度上增加了经济风险。</li></ul><h2 id="社会主义从空想到科学">社会主义（从空想到科学）</h2><ul><li><strong>马克思剩余价值学说的意义</strong>：剩余价值学说深刻揭示了资本家剥削工人的秘密，揭示了无产阶级与资产阶级利益的根本对立，从而科学论证了无产阶级肩负的推翻资本主义旧世界建设社会主义新世界的历史使命，使人们找到了变革资本主义旧社会的力量和通向社会主义新社会的途径。</li><li><strong>唯物史观</strong>：深刻揭示了人类历史发展的一般规律，揭示了人民群众的历史主体作用，揭示了阶级斗争在阶级社会发展中的巨大作用，从而把人们对社会主义的追求建立在对社会发展客观规律科学认识的基础上，克服了空想社会主义者不懂得历史规律的根本缺陷。</li><li><strong>科学社会主义核心命题</strong>：资本主义必然灭亡，社会主义必然胜利。两个必然的根本依据是人类社会发展规律。两个绝不会是指：“无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的。”要把两个必然和两个绝不会联系起来全面把握。</li></ul>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>general course</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>calculus</title>
    <link href="/2023/12/19/calculus/"/>
    <url>/2023/12/19/calculus/</url>
    
    <content type="html"><![CDATA[<blockquote><p>实测部分浏览器可能无法识别Latex公式，建议使用GoogleChrome或移步知乎食用！</p></blockquote><blockquote><p>本文搬运自本人知乎，原文链接为:https://zhuanlan.zhihu.com/p/627529870</p></blockquote><h1 id="常数项级数">常数项级数</h1><h2id="从正项级数的收敛判定到任意项级数的收敛判定">从正项级数的收敛判定到任意项级数的收敛判定</h2><h3 id="正项级数的收敛判定8种方法">正项级数的收敛判定（8种方法）</h3><p>如下：</p><p>1.定义法；2.柯西收敛；3.前n项部分和有上界；4.比较判别法；5.比较判别法（极限版本）（+p级数=阶估法）；6.比值（达朗贝尔）判别法；7.积分判别法；8.柯西根值.</p><h3id="任意项级数的收敛判定6种方法">任意项级数的收敛判定（6种方法）</h3><p>如下：1.定义法；2.柯西收敛；3.绝对收敛；4.使用柯西根值或达朗贝尔判别不绝对收敛时发散;5.迪利克雷判别法和阿贝尔判别法；6.交错级数的莱布尼茨判别法.</p><blockquote><p>先看必要条件是否满足（通项趋于0），再看是否绝对收敛（正项级数），若不绝对收敛，再看是否发散（迪阿莱）.</p></blockquote><h3 id="正部级数负部级数">正部级数&amp;负部级数</h3><p>定义：</p><p><span class="math display">\[a_n = a_n^+ - a_n^- ,|a_n|=a_n^+ + a_n^-;\]</span></p><p><span class="math display">\[a_n^+ = \frac{a_n+|a_n|}{2},a_n^-= \frac{|a_n|-a_n}{2}.\]</span></p><h3 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h3><p>几个定理：</p><p><strong>TH1.</strong> 级数绝对收敛必然收敛.</p><p><strong>TH2.</strong> 级数<span class="math inline">\(\Sigma _{n=1} ^\infty a_n\)</span>绝对收敛的充要条件即为正部级数和负部级数均收敛.</p><p><strong>TH3.</strong> 绝对收敛级数可任意更序，和不变.</p><p><strong>TH4.</strong>（黎曼定理）对于条件收敛的级数，可更换其次序使其收敛于任意给定数或以任意形式发散.</p><h3 id="阿贝尔变换几何直观">阿贝尔变换（几何直观）</h3><p><span class="math display">\[\Sigma_{i=1}^n a_ib_i=a_nB_n -\Sigma_{i=1}^{n-1}(a_{i+1}-a_i)B_i\]</span></p><h3 id="迪利克雷判别法和阿贝尔判别法">迪利克雷判别法和阿贝尔判别法</h3><p>前提条件：</p><p><span class="math display">\[\Sigma u_n =\Sigma a_nb_n\]</span></p><p>迪：</p><p><span class="math display">\[\{a_n\} 单调，且lim_{n\rightarrow\infty} a_n=0\]</span></p><p><span class="math display">\[\{b_n\} 的前n项部分和序列有界\]</span></p><p>阿：</p><p><span class="math display">\[\{a_n\} 单调有界\]</span></p><p><span class="math display">\[\{b_n\} 收敛\]</span></p><h3 id="交错级数">交错级数</h3><p><span class="math display">\[\Sigma (-1)^{n+1} u_n , u_n&gt;0\]</span></p><h3 id="交错级数的莱布尼茨判别法">交错级数的莱布尼茨判别法</h3><p>若<span class="math inline">\(u_n\geq u_{n+1} , lim_{n\rightarrow\infty}u_n=0\)</span>,则收敛，其和<span class="math inline">\(S\lequ_1.\)</span></p><h2 id="几道例题">几道例题:</h2><blockquote><p><spanclass="math inline">\(\Sigma\frac{(-1)^n}{\sqrt{n}-(-1)^n}\)</span>(有理化，发散)</p></blockquote><blockquote><p><span class="math inline">\(\Sigma sinnx\)</span> (sin(x/2))</p></blockquote><h1 id="广义积分">广义积分</h1><h2 id="敛散性的判定">敛散性的判定</h2><p>1.柯西收敛；2.比较判别法（非负）&amp;极限形式；3.阶估法（非负）（两个重要的广义积分）；4.绝对收敛定理；5.迪利克雷判别法.</p><h2 id="迪利克雷判别法">迪利克雷判别法</h2><p><spanclass="math inline">\(判定\int_a^{+\infty}f(x)g(x)收敛：\)</span></p><p>条件：</p><p><spanclass="math inline">\(\int_a^xf(x)dx在[a，+\infty)上有界,g(x)在[a,+\infty)上单调且趋于零\)</span></p><p>证明：</p><p>使用积分第二中值定理.</p><h2 id="tips">TIPS</h2><p>1.当<spanclass="math inline">\(f(x)\)</span>非负且单调递减时，可以用使用积分判别法转化为判定相应级数的敛散性.</p><p>2.广义积分收敛时，被积函数未必趋于零.</p><p>(eg.<spanclass="math inline">\(\int_1^{+\infty}sin(x^2)dx\)</span>).</p><p>3.上下限之间只有一个奇点，多个奇点要将广义积分进行拆分.</p><h2 id="几道例题-1">几道例题</h2><blockquote><p><spanclass="math inline">\(\int_1^{+\infty}sin(x^2)\)</span>(换元)</p></blockquote><blockquote><p><spanclass="math inline">\(\int_0^{+\infty}|\frac{sinx}{x}|dx\)</span>(<spanclass="math inline">\(1.\geq\frac{sin^2x}{x};2.\int_{k\pi}^{(k+1)\pi}|\frac{sinx}{x}|dx\)</span>)</p></blockquote><h1 id="函数项级数">函数项级数</h1><h2 id="一些概念">一些概念</h2><p>一般项/通项 部分和函数 收敛点 发散点 收敛域 发散域 和函数</p><h2 id="一句话">一句话</h2><p>要讨论函数项级数的收敛、发散、绝对收敛、绝对发散，只需要将<spanclass="math inline">\(x\)</span>任意固定，再应用常数项级数的一切有关敛散性定理.</p><h2 id="幂级数">幂级数</h2><h3id="阿贝尔第一定理从收敛到绝对收敛">阿贝尔第一定理（从收敛到绝对收敛）</h3><p>1.如果幂级数<span class="math inline">\(\Sigmaa_nx^n\)</span>在点<spanclass="math inline">\(x=x_0(x_0\neq0)\)</span>收敛，则它在区间<spanclass="math inline">\(|x|&lt;|x_0|\)</span>中绝对收敛；</p><p>2.如果幂级数<span class="math inline">\(\Sigmaa_nx^n\)</span>在点<spanclass="math inline">\(x=x_1\)</span>发散，则在满足<spanclass="math inline">\(|x|&gt;|x_1|\)</span>的点上都发散.</p><h3 id="收敛半径的存在性">收敛半径的存在性</h3><p>如果幂级数具有非零的收敛点与发散点，则必存在一个确定的非负数，使得当<spanclass="math inline">\(|x|&lt;R\)</span>时，级数绝对收敛；而当<spanclass="math inline">\(|x|&gt;R\)</span>时级数发散.</p><h3 id="求收敛半径">求收敛半径</h3><p><span class="math display">\[lim_{n \rightarrow\infty}|\frac{a_n}{a_{n+1}}|\]</span></p><p><span class="math display">\[\lim_{n \rightarrow\infty }\frac{1}{|a_n|^{\frac{1}{n}}}\]</span></p><h3 id="tips-1">TIPS</h3><p>关于幂级数的很多结论都是针对标准形式的，因此会出现一些典型问题比如缺项，可换元解决，或直接依靠定义讨论.</p><h3 id="一道例题">一道例题</h3><blockquote><p>证明：若<span class="math inline">\(f\)</span>是<spanclass="math inline">\([a,+\infty)\)</span>上的单调函数，且<spanclass="math inline">\(\int_a^{+\infty}f(x)dx\)</span>收敛，则<spanclass="math inline">\(lim_{x\rightarrow +\infty}f(x)=0\)</span>，且<span class="math inline">\(f(x)=o(1/x),x\rightarrow+\infty.\)</span></p></blockquote><blockquote><p>思路：1.证有极限-&gt;证有界;2.证极限为0-&gt;反证;3.证高阶小量-&gt;积分中值定理&amp;夹逼.</p></blockquote><h2 id="一致收敛函数项级数的分析性质">一致收敛函数项级数的分析性质</h2><h3 id="一致收敛">一致收敛</h3><h4 id="直观">直观</h4><p>收敛速度可以总体控制.</p><h4 id="定义">定义</h4><p><span class="math inline">\(\{f_n(x)\}\rightrightarrows f(x) ,x\inI\iff\forall\epsilon&gt;0,\exists N&gt;0,n&gt;N,|f_n(x)-f(x)|&lt;\epsilon,x \in I .\)</span></p><p><span class="math inline">\(\{\Sigma u_n(x)\}\rightrightarrows S(x),x\in I.\)</span>$ &gt;0,N&gt;0, n&gt;N,|u_1(x)+..+u_n(x)-S(x)|&lt;,xI.$</p><p><span class="math inline">\(\iff\forall\epsilon &gt;0, \existsN&gt;0,n&gt;N,\forall p\in N,|u_{n+1}(x)+...+u_{n+p}(x)|&lt;\epsilon,x\in I\)</span></p><p><span class="math inline">\(\iff lim_{n\rightarrow\infty}\ sup_{x\inI}|S_n(x)-S(x)|=0.\)</span></p><blockquote><p>上确界和柯西准则在证明不一致收敛时比较好用.</p></blockquote><h4 id="判定">判定</h4><p>M判别法:</p><blockquote><p>数项级数一致收敛.</p></blockquote><p><span class="math display">\[对 \Sigma u_n(x),若：|u_n(x)|&lt;a_n,\forall x\in I  ; \Sigma a_n 收敛\]</span></p><p><span class="math display">\[则 \Sigma u_n 收敛且一致收敛.\]</span></p><blockquote><p>Pf.柯西收敛准则.</p></blockquote><p>迪利克雷判别法：</p><p>若：</p><p><span class="math display">\[1.对区间I上每一个固定的x,数列\{a_n(x)\}单调且一致趋于零;\]</span></p><p><span class="math display">\[2.函数项级数\Sigma b_i(x)的部分和数列\{B_n(x)\}在I上一致有界.\]</span></p><p>则：</p><p><span class="math display">\[\Sigma a_ib_i在I上一致收敛.\]</span></p><p>阿贝尔判别法:</p><p>若:</p><p><span class="math display">\[1.对区间I上每一个固定的x,数列\{a_n(x)\}单调且一致有界;\]</span></p><p><span class="math display">\[2.函数项级数\Sigma b_i(x)在I上一致收敛.\]</span></p><p>则:</p><p><span class="math display">\[\Sigma a_ib_i在I上一致收敛.\]</span></p><h3 id="关于连续性">关于连续性</h3><p><span class="math display">\[若u_n(x)(n=1,2,...)在[a,b]上连续；\Sigma u_n(x)\rightrightarrowsS(x),x\in [a,b].\]</span></p><p><span class="math display">\[则S(x)在[a,b]上连续.\]</span></p><blockquote><p>Pf.搭桥.<span class="math inline">\(S(x)-S_n(x)\)</span>,<spanclass="math inline">\(S_n(x)-S_n(x_0)\)</span>,<spanclass="math inline">\(S_n(x_0)-S(x_0)\)</span>.</p></blockquote><blockquote><p>实际上是两种极限次序的交换.</p></blockquote><h3 id="逐项求积分">逐项求积分</h3><p><span class="math display">\[若u_n(x)(n=1,2,...)在[a,b]上连续；\Sigma u_n(x)\rightrightarrowsS(x),x\in [a,b].\]</span></p><p><span class="math display">\[则S(x)在[a,b]上可积，并且可逐项求积分,\int_a^b\Sigmau_n(x)dx=\int_a^bS(x)dx=\Sigma\int_a^b u_n(x)dx.\]</span></p><blockquote><p>Pf.<span class="math inline">\(r_n(x)\rightrightarrows0\)</span>.</p></blockquote><h3 id="逐项求导">逐项求导</h3><p>若：</p><p><span class="math display">\[1.u_n(x)在[a,b]连续可导;\]</span></p><p><span class="math display">\[2.\Sigma u_n(x)\rightarrow S(x),x\in [a,b]；\]</span></p><p><span class="math display">\[3.\Sigma u_n^{&#39;}(x)\rightrightarrows U(x),x\in[a,b].\]</span></p><p>则:</p><p><span class="math display">\[S(x)在[a,b]上连续可导，并且可逐项求导，即S^{&#39;}(x)=U(x).\]</span></p><blockquote><p>注意，以上关于连续性、逐项积分、逐项求导的讨论都是在闭区间.</p></blockquote><h3 id="内闭一致收敛">内闭一致收敛</h3><p>若<span class="math inline">\(\Sigmau_n(x)\)</span>在开区间的任意一个闭子区间都一致收敛，则成为其在区间<spanclass="math inline">\(I\)</span>上内闭一致收敛.</p><blockquote><p>连续性和逐项求导可在内闭一致区间上进行推广.</p></blockquote><h2 id="幂级数的分析性质">幂级数的分析性质</h2><h3 id="阿贝尔第二定理">阿贝尔第二定理</h3><p>已知:</p><p><span class="math display">\[幂级数\Sigma a_n x^n的收敛半径为R&gt;0\]</span></p><p>有:</p><p><span class="math display">\[（1）幂级数在(-R,R)上内闭一致收敛\]</span></p><p><span class="math display">\[（2）若在右端点R出收敛，则对\forall0&lt;\delta&lt;2R,幂级数在[-R+\delta,R]上一致收敛\]</span></p><p><span class="math display">\[（3）左端点类似（2）\]</span></p><blockquote><p>Pf.（1）M判别法；（2）（3）阿贝尔.</p></blockquote><h3 id="幂级数的分析性质-1">幂级数的分析性质</h3><p>和函数在收敛域内连续、可逐项积分、可逐项求导.逐项求导或求积分后收敛半径不变但端点的收敛性未必.</p><p>推论：</p><ul><li>级数<spanclass="math inline">\(\Sigma_{n=1}^{\infty}na_nx^{n-1}\)</span>,<spanclass="math inline">\(\Sigma_{n=0}^{\infty}\frac{a_n}{n+1}x^{n+1}\)</span>,<spanclass="math inline">\(\Sigma_0^{\infty}a_nx^n\)</span>有相同的收敛半径.</li><li>幂级数<spanclass="math inline">\(\Sigma_nx^n\)</span>的收敛半径为<spanclass="math inline">\(R\)</span>，则在<spanclass="math inline">\((-R,R)\)</span>内该级数可逐项求导数任意次，逐项求积分任意次.</li></ul><h2 id="函数的幂级数展开">函数的幂级数展开</h2><h3 id="函数幂级数展开的存在唯一性">函数幂级数展开的存在唯一性</h3><p>设函数<span class="math inline">\(f\)</span>在点a的邻域<spanclass="math inline">\(U=U(a,R)\)</span>上任意阶可导，则：</p><ul><li><p><span class="math inline">\(f\)</span>在<spanclass="math inline">\(U\)</span>上可展成泰勒级数的充要条件是函数<spanclass="math inline">\(f\)</span>所展成的泰勒公式中的余项<spanclass="math inline">\(r_n(x)\)</span>在<spanclass="math inline">\(U\)</span>上处处收敛于<spanclass="math inline">\(0\)</span>.即：</p><p><span class="math display">\[f(x)=\Sigma_{k=0}^{\infty}\frac{f^{(k)}(a)}{k!}(x-a)^k\ifflim_{n\rightarrow\infty}r_n(x)=0,\forall x\in U.\]</span></p></li><li><p>若<span class="math inline">\(f\)</span>可在<spanclass="math inline">\(U\)</span>上展成幂级数，则这个幂级数唯一，就是<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(a\)</span>的泰勒级数.</p></li></ul><h3 id="基本展开式">基本展开式</h3><ul><li><span class="math display">\[e^x=1+x+\frac{x^2}{2!}+...+\frac{x^n}{n!}+..., (-\infty &lt;x&lt;+\infty)\]</span></li><li><span class="math display">\[sinx=x-\frac{x^3}{3!}+...+(-1)^{m-1}\frac{x^{2m-1}}{(2m-1)!}+...,(-\infty&lt;x&lt; +\infty)\]</span></li><li><span class="math display">\[cosx=1-\frac{x}{2!}+...+(-1)^m\frac{x^{2m}}{(2m)!},(-\infty &lt;x&lt;+\infty)\]</span></li><li><span class="math display">\[(1+x)^\mu=1+\mux+\frac{\mu(\mu-1)}{2!}+...+\frac{\mu(\mu-1)...(\mu-n+1)}{n!}x^n+...,(-1&lt;x&lt;1,\forall\mu)\]</span></li></ul><blockquote><p>1/(1+x)和1/(1-x)展开式很常用</p></blockquote><ul><li><span class="math display">\[ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}+...+(-1)^{n-1}\frac{x^n}{n}+...,(-1&lt;x\leq1)\]</span></li></ul><blockquote><p>求一个函数的展开式的方法有二：一，利用定义直接求；二，利用求导求积分等运算和以上几个基本式子间接求出.</p></blockquote><h1 id="含参积分">含参积分</h1><h2 id="含参常义积分">含参常义积分</h2><h3 id="连续性">连续性</h3><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,y\inI\}\)</span>上连续，则<spanclass="math inline">\(\phi(y)=\int_a^bf(x,y)dx\)</span>在<spanclass="math inline">\(I\)</span>上连续，特别的，对<spanclass="math inline">\(y_0\in I\)</span>，有<spanclass="math inline">\(lim_{y\rightarrowy_0}\int_a^bf(x,y)dx=\int_a^blim_{y\rightarrowy_0}f(x,y)dx\)</span>,即极限和积分的运算顺序可以交换.</p><blockquote><p>推论：设函数<span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(a(y)\leq b(y),y\in I\)</span>上连续，函数<spanclass="math inline">\(a(y),b(y)\)</span>在<spanclass="math inline">\(I\)</span>上连续，则含参变量<spanclass="math inline">\(y\)</span>的积分 $ (y)=_{a(y)}^{b(y)}f(x,y)dx$在<span class="math inline">\(I\)</span>上连续.</p></blockquote><h3 id="积分号下求导">积分号下求导</h3><p>设<span class="math inline">\(f\)</span>与<spanclass="math inline">\(\frac{\partial f}{\partial y}\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,y\inI\}\)</span>上连续，则<span class="math inline">\(\phi\)</span>在<spanclass="math inline">\(I\)</span>上可导，且有（莱布尼茨公式）：</p><p><span class="math display">\[\phi^{&#39;}(y)=\frac{d}{dy}\int_a^bf(x,y)dx=\int_a^b\frac{\partial}{\partial y}f(x,y)dx,\forall y\in I.\]</span></p><p>设二元函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(\frac{\partial f}{\partial y}\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,\alpha\leqy\leq\beta\}\)</span>上连续,函数<spanclass="math inline">\(a(y),b(y)\)</span>在<spanclass="math inline">\([\alpha,\beta]\)</span>上有连续导数，且<spanclass="math inline">\(a\leq a(y)\leq b,a\leq b(y)\leqb\)</span>,则函数</p><p><span class="math display">\[\phi(y)=\int_{a(y)}^{b(y)}f(x,y)dx\]</span></p><p>在</p><p><spanclass="math inline">\([\alpha,\beta]\)</span>上具有连续导数，且有</p><p><span class="math display">\[\phi^{&#39;}(y)=\int_{a(y)}^{b(y)}f_y(x,y)dx+f(b(y),y)b^{&#39;}(y)-f(a(y),y)a^{&#39;}(y),y\in[\alpha,\beta]\]</span></p><h3 id="积分换序">积分换序</h3><p>条件同连续性.</p><h2 id="含参广义积分">含参广义积分</h2><h3 id="一致收敛-1">一致收敛</h3><p><span class="math display">\[\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,s.t.当A&gt;A_0,\forall y\in I,|\int_A^{+\infty}f(x,y)dx|&lt;\epsilon\]</span></p><p><span class="math display">\[\iff lim_{A\rightarrow+\infty}sum_{y\in I}|\int^{+\infty}_Af(x,y)dx|=0\]</span></p><p><span class="math display">\[\iff\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,\forallA_2&gt;A_1&gt;A_0 有|\int^{A_2}_{A_1}f(x,y)dx|&lt;\epsilon,\forall y\inI\]</span></p><h3 id="m判别法">M判别法</h3><p>条件：</p><ul><li><span class="math display">\[\exists M(x),s.t. |f(x,y)|\leq M(x),\forall (x,y)\in D\]</span></li><li><span class="math display">\[\int _a^b M(x)dx 收敛\]</span></li></ul><p>结论：</p><ul><li><span class="math display">\[\int_a^bf(x,y)dx 在I上一致收敛.\]</span></li></ul><h3 id="分析性质">分析性质</h3><p>针对连续性、积分号下求导、积分顺序交换的分析，此处略过.</p><h2 id="gamma函数和-b函数"><spanclass="math inline">\(\Gamma\)</span>函数和 B函数</h2><p>了解定义域、递推关系、不同形式、两者之间的关系、余元公式.</p><h2 id="傅里叶级数">傅里叶级数</h2><p>求傅里叶级数</p>]]></content>
    
    
    <categories>
      
      <category>notes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>math</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
