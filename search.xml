<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>图形学复习</title>
      <link href="/2025/06/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/"/>
      <url>/2025/06/11/%E5%9B%BE%E5%BD%A2%E5%AD%A6%E5%A4%8D%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1id="计算机图形学期末预习复习">计算机图形学期末<del>预习</del>复习</h1><blockquote><p>复习资料已上传至<ahref="https://box.nju.edu.cn/d/7bbbcbb2bef8413c9f5b/">njubox</a>.</p></blockquote><h2 id="样卷分析">样卷分析</h2><p>2021——2022年样卷围绕各个算法展开，涉及直线中点画线算法、直线裁剪算法、多边形扫描转换方法、旋转变换矩阵以及Hermite形式的参数三次多项式曲线.</p><h2 id="图元生成算法">图元生成算法</h2><h3 id="画线算法">画线算法</h3><p>画线，即将线段数字化为一组离散整数位置的过程。场景中的直线段通常由其两<strong>端点</strong>的坐标位置来定义，通过特定算法计算得到中间各点的位置并将颜色值存放到帧缓存的相应坐标位置，待视频控制器从帧缓存读出写入的颜色值并绘制于屏幕。</p><h4 id="dda算法">DDA算法</h4><p>从一个端点出发，以 <span class="math inline">\(\delta_x\)</span>（或<spanclass="math inline">\(\delta_y\)</span>）为步长，逐个计算各点坐标，对于<span class="math inline">\(y=mx+b\)</span>: + <spanclass="math inline">\(|m|&lt;1\)</span>: 以单位 <spanclass="math inline">\(x\)</span> 间隔取样.若从左端点出发，设置 <spanclass="math inline">\(\delta_x=1\)</span> ，则 <spanclass="math inline">\(y_{k+1}=y_k+m\)</span> ;若从右端点出发，设置 <spanclass="math inline">\(\delta_x=-1\)</span> ,则 <spanclass="math inline">\(y_{k+1}=y_k-m\)</span>. + <spanclass="math inline">\(|m|&gt;1\)</span>: 以单位 <spanclass="math inline">\(y\)</span> 间隔取样.若从下端点出发，设置 <spanclass="math inline">\(\delta_y=1\)</span>，则 <spanclass="math inline">\(x_{k+1}=x_k+\frac{1}{m}\)</span>;若从上端点出发，设置 <spanclass="math inline">\(\delta_y=-1\)</span>,则 <spanclass="math inline">\(x_{k+1}=x_k-\frac{1}{m}\)</span>.</p><h4 id="bresenham画线算法">Bresenham画线算法</h4><p>通俗来讲，Bresenham画线算法每次生成两个可能的像素位置，并从中选择一个更接近线路径的，相较于DDA中大量的浮点数运算，Bresenham算法使用整数增量，win！</p><p>以正斜率小于1的直线扫描转换过程为例，我们来思考Bresenham算法做了什么.假如在第k步我们已经确定了要显示的像素在<span class="math inline">\((x_k,y_k)\)</span> ，那么 <spanclass="math inline">\(y_{k+1} \in \{y_k,y_{k+1}\}\)</span> .我们需要衡量<span class="math inline">\(y_k,y_{k+1}\)</span>谁距离目标直线更近，于是我们计算 <spanclass="math inline">\(d_l,d_u\)</span>, 考虑到在 <spanclass="math inline">\(x_k+1\)</span> 处直线上 <spanclass="math inline">\(y\)</span> 坐标实为 <spanclass="math display">\[y=m(x_k+1)+b\]</span> , 那么我们有 <spanclass="math display">\[d_l=y-y_k=m(x_k+1)+b-y_k\]</span> 以及 <spanclass="math display">\[d_u=y_k+1-m(x_k+1)-b\]</span>,只需作差并判断正负我们就可知哪个像素点距离目标直线更近了：<spanclass="math display">\[d_l-d_u=2m(x_k+1)-2y_k+2b-1\]</span>. 又由于<span class="math inline">\(m=\frac{\Delta y}{\Delta x}\in(0,1)\)</span> ，我们希望避免浮点数运算，将上式乘上 <spanclass="math inline">\(\Delta x\)</span> ,于是我们就发明了决策变量：<span class="math display">\[p_k=\Deltax(d_l-d_u)=2\Delta y x_k -2 \Delta x y_k +c \]</span> ，其中 <spanclass="math inline">\(c=2\Delta y+(2b-1)\Delta x\)</span>. 同样的，在第<span class="math inline">\(k+1\)</span> 步，我们也有 <spanclass="math display">\[p_{k+1} = 2\Delta y x_{k+1} -2 \Delta x y_{k+1}+c \]</span>, 作差得 <span class="math display">\[p_{k+1}-p_k = 2\Deltay (x_{k+1}-x_k) -2 \Delta x (y_{k+1}-y_k) = 2\Delta y -2 \Delta x(y_{k+1}-y_k) \]</span>. 当 <spanclass="math inline">\(p_k&gt;0\)</span>,我们有 <spanclass="math inline">\(d_l&gt;d_u\)</span>, <spanclass="math inline">\(y_{k+1}=y_k+1\)</span> ， 有 <spanclass="math display">\[p_{k+1}-p_k = 2\Delta y -2 \Delta x \]</span>,否则有 <span class="math display">\[p_{k+1}-p_k = 2\Delta y\]</span> .直接计算 <span class="math display">\[p_0=\Delta x (d_l-d_u)=2\Deltay-\Delta x\]</span>. 至此我们发明了Bresenham画线算法!</p><blockquote><p><span class="math inline">\(0&lt;m&lt;1\)</span> 时的 Bresenham画线算法：</p><ol type="1"><li>输入线段的两个端点，并将左端点存储在 <spanclass="math inline">\((x_0, y_0)\)</span> 中；</li><li>将 <span class="math inline">\((x_0, y_0)\)</span>装入帧缓存，画出第一个点；</li><li>计算常量 <span class="math inline">\(\Delta x, \Delta y, 2\Deltay\)</span> 和$ 2y - 2x$，并得到决策参数的第一个值: <spanclass="math display">\[p_0 = 2\Delta y - \Delta x \]</span></li><li>从 <span class="math inline">\(k=0\)</span> 开始，在沿线路径的每个<span class="math inline">\(x_k\)</span> 处，进行下列检测：</li></ol><ul><li>如果 <span class="math inline">\(p_k &lt;0\)</span>，下一个要绘制的点是 <span class="math inline">\((x_k+1,y_k)\)</span>，并且 <span class="math display">\[p_{k+1} = p_k + 2\Deltay \]</span></li><li>否则，下一个要绘制的点是 <span class="math inline">\((x_k+1,y_k+1)\)</span>，并且<span class="math display">\[p_{k+1} = p_k +2\Delta y - 2\Delta x \]</span></li></ul><ol start="5" type="1"><li>重复步骤 4，共 <span class="math inline">\(\Delta x-1\)</span>次。</li></ol></blockquote><p>下面我们考虑一般的Bresenham画线算法.注意到xy平面各种八分和四分区域间的对称性:</p><figure><img src="/image/cg/bresenham_line.png"alt="各区域的Bresenham画线算法" /><figcaption aria-hidden="true">各区域的Bresenham画线算法</figcaption></figure><ul><li>斜率绝对值决定取样方向.<ul><li>大于1：<span class="math inline">\(y\)</span> 轴方向取样.</li><li>小于1：<span class="math inline">\(x\)</span> 轴方向取样.</li></ul></li><li>起始端点决定直线生成方向（也即相应坐标值增量的正负）.<ul><li>生成方向与坐标轴相同则增量为坐标值增量为正.</li><li>否则为反.</li></ul></li></ul><h3 id="圆生成算法">圆生成算法</h3><p>下面我们延续Bresenham画线算法的思想，尝试画圆.</p><p>如同画线算法，我们在每一步中以<strong>单位间隔</strong>取样,从两候选像素中找出距离目标圆更近的一个.对于圆心在<span class="math inline">\((x_c,y_c)\)</span> 半径为 <spanclass="math inline">\(r\)</span> 的圆来说，我们可以使用算法计算圆心在<span class="math inline">\((0,0)\)</span> 且半径同为 <spanclass="math inline">\(r\)</span>的圆的像素坐标，再经过简单的平移变换得到目标圆的像素坐标.因此，方便起见，算法只考虑圆心位于原点的圆.考虑到圆的对称性，我们只需要考虑第一象限中从<span class="math inline">\(x=0\)</span> 到 <spanclass="math inline">\(x=y\)</span> 的圆弧段（八分圆），在正 <spanclass="math inline">\(x\)</span>方向取单位步长，其他七个根据对称性求得.</p><p>首先定义圆函数 <span class="math display">\[f_c(x,y) = x^2+y^2-r^2\]</span>, 则任何点 <span class="math inline">\((x,y)\)</span>和圆的位置关系都可根据 <span class="math inline">\(f_c(x,y)\)</span>大于、小于或等于0来判断.下面定义决策参数 <spanclass="math display">\[p_k=f_c(x_k+1 , y_k - \frac{1}{2} )=(x_k+1)^2+(y_k-\frac{1}{2})^2-r^2\]</span>.</p><figure><img src="/image/cg/circ1.png"alt="沿圆路径取样位置xk+1上候选像素间的中点" /><figcaptionaria-hidden="true">沿圆路径取样位置xk+1上候选像素间的中点</figcaption></figure><p>如图所示，若 <span class="math inline">\(p_k&lt;0\)</span>则中点位于圆内，显然扫描线 <span class="math inline">\(y_k\)</span>上的像素更接近与目标圆，我们没理由不选择它；否则我们将选择位于 <spanclass="math inline">\(y_k-1\)</span> 的像素点.</p><p>惊喜的是，依靠增量运算，我们并不需要每次都进行讨厌的平方运算，考虑<spanclass="math display">\[p_{k+1}=f_c(x_{k+1}+1,y_{k+1}-\frac{1}{2})\]</span>，与<span class="math inline">\(p_k\)</span> 作差得 <spanclass="math display">\[p_{k+1}-p_k=2(x_k+1)+(y_{k+1}^2-y_k^2)-(y_{k+1}-y_k)+1\]</span>.</p><p>当 <span class="math inline">\(p_k&lt;0\)</span>，我们有 <spanclass="math inline">\(y_{k+1}=y_k\)</span> , <spanclass="math display">\[p_{k+1}-p_k = 2(x_k +1)+1=2x_{k+1}+1\]</span>; 当<span class="math inline">\(p_k&gt;0\)</span>，我们有 <spanclass="math inline">\(y_{k+1}=y_k-1\)</span>, <spanclass="math display">\[p_{k+1}-p_k =2x_{k+1}+1 - 2y_k -2=2x_{k+1}+1 -2y_{k+1} \]</span>, 而 <span class="math inline">\(2x_{k+1}\)</span> 和<span class="math inline">\(2y_{k+1}\)</span>的求值也可以通过增量的方式得到 <spanclass="math display">\[2x_{k+1}=2x_k+2,2y_{k+1}=2y_k-2\]</span>.对圆函数在起始位置<span class="math inline">\((x_0,y_0)=(0,r)\)</span>求值，就得到了初始决策参数 <spanclass="math display">\[p_0=f_c(1,r-\frac{1}{2}) =\frac{5}{4} -r\]</span> .</p><p>至此，我们发明了中点圆算法！</p><blockquote><p>中点圆算法： 1. 输入圆的半径 $ r $ 和圆心 <spanclass="math inline">\((x_c,y_c)\)</span>，并得到圆周（圆心在原点）上的第一个点：<br /><span class="math display">\[  (x_0, y_0) = (0, r)  \]</span></p><ol start="2" type="1"><li><p>计算决策参数的初始值：<br /><span class="math display">\[  p_0 = \frac{5}{4} - r  \]</span></p></li><li><p>从 $ k = 0 $ 开始，在每个 $ x_k $ 位置进行以下检测：<br /></p></li></ol><ul><li>如果 $ p_k &lt; 0 $，则下一个点为 <spanclass="math inline">\((x_{k+1}, y_k)\)</span>，并更新决策参数：<br /><span class="math display">\[p_{k+1} = p_k + 2x_{k+1} + 1\]</span><br /></li><li>否则，下一个点为 <span class="math inline">\((x_{k+1}, y_k -1)\)</span>，并更新决策参数：<br /><span class="math display">\[p_{k+1} = p_k + 2x_{k+1} + 1 - 2y_{k+1}\]</span><br />其中，$ 2x_{k+1} = 2x_k + 2 $ 且 $ 2y_{k+1} = 2y_k - 2 $。</li></ul><ol start="4" type="1"><li><p>确定在其他七个八分圆中的对称点。</p></li><li><p>将每个计算出的像素位置 <span class="math inline">\((x,y)\)</span> 平移到圆心 <span class="math inline">\((x_c, y_c)\)</span>的圆路径上：<br />$ x = x + x_c, y = y + y_c $</p></li><li><p>重复步骤 3 到步骤 5，直到 $ x y $。</p></li></ol></blockquote><h3 id="椭圆生成算法">椭圆生成算法</h3><p>还是依靠Bresenham算法的思想，我们现在开始尝试画椭圆.</p><p>类似中点圆算法，给定参数 <span class="math inline">\(r_x,r_y\)</span>和 <span class="math inline">\((x_c,y_c)\)</span>，首先确定以原点为中心的标准椭圆上的点 <spanclass="math inline">\((x,y)\)</span> ， 然后将这些点平移到以 <spanclass="math inline">\((x_c,y_c)\)</span> 为中心的椭圆上.如果希望显示不在标准位置的椭圆，只需要饶中心坐标旋转并对长轴和短轴重新定向.</p><p>考虑到椭圆的对称性，我们只需要在第一象限确定各像素点的位置.具体的，中心椭圆算法将以斜率为-1为界限，分成两部分应用于第一象限，如下图所示.在斜率绝对值小于1的区域在 <span class="math inline">\(x\)</span>方向取单位步长，在斜率绝对值大于1的区域在 <spanclass="math inline">\(y\)</span> 方向取单位步长来处理这个象限.</p><p>![椭圆处理的区域]{/image/cg/ellipse1.png}</p><p>定义椭圆函数 <spanclass="math display">\[f_e(x,y)=r_y^2x^2+r_x^2y^2-r_x^2r_y^2\]</span> ,我们令椭圆函数作为中点算法的决策参数，帮我们在两候选像素位置之间做决定.</p><p>具体的，从 <span class="math inline">\((0,r_y)\)</span> 开始，在<span class="math inline">\(x\)</span>方向上取单位步长直到区域1和区域2的分界处，然后转换成 <spanclass="math inline">\(y\)</span>方向的单位步长，从而覆盖第一象限中的剩余曲线段.为了判定我们在哪个区域，每一步都需要检测曲线的（切线）斜率值，椭圆的斜率可由曲线方程求导得到<span class="math display">\[\frac{dy}{dx}=-\frac{2r_y^2x}{2r_x^2y}\]</span> ， 而交界区域位置有 <spanclass="math inline">\(dy/dx=-1\)</span> ,从而有<spanclass="math display">\[2r_y^2x=2r_x^2y\]</span> ,也即当 <spanclass="math inline">\(2r_y^2x \geq 2r_x^2y\)</span>的时候，移出区域1进入区域2.</p><p>考虑区域1，如下图所示. 我们有 <spanclass="math display">\[p1_k=f_e(x_k+1,y_k-\frac{1}{2})=r_y^2(x_k+1)^2+r_x^2(y_k-\frac{1}{2})^2-r_x^2r_y^2\]</span>.当 <span class="math inline">\(p_1k&lt;0\)</span> 中点位于椭圆内，选择<span class="math inline">\(y_k\)</span> 上的像素更接近椭圆，否则选择<span class="math inline">\(y_k-1\)</span> 上的像素.</p><p>![椭圆轨迹上取样位置xk+1处候选像素中点]{/image/cg/ellipse2.png}</p><p>计算下一取样位置的决策参数，<span class="math display">\[p1_{k+1}=f_e(x_{k+1}+1,y_{k+1}-\frac{1}{2})=r_y^2[(x_k+1)+1]^2+r_x^2(y_{k+1}-\frac{1}{2})^2-r_x^2r_y^2\]</span> 从而 <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2(x_k+1)+r_y^2+r_x^2[(y_{k+1}-\frac{1}{2})^2-(y_k-\frac{1}{2})^2]\]</span>.</p><p>当 <span class="math inline">\(p1_k&lt;0\)</span> , <spanclass="math inline">\(y_{k+1}=y_k\)</span> , 有 <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2x_{k+1}+r_y^2\]</span> .当<span class="math inline">\(p1_k \geq 0\)</span> ， <spanclass="math display">\[p1_{k+1}-p1_k=2r_y^2x_{k+1}+r_y^2-2r_x^2y_{k+1}\]</span>.</p><p>事实上，计算增量只需要我们进行加减运算，这是因为 <spanclass="math inline">\(2r_y^2x\)</span> 和 <spanclass="math inline">\(2r_x^2y\)</span> 的值也可以通过增量得到.</p><p>在起始位置处，我们有 <spanclass="math display">\[2r_yx^2=0,2r_x^2y=2r_x^2r_y\]</span>， 决策参数<spanclass="math display">\[p1_0=r_y^2-r_x^2r_y+\frac{1}{4}r_x^2\]</span>.</p><p>对于区域二的分析和区域一类似，不同的是取样方向.</p><blockquote><p>中点椭圆绘制算法</p><ol type="1"><li><strong>输入参数</strong>：输入 <spanclass="math inline">\(r_x\)</span>、<spanclass="math inline">\(r_y\)</span> 和 <span class="math inline">\((x_c,y_c)\)</span>，得到中心在原点的椭圆的第一个点：</li></ol><p><span class="math display">\[  (x_0, y_0) = (0, r_y)  \]</span></p><ol start="2" type="1"><li><strong>区域1决策参数初值</strong>：</li></ol><p><span class="math display">\[  p1_0 = r_y^2 - r_x^2 r_y + \frac{1}{4} r_x^2  \]</span></p><ol start="3" type="1"><li><strong>区域1每个 <span class="math inline">\(x_k\)</span>位置处，<span class="math inline">\(k = 0\)</span>开始循环测试</strong>：</li></ol><ul><li><p>若 <span class="math inline">\(p1_k &lt;0\)</span>，选择像素：<span class="math inline">\((x_k+1, y_k)\)</span>且：</p><p><span class="math display">\[p1_{k+1} = p1_k + 2r_y^2 x_k + r_y^2\]</span></p></li><li><p>若 <span class="math inline">\(p1_k &gt;0\)</span>，选择像素：<span class="math inline">\((x_k+1,y_k-1)\)</span> 且：</p><p><span class="math display">\[p1_{k+1} = p1_k + 2r_y^2 x_k + 2r_y^2 - 2r_x^2 y_k + r_y^2\]</span></p></li><li><p>其中：</p><p><span class="math display">\[2r_y^2 x_{k+1} = 2r_y^2 x_k + 2r_y^2  \]</span></p><p><span class="math display">\[2r_x^2 y_{k+1} = 2r_x^2 y_k - 2r_x^2\]</span></p></li><li><p><strong>循环终止条件</strong>：<span class="math inline">\(2r_y^2x \geq 2r_x^2 y\)</span></p></li></ul><ol start="4" type="1"><li><strong>区域1最后点 <span class="math inline">\((x_l, y_l)\)</span>计算区域2参数初值</strong>：</li></ol><p><span class="math display">\[  p2_0 = r_y^2 (x_l + 1/2)^2 + r_x^2 (y_l - 1)^2 - r_x^2 r_y^2  \]</span></p><ol start="5" type="1"><li><strong>区域2每个 <span class="math inline">\(y_k\)</span>位置处，<span class="math inline">\(k = 0\)</span>开始循环测试</strong>：</li></ol><ul><li><p>若 <span class="math inline">\(p2_k &gt;0\)</span>，选择像素：<span class="math inline">\((x_k, y_k -1)\)</span> 且：</p><p><span class="math display">\[p2_{k+1} = p2_k - 2r_x^2 y_k + r_x^2\]</span></p></li><li><p>否则，选择像素：<span class="math inline">\((x_k + 1, y_k -1)\)</span> 且：</p><p><span class="math display">\[p2_{k+1} = p2_k + 2r_y^2 x_k + 2r_y^2 - 2r_x^2 y_k + r_x^2\]</span></p></li><li><p>与区域1相同的 x 和 y 增量计算。</p></li><li><p><strong>循环终止条件</strong>：至 <span class="math inline">\(r_y= 0\)</span></p></li></ul><ol start="6" type="1"><li><p><strong>对称</strong>：确定其它三个像素对称点。</p></li><li><p><strong>平移</strong>：将每个像素位置 <spanclass="math inline">\((x, y)\)</span> 平移到中心在 <spanclass="math inline">\((x_c, y_c)\)</span>的椭圆轨迹上，并按坐标值画点：</p></li></ol><p><span class="math display">\[  x = x + x_c, \quad y = y + y_c  \]</span></p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>来时路</title>
      <link href="/2025/04/12/%E6%9D%A5%E6%97%B6%E8%B7%AF/"/>
      <url>/2025/04/12/%E6%9D%A5%E6%97%B6%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="4a38b294c18dcfa43b6cc8bdac3c875fa91fab758030c6f48d71bd1158721690">993001887e685ce116fe55cfc0af2e19756f54c96abd96c28d4c8d8127f626140f320add533a9326e0f1a291a9080b8a79ee565a9b778841674a1a616e7cc2dc97041c2db7d13c403f1b98cb87bb1884db632afb6b9493b71368a717816466d173ad19e297792473946d021ec828e0c7ffdc163f42a5070510a0260b85d055f96516ae1eed27926a14c3010211c9ee7cc5d97befb726fee171907b8ad949a3e6cd92f88f34b3addbb24867b9bfc58c000a765ea64ef6310ba3e074de50b55b16943c6f4b95348057e5d2f093485414c3d025ae8a9f6c587bd678b49eeff355ea6b6577ffc4eee75011d5933387dbb8e4e8eb81250ee737d0af61aa2aa69381012ac1288269413cfe3538fce307cc9ae71d3e0ff66c8812a423fafdcd3f0e68a4ea6dc8afd25009ea1dd761aa5a408072c8ae4248912bbf8c77dc90bc01978fb577fb350e618d62f261db515191a2822460a84e9ca63b57ec81a03bfd4a4cf45b5be5a87075d5ec32fa3c38fcc0aee63fa4e1207663f1c8056873f4d68591522ba7eee9a7a03d6763c6d1e03fc9c2d6f389e45f483284e4285e6ef0edeafebb00bda2a07416928a679283fa129e3fff19</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>remote-ssh-to-wsl</title>
      <link href="/2025/04/11/remote-ssh-to-wsl/"/>
      <url>/2025/04/11/remote-ssh-to-wsl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自知乎，原文链接为https://zhuanlan.zhihu.com/p/357038111.</p></blockquote><p>最近希望能通过VScode的Remote-SSH插件来远程访问位于寝室Windows主机上的WSL，但是考虑到处于校园网环境，Windows主机的IP地址是动态分发的且<del>一直开机并不现实</del>，因此可能每次使用远程访问时都要重复操作，为避免遗忘，遂记录于此.</p><ol type="1"><li>在WSL2下重装ssh</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get remove openssh-server<br>sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>编辑sshd_config文件，修改几处配置</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/ssh/sshd_config<br><br>+++ Port 22<br>+++ PermitRootLogin <span class="hljs-built_in">yes</span><br>+++ PasswordAuthentication <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>编辑hosts.allow</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts.allow<br><br>+++ sshd: ALL<br></code></pre></td></tr></table></figure><ol start="4" type="1"><li>重启ssh服务</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo service ssh --full-restart<br><br>sudo systemctl <span class="hljs-built_in">enable</span> ssh <span class="hljs-comment">#设置开机自启</span><br></code></pre></td></tr></table></figure><ol start="5" type="1"><li>进行端口转发</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ifconfig <span class="hljs-comment">#在WSL，查看ip地址</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># in Win : 管理员cmd</span><br>netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=22 connectaddress=xxx.xxx.xxx.xxx connectport=22<br><br>netsh interface portproxy show all <span class="hljs-comment">#查看已设置的转发</span><br>netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=22 <span class="hljs-comment">#删除某一转发</span><br>netsh interface portproxy reset <span class="hljs-comment">#重置所有转发</span><br></code></pre></td></tr></table></figure><ol start="6" type="1"><li>cmd下查询Windows的内网IP地址</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ipconfig<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>通过Remote-SSH进行连接</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh root@xxx.xxx.xxx.xxx <span class="hljs-comment">#root可换成对应用户名</span><br></code></pre></td></tr></table></figure><blockquote><p>Windows防火墙设置默认会关闭22端口，需要开放防火墙设置：<code>Win+R</code>键入<code>control firewall.cpl</code>，新建入站规则即可.</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Happy-Birthday!</title>
      <link href="/2025/04/04/Happy-Birthday/"/>
      <url>/2025/04/04/Happy-Birthday/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="5d4e8e15c921a904d779959554b2a0dd66504dc711ed4ebe1801f68cac2e75ff">10d79030e8222445804370796b90fca1b3149e2c2a0f36d6b4ea04e548758c2111af2b8f18804544ae7edb4f8d5e33e48fc2a9e5d9e9f70e011ebca3a0dafa9769cd7daa121cdd45e0c91ba3361a09d36de5c6e0fb770a3ed9dd4c90afdc474230ef1020e3f05616cf54411d130d330d0a4ce5198ef3f64941d5c9594d0dc0a6122e77f4437062fb68ea3e7e79b2b82b9b48604a51b072c920e858bc130b529d5cb22b633e42c6ad6a697b6db93e9586058e36b1865c3d3280101deda27938cfc3ff9926d9d79cdc8a4f9144c8a06a72d6c84672c15d0832a35644787f1f8b9ee7c4ef6b4617227f33c68880d33652e2b9b118b97bde873f5554112119329d3f88a36ea527fe07c7f75d2c70ccefb3e288a05a8d5b234df5f5f0d2a9cda0660f3c0fe41ad418601cb0398b757ed0192b9231545d014692a6e872a64971e402f9deee6ace0e80ee062e884bd36370c13d7290527cc0416df2a64debc6eb01ac49e696d905a188a5f85e495d1c1c63cc1003a263b5c8f48636aa860bfbc14cad80794cf7be3eac3926ef77c5ff34d1db09a5c4c1a31026772936aeb5cc0b01802499103d5a73c60d9755c4ce9588bdb016f1c7a7ccdc0756d6cea85416691ad0b9fd355cc637ec21e6953928aecad5cd034deb0cd194df35af0569bb174ef50e69a10be1011f42a6b49b2bb0da289c783630cdcc9c0b918613e1fd939d7054e5a240ab9d1c55a27b72e030114ac122ac727df6377387fc56d40c93a65c5a6e31e27e9e83bcb7781de4a68b880fce78aa075ea4c2e3f2730eb23f00f828bf015e24a138249fbc153cad4cbc801682b1b508a6074bbd2a20df884d6d3d397d489d8103349f6857534038d63cf03b21e8742801da36bff61bc7db8f7555bbcd5c233bb635b32856025bc385a8db7683d1c3e178ae58447b78818562ac1c6830dc979841f242014ebee71eaabf499b4ff6a8eb0e22f1770a1ac0cc2d81081a10e5ea5ccb028e24161bd2bef71d7804588e4a94e4327b1afb98066c44a4f595068d2f7803038e0775df8593a07eaad1dd34e49eb98a1bb0376bde504709a6e51532ea20383567e16164fe55925936a279a88b1416d4a59accdccc9b11d151f81f9e308e8451113ac945f4aa509d05d582d9a7480b02d011307cf13abcbeffd333ceeedeffae655337e805e819eff7e00893a53a557104bdc77ad4edb1af7771f6468b624385ba5863eafc9f7eaff889b6af08aa237e54441fcbb40b63332e6f800d1f4d37d9a5ae97178386fe1ad920a30f47ce63ecdb01312dc37c834bea162f6e730f672ccf3fab55aa551a96c15de0d9c4707ef6b81d49e67e09973de7ec94ca608ab649a35037dc838d7b1ca9678b156d3c423ac2ed6806b66fd5ff428b15e3031e4a1025a8399e646af4d45ba72f8d16236dc06e6d353a811a1b9668b45be0c23d4383bf7013171d6fac360d276b20ab92539f1aeb074e45f040a5b96b927dea99f5b2111759b563c5aa55561b07351397221ff8ee1bdd36bfc4eb9961f11a49f0fcf8fcae9d53dec8d22fb804a80ebd1885ee3b65b1d2b458f43031ecd3d581fbbe7d361d2c993c9720784388ef669898dfc2dad805eb20f537276d4e963d1747bfcdefae7ed9ebc0633c02b43bfb7dc9</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Win安装“动手学深度学习”</title>
      <link href="/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/"/>
      <url>/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/</url>
      
        <content type="html"><![CDATA[<p>课程网站上的<ahref="https://zh.d2l.ai/chapter_installation/index.html">安装说明</a>已经很friendly了，但是并未列出Windows下的安装教程，谨在此记录我是如何在Win11下进行安装的.</p><h2 id="安装配置-miniconda">安装配置 Miniconda</h2><p>根据自己使用的python版本，在<ahref="https://repo.anaconda.com/miniconda/">miniconda</a>官网中选择对应的版本即可，如笔者使用的是<code>python 3.9</code>，则选择了<code>Miniconda3-py39_24.11.1-0-Windows-x86_64.exe</code>来下载并双击安装.</p><ul><li>建议勾选 Register Miniconda3 as my default Python 3.9...</li><li>不要忘记设置环境变量</li></ul><p>详细安装教程可参见<ahref="https://www.bilibili.com/opus/509341163774622170">bilibili</a>.</p><h2 id="其余即可参照课程网站">其余即可参照课程网站</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>生日快乐</title>
      <link href="/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
      <url>/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="eee754c680eee422755caa7629bf38031c9061637af1d9456d14c46fefceb82a">10d79030e8222445804370796b90fca1b3149e2c2a0f36d6b4ea04e548758c216c4f8b959fb5a2e4b286d076935415b6f0cdcf9e45f7294fc1e8b64cbc9380b3fe6487b2928a50342d05240db2caa35730dbb529bcc971a81652b3114321186ac79b1ecd9b95b4d8af574ecafaf902dd1cbca9697f1d3bb19746e3856145feeeb87114c2fe1d38a7856c22de22b34243a6d2c4f7ba1aca75e07b9da9838b071a16fd10387eb0db1d7778a621b36ea5c78bf0a7edba408b0a8d10d9f935292e294755990afd8f95b5c4cdc9b9993b21ac9fbf4ec994a8e762644a4eb4b6fca0342c855f1458eb8f9ffd947d55744c1a52044da75d3fcdb6716e661aa984a8f1d9234b5373cd1c347829812e01f0d0003b60610339d954448218226ec58ab9f0553a5a26ce57b9c40a5a0676355ce1157244924371f1623bee26ec46883ed60e139901d839cb35b3bbacac99bd0a32baaac5dfc8dd4c49e466b2d5b8cbaace0c0a36e0a0777bd98113acdf7af01737ea7f73f187a82cebf3ddbe544ff77749785399da7ffcfb65fbe1b2c2986ac0f0ba7dccadb0f871d3b0722f416e00ceb3709a64743fdc5ea6f76e018976de732b3e74adcf5f841e2e8e3594f9de30f57c9586b5a656b027904f3e1c8c4f0595f78c76b9d13a5d4aabcdf45ae62c0a06008ff1ca3deaef08b5236bdf64abb9fb07e8f09c2ab6f41fee57abc17e8664c7376bf8cd7ead7c606a699b496ebae5cd59c673318f29b2f595d363a967b94ea17ab72758d4de468858aa228c5dc1f5f95733d6d711b625b38d0f80eb9e58425ca8317614ba38197687af7f56b48296b289f04e816342073bdfb2393c8cc282c8d8ca9e2e9caae9e0ab604cf498313e4dc1b62ad28b42329117faec1bc3def578d6e20df8f5afaa2a5783af5aab5ce83f0194f732fe77f3f3b64105b9610e92e6013f65112c5ed58a2c7e36d738b7df75494c154a77c35b60d176b43cc8ac6eefccd55f033c6e167da696e86b42e4052f0522eb5b0827c8de001d1b38ceb7b8057b96037ad19d56a6c19ec04674312dae33efd9447846ec56cd7868dc5a93178979c22ee8708b3d72e08613e069408fa3f80922e297a9f5378239ca653132ee7edc6da005e3de65793f8c4983994eeffb89757434fb23ff747b3d5037598a7d310e1ac24f196bb4d84fb006f7ac67f39ce17709816c3fdac776ba5c4f30d942f2ff9e6390c4c0c381e47dcd0fe90726f1ba9e4f468abdc35d1f79aca9f47dd6ecdf8693727f8cddb3b3c95b139d693d84b561ffb1a1d163cf6e3ec35acad436a462322a938e24070375c44352aa0214dc61f2fac8df4f72de6983fe3d1d139275346e82732a16b7e93d514d3064c7ceea3070a03bbb7e70918245ad1d773896bdd17b4174de19bf5e4d4951501ec03dc083821a53c6d06e2631ed6e04c10d8b06cfb1f63799d868e4056d67459491c52b38092e5dfe8d436fa561efc75f139c2cf804c9a5293981ab297b8da1570fb2d961d392059861f6e941edf4688850eae78c1fd7c964d16ba51bfed11c0a7864fd9b92fa16246feeac091da290bf2223e6889a2b514d83124222b97481ea5ead8f93fbcc0675e9e93ffdcfa6c93ff761ac3df6ea504cd531313f1c1de75eea3018a15100</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CRYPTO</title>
      <link href="/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="消息认证">消息认证</h2><ul><li>消息认证的必要性</li><li>MAC<ul><li>定义</li><li>正确性与安全性要求</li><li>使用</li></ul></li><li>构造 secure MACs<ul><li>定长</li><li>CBC-MAC处理长消息</li></ul></li><li>AE<ul><li>定义</li><li>CCA安全</li><li>不可伪造加密</li><li>构造AE</li></ul></li></ul><h3 id="消息认证的必要性">消息认证的必要性</h3><p>安全的对话要确定消息发送方的身份和以及消息未被串改，仅加密在很多时候并不能确保这些.</p><h3 id="mac">MAC</h3><p>给我们的消息打一个tag！</p><h4 id="定义">定义</h4><p>消息认证码，即 MAC 是一个 PPT 算法组成的三元组 <spanclass="math inline">\(\Pi=(Gen,Mac,Vrfy)\)</span>: + 密钥生成算法: <spanclass="math inline">\(k \leftarrow Gen(1^n) , |k| \geq n\)</span>. +标签生成算法：<span class="math inline">\(t \leftarrow Mac_k(m)\ or\ t:= Mac_k(m), m\in \{0,1\}^*\)</span>. + 确定性的认证算法：<spanclass="math inline">\(b := Vrfy_k(m,t) , b=1 \ iff.\ m\ is\valid\)</span>.</p><h4 id="正确性与安全性要求">正确性与安全性要求</h4><p><strong>正确性</strong>：正确生成的MAC要被认可，即 <spanclass="math display">\[\forall n, k \leftarrow Gen(1^n), \forall m\in\{0,1\}^*, Vrfy_k(m,Mac_k(m))=1\]</span></p><p>当 <span class="math inline">\(Mac\)</span>是确定性算法时，一种典型的认证方法是重新计算tag并进行比对.</p><p><strong>安全性</strong>通过消息认证试验 <spanclass="math inline">\(Mac-forge_{\mathcal{A},\Pi}(n)\)</span> 来定义：1. <span class="math inline">\(k \leftarrow Gen(1^n)\)</span>对敌手保密. 2. 给 <span class="math inline">\(\mathcal{A}(1^n)\)</span>调用 <span class="math inline">\(Mac_k(\cdot)\)</span> 的能力，<spanclass="math inline">\(\mathcal{A}\)</span> 查询若干次，最终输出 <spanclass="math inline">\((m,t)\)</span>. 记 <spanclass="math inline">\(\mathcal{Q}\)</span> 为 <spanclass="math inline">\(\mathcal{A}\)</span> 所查询消息的集合. 3. <spanclass="math inline">\(\mathcal{A}\)</span> 成功也即 <spanclass="math inline">\(Mac-forge_{\mathcal{A},\Pi}(n)=1\)</span> 当且仅当<span class="math inline">\(Vrfy_k(m,t)=1 \wedge m \notin\mathcal{Q}\)</span>.</p><p>一个 MAC 是 secure 当且仅当 对于任何一个PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , 都存在可忽略的函数 <spanclass="math inline">\(negl\)</span> ，使得 <spanclass="math display">\[Pr[Mac-forge_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>secure保证了一个敌手不可能为一个先前未认证的<strong>新消息</strong>生成一个合法的tag, 但是并未保证敌手不能为已经认证的消息生成一个<strong>新的合法tag</strong>, 于是有了 strongly secure</p><p>消息认证试验 <spanclass="math inline">\(Mac-sforge_{\mathcal{A},\Pi}(n)\)</span> : 1.<span class="math inline">\(k \leftarrow Gen(1^n)\)</span> 对敌手保密.2. 给 <span class="math inline">\(\mathcal{A}(1^n)\)</span> 调用 <spanclass="math inline">\(Mac_k(\cdot)\)</span> 的能力，<spanclass="math inline">\(\mathcal{A}\)</span> 查询若干次，最终输出 <spanclass="math inline">\((m,t)\)</span>. 记 <spanclass="math inline">\(\mathcal{Q}\)</span> 为 <spanclass="math inline">\(\mathcal{A}\)</span> 所查消息和对应tag对的集合. 3.<span class="math inline">\(\mathcal{A}\)</span> 成功也即 <spanclass="math inline">\(Mac-sforge_{\mathcal{A},\Pi}(n)=1\)</span>当且仅当 <span class="math inline">\(Vrfy_k(m,t)=1 \wedge (m,t) \notin\mathcal{Q}\)</span>.</p><p>一个 MAC 是 strongly secure 当且仅当 对于任何一个PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , 都存在可忽略的函数 <spanclass="math inline">\(negl\)</span> ，使得 <spanclass="math display">\[Pr[Mac-sforge_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>显然典型的使用确定性的 secure 的 MAC 天然就是 strongly secure 的.</p><h4 id="如何使用-mac">如何使用 MAC</h4><p>What if Alice needs to send a message in Q, (i.e. was sentpreviously)? + Directly applying the MAC would cause repeated messagesto be rejected. + One can append a unique timestamp or nonce to eachmessage.</p><h3 id="构造-secure-的-mac">构造 secure 的 MAC</h3><h4 id="定长-mac">定长 MAC</h4><p>如果有函数 <span class="math inline">\(l\)</span> 使得对于任意 <spanclass="math inline">\(k \leftarrow Gen(1^n)\)</span>, <spanclass="math inline">\(Mac_k\)</span> 仅对 <spanclass="math inline">\(m\in \{0,1\}^{l(n)}\)</span> 上的消息有定义.</p><p>使用PRF！</p><p>令 <span class="math inline">\(F\)</span> 是 PRF . 对长为 n的消息定义一个定长的 MAC： + Mac : 输入密钥 <spanclass="math inline">\(k\in \{0,1\}^n\)</span> 和消息 <spanclass="math inline">\(m\in\{0,1\}^n\)</span>,输出标签 <spanclass="math inline">\(t:=F_k(m)\)</span>. + Vrfy: 输入密钥 <spanclass="math inline">\(k\in \{0,1\}^n\)</span> 消息 <spanclass="math inline">\(m\in \{0,1\}^n\)</span> 和标签 <spanclass="math inline">\(t\in\{0,1\}^n\)</span>,输出1当且仅当 <spanclass="math inline">\(t=F_k(m)\)</span>.</p><p>若 <span class="math inline">\(F\)</span> 是 PRF ，上述构造就是一个对长度为n的消息的 secure fixed-length MAC.</p><h4 id="处理长消息定长">处理长消息（定长）</h4><p>basic CBC-MAC: <span class="math inline">\(F\)</span> 是一个 PRF ，以及长度函数 <span class="math inline">\(l\)</span> + Mac : 输入 <spanclass="math inline">\(k \in \{0,1\}^n, m\in \{0,1\}^{n\cdotl(n)}\)</span> + 将 <span class="math inline">\(m\)</span> 分成 <spanclass="math inline">\(l(n)\)</span> 个长度为 <spanclass="math inline">\(n\)</span> 的块, + <spanclass="math inline">\(t_0:= 0^n\)</span>,对 <spanclass="math inline">\(i\)</span> 从 1 到 <spanclass="math inline">\(l(n)\)</span>, <span class="math inline">\(t_i :=F_k(t_{i-1} \oplus m_i)\)</span> + 输出 <spanclass="math inline">\(t_l\)</span> + Vrfy : 输入 <spanclass="math inline">\(k\in \{0,1\}^n, m, t\)</span>,输出1当且仅当 <spanclass="math inline">\(|m|=n\cdot l(n) \wedge t=Mac_k(m)\)</span>.</p><figure><img src="/image/crypto/basic-cbc.png" alt="basic-cbc mode" /><figcaption aria-hidden="true">basic-cbc mode</figcaption></figure><p>仍然仅能处理定长的消息！！！</p><h3 id="ae">AE</h3><p>消息的安全性和真实性都要！</p><h4 id="定义-1">定义</h4><p>一个私钥加密方案是 AE 的如果其是 CCA-secure 并且 unforgeable.</p><h4 id="cca安全">CCA安全</h4><p>CCA安全由CCA indistinguishability experiment <spanclass="math inline">\(PrivK_{\mathcal{A},\Pi}^{cca}(n)\)</span> 定义：1. <span class="math inline">\(k\leftarrow Gen(1^n)\)</span> 2.给敌手调用 <spanclass="math inline">\(Enc_k(\cdot),Dec_k(\cdot)\)</span>的权限，敌手输出 <span class="math inline">\(m_0,m_1\)</span>. 3. 加密<span class="math inline">\(c\leftarrowEnc_k(m_b),b\overset{\$}{\leftarrow}\{0,1\}\)</span>,将 <spanclass="math inline">\(c\)</span> 发送给敌手. 4. 敌手调用 <spanclass="math inline">\(Enc_k(\cdot),Dec_k(\cdot)\)</span>，但不允许直接调用 <span class="math inline">\(Dec_k(c)\)</span>，输出<span class="math inline">\(b&#39;\)</span>. 5. <spanclass="math inline">\(PrivK_{\mathcal{A},\Pi}^{cca}(n)=1\)</span>当且仅当 <span class="math inline">\(b=b&#39;\)</span>.</p><p>私钥加密方案 <span class="math inline">\(\Pi\)</span> 是 <spanclass="math inline">\(CCA-secure\)</span>的当且仅当对于任意PPT的敌手均有 <spanclass="math display">\[Pr[PrivK_{\mathcal{A},\Pi}^{cca}(n)=1]\leq\frac{1}{2} + negl(n).\]</span></p><p>可延展性（malleable) 在不知道 <span class="math inline">\(m\)</span>的前提下构造其密文. CCA安全推出了不可延展性.</p><h4 id="不可伪造性">不可伪造性</h4><p>不可伪造加密试验 <spanclass="math inline">\(Enc-Forge_{\mathcal{A},\Pi}(n)\)</span>: 1. <spanclass="math inline">\(k\leftarrow Gen(1^n)\)</span> 2. 敌手有调用 <spanclass="math inline">\(Enc_k(\cdot)\)</span> 的权限， 最终输出一个密文.3. <span class="math inline">\(m:=Dec_k(c)\)</span> ， <spanclass="math inline">\(Enc-Forge_{\mathcal{A},\Pi}(n)=1\)</span> 当且仅当密文合法且 <span class="math inline">\(m\)</span> 没被查过.</p><p>私钥加密方案 <span class="math inline">\(\Pi\)</span> 是 unforgeable当且仅当对于任意PPT的敌手均有 <spanclass="math display">\[Pr[Enc-Forge_{\mathcal{A},\Pi}(n)=1]\leq  negl(n).\]</span></p><h4 id="构造ae">构造AE</h4><p>加密后验证！</p><figure><img src="/image/crypto/encrpt-then-authenticate.png"alt="encrpt-then-authenticate" /><figcaption aria-hidden="true">encrpt-then-authenticate</figcaption></figure><p><span class="math inline">\(\Pi_E\)</span> 是CPA安全的，<spanclass="math inline">\(\Pi_M\)</span> 是strongly secureMAC,那么上述构造是AE.</p><h2 id="哈希函数及其应用">哈希函数及其应用</h2><ul><li>哈希函数<ul><li>加密哈希函数</li><li>定义域扩展</li><li>例子</li></ul></li><li>MAC 和 Hash<ul><li>使用哈希函数扩展 MAC 的定义域</li><li>使用哈希函数构造 MAC</li></ul></li><li>哈希函数的应用</li><li>针对哈希函数一般攻击</li></ul><h3 id="哈希函数">哈希函数</h3><p>将长串映射到短串！！！</p><h4 id="加密哈希函数">加密哈希函数</h4><p>能在加密应用中使用的符合密码学要求的哈希函数，一般满足如下要求： +collision resistant: It is difficult to find two different messages<span class="math inline">\(m\)</span> and <spanclass="math inline">\(m′\)</span> such that <spanclass="math inline">\(hash(m) = hash(m′)\)</span>. + “completelyunpredictable” (a.k.a. <strong>random oracles</strong>): The hashfunction is indistinguishable from a random mapping.</p><h5 id="抗碰撞哈希函数">抗碰撞哈希函数</h5><p>我们将键控哈希函数 <span class="math inline">\(H\)</span>视为一个以密钥 <span class="math inline">\(s\)</span> 和字符串 <spanclass="math inline">\(x\)</span> 为输入的函数 <spanclass="math inline">\(H^s(x)=H(s,x)\)</span>.</p><p>这儿的密钥 <span class="math inline">\(s\)</span>通常并不是随机采样出来的，而是由密钥生成算法 <spanclass="math inline">\(Gen\)</span> 生成的.此外，密钥 <spanclass="math inline">\(s\)</span> 并不保密...</p><p>输出长度为 <span class="math inline">\(l\)</span>的哈希函数是这么一对 PPT 的算法 (Gen,H), 满足: + <spanclass="math inline">\(s \leftarrow Gen(1^n)\)</span> + <spanclass="math inline">\(H\)</span> 以密钥 <spanclass="math inline">\(s\)</span> 和串 <spanclass="math inline">\(x\in\{0,1\}^*\)</span> 为输入，输出串 <spanclass="math inline">\(H^s(x) \in \{0,1\}^{l(n)}\)</span>.</p><p>如果 <span class="math inline">\(H^s\)</span> 仅对定长 <spanclass="math inline">\(l&#39;(n)&gt;l(n)\)</span>的输入有定义，我们就称之为定长哈希函数，也叫compression function.</p><h5 id="碰撞检测试验">碰撞检测试验</h5><p>The collision-finding experiment <spanclass="math inline">\(Hash\text{-}coll_{\mathcal{A},\Pi}(n)\)</span>: 1.<span class="math inline">\(s \leftarrow Gen(1^n)\)</span> 2. 给敌手<span class="math inline">\(s\)</span>, 敌手输出 <spanclass="math inline">\(x,x&#39;\)</span> 3. <spanclass="math inline">\(Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1\)</span>当且仅当 <span class="math inline">\(H^s(x)=H^s(x&#39;)\)</span></p><p>一个哈希函数 <span class="math inline">\(\Pi=(Gen,H)\)</span>是抗碰撞（collision resistant）的当且仅当对任意PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> ,都有<spanclass="math display">\[Pr[Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1]\leqnegl(n).\]</span></p><p>我们有时候省略掉 <span class="math inline">\(Gen\)</span> ，直接称<span class="math inline">\(H\)</span> 或 <spanclass="math inline">\(H^s\)</span>为抗碰撞哈希函数.此外，在实践中，有很多非键控抗碰撞哈希函数.</p><p><strong>更弱的抗碰撞</strong> + 2nd p.r. 给一个均匀随机的 <spanclass="math inline">\(x\)</span>，找 <spanclass="math inline">\(x&#39;\)</span> 使得 <spanclass="math inline">\(H^s(x)=H^s(x&#39;)\)</span>. + p.r.给一个均匀随机的 <span class="math inline">\(y\)</span>, 找 <spanclass="math inline">\(x&#39;\)</span> 使得 <spanclass="math inline">\(y=H^s(x&#39;)\)</span>.</p><p><span class="math display">\[ c.r. \Rightarrow 2nd\ p.r. \Rightarrowp.r.\]</span></p><h4 id="定义域扩展">定义域扩展</h4><p>使用定长的 c.r. 哈希来构造对任意长度的哈希.</p><p>Merkle-Damgard Transform: + “Partition and Padding”. + <imgsrc="/image/crypto/Partition_and_Padding.png"alt="Partition and Padding" /> + “Chained-Compressing”. + <imgsrc="/image/crypto/Chained-Compressing.png"alt="Chained-Compressing" /></p><blockquote><p>If (Gen, h) is collision resistant, the (Gen, H) is also collisionresistant. Pf. 考虑 <span class="math inline">\(|x|=|x&#39;|\)</span> 和<span class="math inline">\(|x|\neq|x&#39;|\)</span> 两种情况.</p></blockquote><h3 id="mac-与-哈希">MAC 与 哈希</h3><h4 id="hash-and-mac">Hash and MAC</h4><p>至此，我们有对定长消息做认证的MAC，也有将任意长度的串映射到定长串的Hash，二者的结合注定发生奇妙的化学反应.</p><p>令 <span class="math inline">\(\Pi=(Mac,Vrfy)\)</span> 是对长度为<span class="math inline">\(l(n)\)</span> 的消息的 MAC , <spanclass="math inline">\(\Pi_H=(Gen_H,H)\)</span> 是输出为定长 <spanclass="math inline">\(l(n)\)</span> 的哈希函数, 构造一个MAC <spanclass="math inline">\(\Pi&#39;=(Gen&#39;,Mac&#39;,Vrfy&#39;)\)</span>适用于任意长度的消息： + Gen': 输入 <spanclass="math inline">\(1^n\)</span> ，均匀选择 <spanclass="math inline">\(k\in\{0,1\}^n\)</span> , 运行 <spanclass="math inline">\(Gen_H(1^n)\)</span> 得到 <spanclass="math inline">\(s\)</span> , 密钥 <spanclass="math inline">\(k&#39;:=&lt;k,s&gt;\)</span>. + Mac': 输入密钥<span class="math inline">\(&lt;k,s&gt;\)</span> , 和任意长度的消息<span class="math inline">\(m\in\{0,1\}^*\)</span> , 输出 <spanclass="math inline">\(t \leftarrow Mac_k(H^s(m))\)</span>. + Vrfy':输入密钥 <span class="math inline">\(&lt;k,s&gt;\)</span> , 消息 <spanclass="math inline">\(m\in\{0,1\}^*\)</span> , tag <spanclass="math inline">\(t\)</span> , 输出1当且仅当 <spanclass="math inline">\(Vrfy_k(H^s(m),t)=1\)</span>.</p><p>如果 <span class="math inline">\(MAC\)</span> 是secure的 , 且 <spanclass="math inline">\(\Pi_H\)</span> 是抗碰撞的，那么上述构造是对任意长度的消息的一个secure的MAC.（Pf.两种情况分别规约到c.r.Hash和secure MAC上）</p><h4 id="hmac">HMAC</h4><figure><img src="/images/HMAC.png" alt="HMAC" /><figcaption aria-hidden="true">HMAC</figcaption></figure><h3 id="针对哈希的一般攻击">针对哈希的一般攻击</h3><p>由鸽巢原理，找 <span class="math inline">\(2^{l+1}\)</span>个值总能找到碰撞 <span class="math inline">\(\Theta(2^l)\)</span>,有没有可能少找一些期望有一定概率找到呢？</p><p>生日问题： &gt; If q people are in a room, what is the probabilitythat two of them have the same birthday?</p><p>若 <span class="math inline">\(y_1,...,y_q\)</span> 是从 <spanclass="math inline">\(\{1,...,N\}\)</span> 中均匀抽取的，当 <spanclass="math inline">\(q=\Theta(N^{1/2})\)</span> 时，有接近 1/2的概率存在碰撞.</p><blockquote><p>The above imply that a hash function with n-bit output is limited ton/2 bits of security.</p></blockquote><h2id="单向函数与硬核谓词hard-core-predicates">单向函数与硬核谓词(Hard-CorePredicates)</h2><ul><li>单向函数</li><li>OWF候选名单</li><li>硬核谓词<ul><li>任意OWF的硬核谓词</li></ul></li><li>使用OWF构造PRG</li></ul><h3 id="单向函数">单向函数</h3><p>什么是OWF？ + easy to compute + hard to invert</p><p>我们给出OWF的<strong>形式化定义</strong>.一个函数 <spanclass="math inline">\(f:\{0,1\}^* \rightarrow \{0,1\}^*\)</span> 是<strong>one-way</strong> 如果满足以下两个条件： 1. Easy to compute :存在PPT的算法 <span class="math inline">\(M_f\)</span> 来计算 f(多项式时间内可计算) 2. Hard to invert: <spanclass="math inline">\(\forall PPT \mathcal{A} ,Pr_{x\overset{\$}{\leftarrow}\{0,1\}^n}[\mathcal{A}(1^n,f(x))\inf^{-1}(f(x))]\leq negl(n)\)</span>.</p><p>注意，此处的 <spanclass="math inline">\(x\overset{\$}{\leftarrow}\{0,1\}^n\)</span>是均匀选取的，并且我们只要求给出原象，不求给出 <spanclass="math inline">\(x\)</span> 本身.</p><p>我们当然也有inverting experiment <spanclass="math inline">\(Invert_{\mathcal{A},f}(n)\)</span>: 1. 均匀选取<span class="math inline">\(x\in\{0,1\}^n\)</span> , 计算 <spanclass="math inline">\(y:=f(x)\)</span> 2. 敌手以 <spanclass="math inline">\(y\)</span> 为输入， 输出 <spanclass="math inline">\(x&#39;\)</span> 3. <spanclass="math inline">\(Invert_{\mathcal{A},f}(n)=1/ iff./f(x&#39;)=y\)</span></p><p>Hard to invert: 对任意PPT的敌手 <spanclass="math inline">\(\mathcal{A}\)</span> , <spanclass="math inline">\(Pr[Invert_{\mathcal{A},f}(n)=1]\leqnegl(n)\)</span>.</p><h3 id="owf的候选名单">OWF的候选名单</h3><p>事实上，我们并不知道是不是真的有OWF:(但是我们还是有些候选函数，至少我们至今没有发现PPT的算法来invert它们...</p><ul><li>整数分解</li><li>子集和问题</li><li>离散对数问题</li></ul><h3 id="硬核谓词hard-core-predicates">硬核谓词(Hard-CorePredicates)</h3><p><span class="math inline">\(f(x)\)</span> 是OWF意味着我们无法从 <spanclass="math inline">\(f(x)\)</span> 中还原出 <spanclass="math inline">\(x\)</span>, 但并不意味着 <spanclass="math inline">\(f(x)\)</span> 不会泄露 <spanclass="math inline">\(x\)</span> 的信息，就比如 <spanclass="math inline">\(f(x_1||x_2)=x_1||g(x_2)\)</span>.</p><p>我们定义函数 <span class="math inline">\(f\)</span> (不一定是OWF)的硬核谓词 <span class="math inline">\(hc:\{0,1\}^*\rightarrow\{0,1\}\)</span> 如果 <span class="math inline">\(hc\)</span>可以在多项式时间内计算，并且对任意PPT的 <spanclass="math inline">\(\mathcal{A}\)</span> 有 <spanclass="math display">\[Pr_{x\overset{\$}{\leftarrow}\{0,1\}^n}[\mathcal{A}(1^n,f(x))=hc(x)]\leq1/2 + negl(n)\]</span>.</p><p>这儿的 <spanclass="math inline">\(x\overset{\$}{\leftarrow}\{0,1\}^n\)</span>依然是均匀选取的.另外，我们没要求函数 <spanclass="math inline">\(f\)</span> 一定是OWF.</p><h4 id="任意owf的硬核谓词">任意OWF的硬核谓词</h4><p><strong>Goldreich-Levin Theorem</strong>: Assume one-way function(resp. permutation) exists. Then there exists a one-way function (resp.permutation) <span class="math inline">\(g\)</span> and a hard-corepredicate <span class="math inline">\(hc\)</span> of <spanclass="math inline">\(g\)</span>.</p><figure><img src="/image/crypto/Goldreich-Levin-Theorem.png"alt="Goldreich-Levin Theorem" /><figcaption aria-hidden="true">Goldreich-Levin Theorem</figcaption></figure><p>这里的 <span class="math inline">\(r\)</span> 是均匀随机选取的.</p><h3 id="使用owf构造prg">使用OWF构造PRG</h3><p>令 <span class="math inline">\(f\)</span> 是一个one-waypermutation，<span class="math inline">\(hc\)</span> 是 <spanclass="math inline">\(f\)</span> 的硬核谓词，那么 <spanclass="math inline">\(G(s)=f(s)||hc(s)\)</span> 是一个 PRG 扩展因子为<span class="math inline">\(l(n)=n+1\)</span>.</p><p>下面开始叠叠乐！</p><p>如果有一个 扩展因子为 <span class="math inline">\(n+1\)</span>的PRG，那么对任意多项式 <span class="math inline">\(poly\)</span>，存在PRG <span class="math inline">\(\hat{G}\)</span> 扩展因子为 <spanclass="math inline">\(poly(n)\)</span>.</p><figure><img src="/image/crypto/polyPRG.png" alt="polyPRG" /><figcaption aria-hidden="true">polyPRG</figcaption></figure><h2 id="数论与密码学困难度假设">数论与密码学困难度假设</h2><h3 id="基础知识">基础知识</h3><p>带余除法唯一表示：<span class="math display">\[a \in \mathbb{Z} , b\in \mathbb{Z}_+ , \exists \ unique\ q,r \in \mathbb{Z}, s.t.\ a=qb+r,\0\leq r\leq b.\]</span> <strong>最大公因数</strong> <spanclass="math display">\[a,b\in \mathbb{Z}_+, \exists X,Y \in \mathbb{Z},\s.t.\ Xa+Yb=gac(a,b).\]</span> 此外，<spanclass="math inline">\(gcd(a,b)\)</span> 是满足上述方程的最小正整数.</p><blockquote><p>欧几里得算法与拓展欧几里得算法.</p></blockquote><p>对大于等于1的整数 <span class="math inline">\(b,N\)</span> , <spanclass="math inline">\(b\)</span> 在模 <spanclass="math inline">\(N\)</span> 意义上有逆元当且仅当 <spanclass="math inline">\(gcd(b,N)=1\)</span>.</p><blockquote><p>拓展欧几里得算法.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>    x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>  y -= a / b * x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>群</strong>是一种代数结构，由一个集合 <spanclass="math inline">\(\mathbb{G}\)</span> 和定义在集合上的二元运算 <spanclass="math inline">\(\circ\)</span> 构成，满足: + 封闭性 + 结合律 +有逆元 + 有单位元 <img src="/image/crypto/group.png" alt="group" /></p><p>$N=_i p_i^{e_i} $ , 其中 <span class="math inline">\(p_i\)</span>是不同的素数， <span class="math inline">\(e_i\geq 1\)</span>, 那么有<span class="math inline">\(\phi(N)=\Pi_ip_i^{e_i-1}(p_i-1)\)</span>.</p><p><spanclass="math inline">\(g^0\overset{def}{=}1,g^{-m}\overset{def}{=}(g^{-1})^m\)</span>.</p><p>令 <span class="math inline">\(\mathbb{G}\)</span> 是有限群 <spanclass="math inline">\(m=|\mathbb{G}|\)</span> ,则 <spanclass="math inline">\(\forall g \in \mathbb{G} ,g^m=1\)</span>.</p><p><strong>Fermat-Euler Theorem</strong> <spanclass="math inline">\(\forall N&gt;1, a\in Z_N^* ,a^\phi(N)=1\ mod\N.\)</span></p><blockquote><p>Fermat-Euler Theorem 在计算模下求幂和非素性检测有用</p></blockquote><h3 id="中国剩余定理">中国剩余定理</h3><p>常用来解同余方程.</p><figure><img src="/image/crypto/CRT.png" alt="CRT" /><figcaption aria-hidden="true">CRT</figcaption></figure><blockquote><p>from <ahref="https://oi-wiki.org/math/number-theory/crt/#%E5%BC%95%E5%85%A5">OI-Wiki</a></p></blockquote><p>群论下的中国剩余定理：</p><figure><img src="/image/crypto/gCRT.png" alt="gCRT" /><figcaption aria-hidden="true">gCRT</figcaption></figure><p>求逆：</p><figure><img src="/image/crypto/crt-eg3.png" alt="crt-eg3" /><figcaption aria-hidden="true">crt-eg3</figcaption></figure><figure><img src="/image/crypto/crt-eg3-.png" alt="crt-eg3—" /><figcaption aria-hidden="true">crt-eg3—</figcaption></figure><h3 id="factoring-assumption">Factoring Assumption</h3><p><strong><spanclass="math inline">\(GenModulus(1^n)\)</span></strong>: + 输出 <spanclass="math inline">\((N,p,q)\)</span> + <spanclass="math inline">\(N=pq\)</span> + 除可忽略的概率 <spanclass="math inline">\(negl(n)\)</span> 外，<spanclass="math inline">\(p,q\)</span> 均为 <spanclass="math inline">\(n-bit\)</span> 素数.</p><p><strong>The factoring experiment</strong> <spanclass="math inline">\(Factor_{\mathcal{A},GenModulus}(n)\)</span>: 1.<span class="math inline">\((N,p,q) \leftarrow GenModulus(1^n)\)</span>2. 给 <span class="math inline">\(\mathcal{A}\)</span> <spanclass="math inline">\(N\)</span> , 要其输出 <spanclass="math inline">\(p&#39;,q&#39;\)</span> 3. <spanclass="math inline">\(Factor_{\mathcal{A},GenModulus}(n)=1\)</span> iff.<span class="math inline">\(N=p&#39;q&#39;\)</span>.</p><p><strong>Factoring is hard relative to GenModulus</strong> if for allPPT algorithms <span class="math inline">\(\mathcal{A}\)</span> thereexists a negligible function <span class="math inline">\(negl\)</span>such that <spanclass="math display">\[Pr[Factor_{\mathcal{A},GenModulus}(n)=1]\leqnegl(n).\]</span></p><p><strong>FactoringAssumption</strong>就是假设存在这么一个<strong>GenModulus</strong>使factoring是hard的.</p><h3 id="rsa-problem">RSA problem</h3><p><span class="math inline">\(GenRSA(1^n)\)</span> : + 输出 <spanclass="math inline">\((N,e,d)\)</span> + <spanclass="math inline">\(N\)</span> 是两个 <spanclass="math inline">\(n-bit\)</span> 素数的乘积 + <spanclass="math inline">\(gcd(e,\phi(N))=1, ed=1\ mod\ \phi(N)\)</span></p><p>The RSA experiment <spanclass="math inline">\(RSA-inv_{\mathcal{A},GenRSA}(n)\)</span>: 1. <spanclass="math inline">\((N,e,d)\leftarrow GenRSA(1^n)\)</span> 2. 均匀选取<span class="math inline">\(y\in \mathbb{Z}_N^*\)</span>. 3. 给 <spanclass="math inline">\(\mathcal{A}\)</span> <spanclass="math inline">\((N,e,y)\)</span> , 输出 <spanclass="math inline">\(x\in \mathbb{Z}_N^*\)</span> 4. <spanclass="math inline">\(RSA-inv_{\mathcal{A},GenRSA}(n)=1\)</span> iff.<span class="math inline">\(x^e=y\)</span>.</p><p><strong>The RSA problem is hard relative to GenRSA</strong> if forall PPT algorithms <span class="math inline">\(\mathcal{A}\)</span>there exists a negligible function <spanclass="math inline">\(negl\)</span> such that <spanclass="math display">\[Pr[RSA-inv_{\mathcal{A},GenRSA}(n)=1]\leqnegl(n).\]</span></p><p><strong>RSAAssumption</strong>就是假设存在这么一个<strong>GenRSA</strong>使RSAproblem是hard的.</p><h3 id="循环群">循环群</h3><figure><img src="/image/crypto/cyclic_group.png" alt="cyclic_group" /><figcaption aria-hidden="true">cyclic_group</figcaption></figure><h3 id="离散对数问题">离散对数问题</h3><p>对于 <span class="math inline">\(h\in \mathbb{G}\)</span> , <spanclass="math inline">\(\mathbb{G}\)</span> 是一个循环群, 存在唯一的 <spanclass="math inline">\(x\in Z_q, q=|\mathbb{G}|\)</span>, 使得 <spanclass="math inline">\(g^x=h\)</span>, 我们称 <spanclass="math inline">\(x\)</span> 是 <spanclass="math inline">\(h\)</span> 的离散对数 w.r.t <spanclass="math inline">\(g\)</span> , 写作 <spanclass="math inline">\(x=log_g\ h\)</span>.</p><p>离散对数问题就是求解一个在循环群上均匀抽取的元素的离散对数，可定义为以下试验.</p><p>The discrete-logarithm experiment <spanclass="math inline">\(DLog_\{\mathcal{A},\mathcal{G}\}\)</span>: 1.<span class="math inline">\((\mathbb{G},q,g)\leftarrow\mathcal{G}(1^n)\)</span>, 其中 <spanclass="math inline">\(\mathbb{G}\)</span> 是循环群, <spanclass="math inline">\(q=|\mathbb{G}|,\overline{||q||=n}\)</span>, <spanclass="math inline">\(g\)</span> 是生成元. 2. $h $ 3. 给 <spanclass="math inline">\(\mathcal{A}\)</span> 输入 <spanclass="math inline">\(\mathbb{G},q,g,h\)</span> , 其输出 <spanclass="math inline">\(x\in \mathbb{Z}_q\)</span>. 4. <spanclass="math inline">\(DLog_\{\mathcal{A},\mathcal{G}\}=1\)</span> iff.<span class="math inline">\(g^x=h\)</span>.</p><p>We say that <strong>the discrete-logarithm problem is hard relativeto <span class="math inline">\(\mathcal{G}\)</span> </strong>if for allPPT algorithms <span class="math inline">\(\mathcal{A}\)</span> thereexists a negligible function <span class="math inline">\(negl\)</span>such that <span class="math display">\[Pr[DLog_\{\mathcal{A},\mathcal{G}\}=1]\leq negl(n) .\]</span></p><p>离散对数假设就是假定存在这么一个 <spanclass="math inline">\(\mathcal{G}\)</span>.</p><h3 id="d-h-problem">D-H Problem</h3><p>The <strong>computational</strong> D-H (CDH) problem: Given <spanclass="math inline">\(g\)</span>, <spanclass="math inline">\(g^x\)</span> and <spanclass="math inline">\(g^y\)</span>, can you compute <spanclass="math inline">\(g^{xy}\)</span>?</p><p>The <strong>decisional</strong> D-H (DDH) problem: Given <spanclass="math inline">\(g\)</span>, <spanclass="math inline">\(g^x\)</span>, <spanclass="math inline">\(g^y\)</span>, and g^{xy}, can you differentiate<span class="math inline">\(g^{xy}\)</span> from a uniform random groupelement <span class="math inline">\(g^z\)</span>?</p><p>The D-H assumptions are assumptions that there exists instances ofCDH/DDH problem which are hard.</p><blockquote><p>Closed related to the discrete-logarithm problem, but <strong>notknown</strong> to be equivalent.</p></blockquote><h2 id="密钥管理与公钥加密变革">密钥管理与公钥加密变革</h2><h3 id="kdc">KDC</h3><p>A secure key-distribution protocol using a KDC:</p><figure><img src="/image/crypto/Needham-Schroeder.png"alt="Needham-Schroeder" /><figcaption aria-hidden="true">Needham-Schroeder</figcaption></figure><h3 id="d-h-key-exchange-protocol">D-H key-exchange protocol</h3><p>D-H key-exchange protocol 的构造如下，其中 <spanclass="math inline">\(\mathbb{G}\)</span> 是循环群, <spanclass="math inline">\(q=|\mathbb{G}|,||q||=n\)</span>, <spanclass="math inline">\(g\)</span> 是生成元$:</p><figure><img src="/image/crypto/D-H-exchange.png" alt="D-H-exchange" /><figcaption aria-hidden="true">D-H-exchange</figcaption></figure><p><strong>安全性</strong>：我们把脚本协议双方来往的所有信息记录下来丢给敌手，如果敌手在此加持下无法区分真正的密钥和一个随机抽取的假密钥，那么协议应该是安全的。具体的：</p><figure><img src="/image/crypto/KE.png" alt="KE" /><figcaption aria-hidden="true">KE</figcaption></figure><p>A key-exchange protocol <span class="math inline">\(\Pi\)</span> issecure in the presence of an eavesdropper if for all PPT adversaries<span class="math inline">\(\mathcal{A}\)</span> there is a negligiblefunction <span class="math inline">\(negl\)</span> such that <spanclass="math display">\[ Pr[KE^{eav}_{\mathcal{A},\Pi}(n) = 1] ≤ 1/2+negl(n).\]</span></p><figure><img src="/image/crypto/KEsecure.png" alt="KEsecure" /><figcaption aria-hidden="true">KEsecure</figcaption></figure><blockquote><p>我们在这儿使用了KE试验的变体，证明时将DDH问题规约到KE上来.</p></blockquote><h2 id="公钥加密">公钥加密</h2><h3 id="定义-2">定义</h3><p>公钥加密方案是一个PPT算法的三元组(Gen,Enc,Dec),其中Gen生成一对密钥(pk,sk),Enc使用公钥pk进行加密,Dec则使用私钥sk进行解密.具体的<strong>定义</strong>见下图：</p><figure><img src="/image/crypto/public-key_encryption.png"alt="public-key_encryption" /><figcaption aria-hidden="true">public-key_encryption</figcaption></figure><h3 id="安全性">安全性</h3><h4 id="cpa">CPA</h4><p>在下图所定义的EAV试验中，敌手 <spanclass="math inline">\(\mathcal{A}\)</span> 是被给予了 <spanclass="math inline">\(pk\)</span>的，以及试验中的加密采用了公钥加密方案，除此之外和私钥加密时定义的EAV试验是一样的。但是正由于敌手被给予了<span class="math inline">\(pk\)</span>，而加密方案又是公开的，因此敌手相当于得到了Enc的权限，从而一旦secure天然就有CPA-secure.</p><figure><img src="/image/crypto/pubeav.png" alt="pubeav" /><figcaption aria-hidden="true">pubeav</figcaption></figure><p>同样我们有根据试验所定义的<strong>安全性</strong>.</p><figure><img src="/image/crypto/Pub-secure.png" alt="Pub-secure" /><figcaption aria-hidden="true">Pub-secure</figcaption></figure><p>如果一个公钥加密方案是CPA-secure，它对多消息加密天然也是CPA-secure的.</p><p>此外，定长的CPA-secure加密可以推出任意长的CPA-secure加密(切成定长块，和多消息加密差不多了就).</p><h4 id="cca">CCA</h4><p>私钥当然是不能给敌手的，因此敌手还是以神谕基的形式调用Dec.</p><figure><img src="/image/crypto/CCA-secure.png" alt="CCA-secure" /><figcaption aria-hidden="true">CCA-secure</figcaption></figure><p>我们当然也有基于试验的安全性定义.</p><figure><img src="/image/crypto/CCA-secure-def.png" alt="CCA-secure-def" /><figcaption aria-hidden="true">CCA-secure-def</figcaption></figure><p>如果一个公钥加密方案是CCA-secure，它对多消息加密天然也是CCA-secure的.但是我们无法将定长CCA安全方案推广到任意长了，因为敌手完全可以打乱顺序进行解密...</p><h3 id="杂交加密">杂交加密</h3><figure><img src="/image/crypto/hybrid-encryption.png"alt="hybrid-encryption" /><figcaption aria-hidden="true">hybrid-encryption</figcaption></figure><p>KEM: 一个黑盒，输入公钥，为私钥加密生成对应的私钥和私钥密文.</p><p>DEM: 也就是公钥加密.</p><blockquote><p>A key-encapsulation mechanism (KEM) is a public-key primitive thatefficiently generates an encryption key for the private-key encryption kand its ciphertext c in a hybrid encryption scheme. Accordingly, theprivate-key encryption scheme is called a data-encapsulation mechanism(DEM) here.</p></blockquote><figure><img src="/image/crypto/KEM-DEM.png" alt="KEM-DEM" /><figcaption aria-hidden="true">KEM-DEM</figcaption></figure><h3 id="cdhddh-based-encryption">CDH/DDH-Based Encryption</h3><p>The El Gamal encryption scheme is described in the following:</p><figure><img src="/image/crypto/El-Gamal-encryption.png"alt="El-Gamal-encryption" /><figcaption aria-hidden="true">El-Gamal-encryption</figcaption></figure><p>安全性：</p><figure><img src="/image/crypto/El-Gamal-encryption-secure.png"alt="El-Gamal-encryption-secure" /><figcaption aria-hidden="true">El-Gamal-encryption-secure</figcaption></figure><blockquote><p>构造一个完全随机的 <span class="math inline">\(&lt;g^y,g^z\cdotm\)</span> 来证明.</p></blockquote><p>El Gamal encryption 不是CCA安全的！！！具有延展性(<spanclass="math inline">\(&lt;c_1,c_2&gt;,&lt;c_1^2,c_2^2&gt;\)</span>).</p><h3 id="rsa">RSA</h3><h4 id="plain-rsa">Plain RSA</h4><figure><img src="/image/crypto/RSA-key-generation.png"alt="RSA-key-generation" /><figcaption aria-hidden="true">RSA-key-generation</figcaption></figure><figure><img src="/image/crypto/plain-RSA-encryption-scheme.png"alt="plain-RSA-encryption-scheme" /><figcaption aria-hidden="true">plain-RSA-encryption-scheme</figcaption></figure><p>plainRSA不是CPA安全的.事实上任何确定性的公钥加密算法都不会是CPA安全的！此外，我们无法通过RSAassumption来证明其安全性...</p><h4 id="padded-rsa">Padded RSA</h4><figure><img src="/image/crypto/Padded-RSA.png" alt="Padded-RSA" /><figcaption aria-hidden="true">Padded-RSA</figcaption></figure><figure><img src="/image/crypto/PKCS.png" alt="PKCS" /><figcaption aria-hidden="true">PKCS</figcaption></figure><h2 id="数字签名机制">数字签名机制</h2><p>TBD</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRYPTO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成长的短视</title>
      <link href="/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/"/>
      <url>/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/</url>
      
        <content type="html"><![CDATA[<p>小百合系版"有像我一样不会写代码的cser么?"回复节选</p><ul><li>我们都是活生生的人,从小就被不由自主地教导用最小的付出获得最大的得到,经常会忘记我们究竟要的是什么. 我承认我完美主义,但我想每个人心中都有那一份求知的渴望和对真理的向往,"大学"的灵魂也就在于超越世俗, 超越时代的纯真和理想--我们不是要讨好企业的毕业生, 而是要寻找改变世界的力量. -- jyy</li><li>教育除了知识的记忆之外, 更本质的是能力的训练, 即所谓的training.而但凡training就必须克服一定的难度, 否则你就是在做重复劳动,能力也不会有改变. 如果遇到难度就选择退缩,或者让别人来替你克服本该由你自己克服的难度,等于是自动放弃了获得training的机会, 而这其实是大学专业教育最宝贵的部分.-- etone</li><li>这种"只要不影响我现在survive, 就不要紧"的想法其实非常的利己和短视:你在专业上的技不如人, 迟早有一天会找上来,会影响到你个人职业生涯的长远的发展; 更严重的是,这些以得过且过的态度来对待自己专业的学生,他们的survive其实是以透支南大教育的信誉为代价的 --如果我们一定比例的毕业生都是这种情况, 那么过不了多久,不但那些混到毕业的学生也没那么容易survive了,而且那些真正自己刻苦努力的学生, 他们的前途也会受到影响. -- etone</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>名师导学期中</title>
      <link href="/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/"/>
      <url>/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1id="关于高效寻找适用于锂-空气电池催化剂的思考">关于高效寻找适用于锂-空气电池催化剂的思考</h1><h2 id="介绍研究背景和现状">介绍研究背景和现状</h2><h3 id="研究背景">研究背景</h3><p>煤、石油、天然气等化石能源的日益枯竭，以及化石燃料燃烧带来的诸多环境问题，迫使人们寻求、开发清洁高效的可再生能源和储能系统。锂-空气电池（<spanclass="math inline">\(Li-O_2\)</span>电池）以金属锂作为负极，从空气中直接获取氧气进行正极反应而无需将氧气存储在电池内部，具有非常高的理论比能量(约<spanclass="math inline">\(11140Wh·kg^{-1}\)</span>)，这一数值非常接近汽油的理论比能量（约<spanclass="math inline">\(13kWh·kg^{-1}\)</span>）。这使得锂-空气电池在新能源汽车领域有着较好的应用前景，受到了人们的广泛关注。相关领域经过多年发展，针对锂-空气电池的研究逐渐深入，成果显著，锂-空气电池也是被视为极具应用前景的下一代储能系统之一，但锂-空气电池体系仍存在一些亟待解决的技术问题。</p><h3 id="研究现状">研究现状</h3><p>依据工作环境和介质条件的不同，当前被研究最多的锂空气电池主要是有机电解液、有机-水组合电解液以及全固态电解质三种类型。</p><p>有机体系锂-空气电池的结构相对简单，符合经典的摇椅式电池结构，能量密度最高、体系最为稳定。其选择溶解有钾盐的有机溶剂为电解液，如醚、烯酯等。放电时，氧气在正极被还原并与电解液里的<spanclass="math inline">\(Li^+\)</span>结合，金属锂在负极被氧化生成 <spanclass="math inline">\(Li^+\)</span>进入电解液。虽然正极的反应方式容易使人们联想到氢氧燃料电池，但与氢氧燃料电池不同的是，锂-空气电池放电会产生锂的绝缘难溶氧化物，可能会使空气通道被阻塞、电池极化增大从而导致放电提前终止，从而影响放电容量。另外，由于金属锂的活泼性，空气中的水、二氧化碳等诸多成分都会造成金属锂的腐蚀，影响电池寿命。事实上，已经有研究报道了水分子（相对湿度）对有机锂-空气电池的影响：水分子会使得放电容量有所增加，但会对电池的循环性能和倍率性能造成负面影响<spanclass="math inline">\(^4\)</span>。除此之外，有机体系锂-空气电池还存在着充放电过程空气正极过电位过大、充放电效率低等问题，对催化剂的性能、催化剂的稳定性提出了较高的要求，这也是当前许多研究人员正在关注、研究的重要课题。</p><p>为解决有机体系中正极反应会生成绝缘难溶氧化物问题，周豪慎教授研究组首先提出有机-水组合电解液型锂-空气电池。在这种锂-空气电池里，<spanclass="math inline">\(LiOH\)</span>水溶液和有机电解液分别与电池的正负极接触，二者用<spanclass="math inline">\(LISICON\)</span>隔开。研究表明，该类型电池可连续放电<spanclass="math inline">\(500h\)</span>以上，比容量高达<spanclass="math inline">\(50000mAh·g^{-1}\)</span>。在后续研究中，研究人员针对<spanclass="math inline">\(LISICON\)</span>在碱性环境不稳定等问题进行了改进，进一步提高了电池的稳定性与能量密度。另外，在组合电解液型电池的基础上，研究人员还提出了液流型锂-空气电池。有机-水组合电解液和液流型锂-空气电池都解决了有机电解液型电池中存在的正极产生绝缘氧化物影响电池性能的问题，更为接近燃料电池，同时使电池受空气中其他成分影响大幅减小，持续放电能力增强<spanclass="math inline">\(^4\)</span>。但此类型电池对隔膜材料的稳定性和离子电导率提出了较高要求，仍存在较大过电位损失这一问题。</p><p>事实上，虽然锂-空气电池理论能量密度高，应用潜力巨大，但还无法真正实现商业化，仍有诸多问题亟待解决：</p><ul><li>正极充放电过程有较大的过电位</li><li>实际容量要比理论容量低</li><li>循环过程中的容量衰减较大</li></ul><h2 id="提出重要科学问题">提出重要科学问题</h2><p>当前的锂-空气电池的空气正极在充放电过程中均存在有较大的过电位问题，这使得空气正极被视作限制锂-空气电池发展的一大重要因素，寻找合适的催化剂可能有效缓解、甚至解决这一问题。事实上，为解决这一问题，早有国内外研究人员对不同相中的氧还原反应深入研究，试图找到廉价、高效、稳定的催化剂材料<spanclass="math inline">\(^5\)</span>。既然寻找催化材料如此重要，我们是否有方法加速寻找适用于锂-空气电池的催化剂材料？</p><h2 id="对问题的分析和研究">对问题的分析和研究</h2><p>当前计算机技术飞速发展，机器学习已在诸多领域有了广泛应用，例如机器学习已成为高效预测蛋白质功能的有效手段，在酶功能预测领域有了广泛应用<spanclass="math inline">\(^1\)</span>。而酶本身是一种高效的有机催化剂，是否也可以利用机器学习等计算机技术帮助我们高效设计、寻找高效稳定的催化剂材料来有效解决锂-氧气电池存在的过电位问题呢？本文余下内容旨在讨论机器学习等计算机技术协助寻找、开发合适的催化剂材料助力锂-空气电池发展的可能性与展望。</p><p>首先是利用机器学习来加速寻求高效稳定的催化剂材料的可能性。机器学习等数据科学能够为研究人员提供了快速灵活的预测框架，在材料研发等领域展现出极大的应用前景。</p><p>在电池领域，机器学习已有诸多应用。锂离子电池能量密度高，循环次数多，广泛应用于移动设备和电动汽车领域。但锂离子电池的寿命难以预测，使得对人们不得不花费大量的时间与成本做破坏性实验来得到某种电池的寿命数据。这就导致在用户的实际应用中，由于缺乏电池的剩余寿命数据，无法准确制定电源计划。另外，锂离子电池的剩余电量甚至也无法通过传统方法来精准预测。而随着人工智能技术的发展，研究人员发现可以利用深度学习等技术很好的解决这些问题。人们只需要提供电池使用一段时间的相关数据，就可利用机器学习技术，参照过去得到的数据信息，精准预测电池的剩余寿命和剩余电量<spanclass="math inline">\(^2\)</span>。与我们论题更为相关的电池材料方面，机器学习也已经在发挥重要作用。各种材料具有复杂的不同的性质，当人们采用不同的材料组合时，这些材料的性质相互影响叠加在一起才能决定电池的实际性能。人工穷举所有的材料组合显然是个难以完成的任务，而机器学习技术可以利用计算机的计算、存储能力，通过学习过去已有的实验资料高效而准确的筛选材料组合，从而大幅提高研发效率<spanclass="math inline">\(^2\)</span>。</p><p>在催化剂领域，机器学习也早已有了广泛的应用。除去上文提及的对酶的结构、功能的预测外，机器学习在无机催化领域也发挥着巨大的作用。温室效应的加剧是人们不得不面临的一个问题便是对<spanclass="math inline">\(CO_2\)</span>的处理。二氧化碳的电还原便是实现二氧化碳回收的重要方法之一。和锂-空气电池类似，此技术需要寻找高性能的电催化剂。近些年，诸多研究者利用大数据来辅助新型催化剂的开发，提高了开发效率，降低了开发成本，加速了二氧化碳电还原技术的发展<spanclass="math inline">\(^2\)</span>。此外，机器学习在搜寻新型双钙钛矿氧化物光催化剂领域也起到了重要的加速作用<spanclass="math inline">\(^3\)</span>。</p><p>锂-空气电池的空气正极通常包括防水层、集流体、催化层等部分<spanclass="math inline">\(^4\)</span>。多数情况，开发可有效降低锂-空气电池过电位的催化材料可以视为开发合适的电池材料的一个子任务。由上述介绍，我们知道机器学习已经在催化化学领域和电池材料领域有了广泛而重要的应用，利用机器学习等技术来加速研发适用于锂-空气电池的高效、稳定催化材料显然也是可能的。</p><h2 id="结果讨论与展望">结果讨论与展望</h2><p>正如上文所述，利用机器学习技术加速开发合适的正极催化材料来有效缓解、解决锂-空气电池充放电过程中的较大过电位问题是可能的。机器学习等方法相当依赖训练数据，为了得到更好的预测结果，除了需要选择、开发更合适的算法之外，还需要建立、完善相应的数据库，已加强训练效果。此外，选择、开发合适的算法涉及到学科交叉，这意味着数据科学研究者和自然科学家之间需要进行充分的对接。最后，机器学习方法不应与理论分析分离。由于机器学习归根结底是依靠训练数据进行猜测，在未训练到的方面是不可靠的，纵使在已经得到充分训练的领域，在对其结果进行应用前也应对进行相应理论分析和实验研究，方能放心使用。</p><p>综上所述，相信借助机器学习技术的辅助能使锂-空气电池技术加速发展，从而推动能源技术发展，进而助力人类社会可持续发展。</p><h2 id="参考文献">参考文献</h2><ol type="1"><li>池燕飞, 李春, 冯旭东. 机器学习在蛋白质功能预测领域的研究进展[J].生物工程学报, 2023, 39(6): 2141-2157.</li><li>许建兵, 李翰实, 谭济民, 等. 机器学习在固体氧化物燃料电池, 锂电池,CO2 电还原催化剂中的研究进展[J]. 硅酸盐学报, 2022, 50(11).</li><li>万新阳, 章烨辉, 陆帅华, 等.机器学习加速搜寻新型双钙钛矿氧化物光催化剂[J]. 物理学报, 2022.</li><li>童圣富, 何平, 张雪苹, 等.基于有机和组合电解液的锂空气电池研究进展[J]. 电化学, 2015, 21(3):234.</li><li>王迪, 乔羽, 邓瀚, 等. 锂-空气电池研究进展与表征方法[J]. 催化学报,2019, 40(s1): 217.</li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> general course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Review for Principles of Marxism</title>
      <link href="/2023/12/19/Review-for-Principles-of-Marxism/"/>
      <url>/2023/12/19/Review-for-Principles-of-Marxism/</url>
      
        <content type="html"><![CDATA[<h1 id="马原复习">马原复习</h1><blockquote><p>搬运自本人大一下马原复习文档</p></blockquote><h2 id="马克思主义">马克思主义</h2><ul><li><strong>马克思主义</strong>：由马克思和恩格斯创立，并为后继者所不断发展的科学理论体系，是关于科学社会以及人类思维发展的一般规律的学说，是关于社会主义必将代替资本主义最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。</li><li><strong>马克思主义的基本组成部分</strong>：马克思主义哲学、马克思主义政治经济学、科学社会主义。</li><li><strong>创立</strong>：三大先进思潮是德国古典哲学、英国古典政治经济学、英法空想社会主义。</li><li><strong>特征</strong>：科学性、人民性、实践性、发展性。</li></ul><h2 id="物质">物质</h2><ul><li><strong>物质</strong>：是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，不依赖我们的感觉而存在，为我们的感觉所复写、摄影、反映。</li><li><strong>哲学基本问题</strong>：一、存在和思维、物质和意识谁为本源的问题，即何者为第一性的问题（产生了唯物和唯心）；二、存在和思维、物质和意识是否具有同一性的问题，即思维能否正确反映存在，人能否认识和正确认知世界的问题（产生了可知论和不可知论）。</li><li><strong>马克思理论意义</strong>：坚持唯物主义一元论（非唯心一元or二元论），坚持能动的反映论和可知论，批判不可知论，体现了唯物论和辩证论的统一，克服形而上学唯物主义的缺陷，体现唯物主义自然观和历史观的统一，为彻底的唯物主义奠定了理论基础。</li><li><strong>物质和意识的相互作用</strong>：1.意识是人脑的机能和属性，是客观世界的主观映像，物质对意识的决定作用表现在意识的本质和起源上：意识在内容上是客观的，在形式上是主观的，体现了主观与客观形式的统一。2.物质决定意识，意识对物质具有反作用，这种反作用是意识的能动作用，表现在：第一，意识具有目的性和计划性；第二，意识具有创造性；第三，意识可以指导实践改造客观世界；第四，意识可以调控人的行为和生理活动。</li><li><strong>意识与人工智能</strong>：人工智能是人的意识能动性的一种特殊表现，是人的本质力量的对象化和现实化。人工智能不能超越人类。第一，人类意识是知情意的统一体，而人工智能只是对人类的理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形态。第二，社会性是人类意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性。第三，人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力。</li></ul><h2 id="实践和认识">实践和认识</h2><ul><li><strong>科学实践观的意义</strong>：1.克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础；2.建立了科学的、能动的、革命的反映论，实现了人类认识史上的变革；3.在人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础；4.为人类能动的认识和改造世界提供了基本的思想方法和工作方法。</li><li><strong>实践对认识的决定作用</strong>：实践是认识的来源，是认识发展的动力，是认识的目的，是检验认识真理性的唯一标准。</li><li><strong>实践的本质</strong>：是人类能动的改造世界的社会性的物质活动，具有客观实在性、自觉能动性和社会历史性三个基本特征。</li><li><strong>实践的结构</strong>：实践主体、实践客体、实践中介。</li><li><strong>实践的过程</strong>：实践目的的确定、主体通过中介或手段作用于客体、实践结果的检验和评价。</li><li><strong>认识的本质</strong>：主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。唯心主义认识路线否认认识是人脑对客观世界的反映，认为认识先于人的实践经验。旧唯物主义认识论以感性直观为基础，把人的认识看成消极的、被动的反映和接受外界对象，是直观的、消极被动的反映论。</li><li><strong>真理</strong>：是标志主观和客观相符合的哲学范畴，是对客观事物及其规律的正确反映。</li><li><strong>谬误</strong>：所谓谬误，是同客观事物及其发展规律相违背的认识，是对客观世界及其发展规律的歪曲反映。</li><li><strong>价值</strong>：价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义。</li><li><strong>真理与谬误的关系</strong>：第一，二者相互对立；第二，二者的对立是相对的，它们在一定条件下能够相互转化；第三，真理和谬误的对立统一关系表明，真理总是同谬误相比较而存在、相斗争而发展的。实践是检验真理的唯一标准。</li></ul><h2 id="人类社会的发展规律">人类社会的发展规律</h2><ul><li><strong>社会存在</strong>：社会存在是指社会物质生活条件，是社会生活的物质方面，主要包括自然地理环境、人口因素和物质生产方式。</li><li><strong>唯物史观和唯心史观</strong>：马克思主义产生之前，唯心史观占据统治地位。</li><li><strong>社会意识</strong>：是社会存在的反映，是社会生活的精神方面，社会意识是人们进行社会物质交往的产物。</li><li><strong>社会存在和社会意识的辩证关系</strong>：1.社会存在决定社会意识。社会意识是对社会存在的反映，并反作用于社会存在，社会存在的变化发展决定社会意识的变化发展；2.社会存在是社会意识的内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映；3.社会意识具有相对独立性，社会意识有时会落后于社会存在，有时会先于社会存在而变化发展；4.社会意识对社会发展具有能动的反作用，落后的社会意识对社会的发展起到阻碍作用，先进的社会意识可以正确预见社会发展方向和趋势，对社会的发展起到积极的推动作用。</li><li><strong>生产力</strong>：生产力是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量。</li><li><strong>基本要素</strong>：劳动资料、劳动对象、劳动者</li><li><strong>生产关系</strong>：人们在物质生产过程中形成的不以人的意志为转移的经济关系。</li><li><strong>生产力和生产关系的相互作用</strong>：生产力和生产关系是社会生产不可或缺的两个方面。第一，生产力决定生产关系。第二，生产关系对生产力具有能动的反作用。生产关系和生产力的相互作用是一个过程，表现为二者的矛盾作用。二者的矛盾运动规律的原理有重要的理论和现实意义：1.否定了单纯以道德为评判历史功过的是非标准的思想体系；2.是马克思主义政党指定路线方针和政策的重要依据。</li><li><strong>经济基础</strong>：是指由社会一定发展阶段的生产力所决定的生产关系的总和。</li><li><strong>上层建筑</strong>：建立在一定经济基础上的意识形态以及与之相适应的制度、组织和设施。</li><li><strong>阶级</strong>：在历史上一定的社会生产经济体系中所处地位不同的集团。</li><li><strong>人类社会的基本矛盾</strong>：生产力和生产关系、经济基础和上层建筑之间的矛盾。</li><li><strong>经济基础与上层建筑的关系</strong>：相互影响，相互作用。经济基础决定上层建筑；上层建筑对经济基础具有反作用；经济基础与上层建筑的相互作用构成二者的矛盾运动；经济基础和上层建筑之间的内在联系构成了上层建筑一定要适应经济基础状况的规律。</li><li><strong>社会形态的内涵</strong>：社会形态是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。社会形态包括社会的经济形态、政治形态和意识形态，是三者具体的历史的统一。</li><li><strong>社会基本矛盾</strong>：1.生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量。2.生产力是社会进步的根本内容，是衡量社会进步的根本尺度。3.社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展。</li><li><strong>主要矛盾和基本矛盾</strong>：社会基本矛盾和社会主要矛盾。二者不是同一概念，也不是同一层次。社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展；社会主要矛盾是社会基本矛盾的具体体现。</li><li><strong>科学技术在社会发展中的作用</strong>：1.科技革命是推动经济和社会发展的强大杠杆：对生产关系产生了深刻影响，对生产方式产生了巨大影响，促进了思维方式的改变；2.科学技术能够通过促进经济和社会发展造福于人类。</li><li><strong>阶级斗争</strong>：是社会基本矛盾在阶级社会的直接体现，是阶级社会发展的直接动力。</li></ul><h2 id="资本主义">资本主义</h2><ul><li><strong>劳动二重性</strong>：1.具体劳动：生产一定使用价值的具体形式的劳动；2.抽象劳动：人的脑力和体力耗费。3.二者在时间和空间上统一，是统一劳动过程不可分割的两个方面；另一方面，反映劳动的不同属性（具体to自然抽象to社会）。</li><li><strong>商品二因素</strong>：使用价值和价值。对立统一：对立表现在二者相互排斥不可兼得，统一表现在作为商品必须同时具有使用价值和价值两个因素。</li><li><strong>商品经济</strong>：不是从来就有的，而是在一定历史条件下，作为自然经济的对立物而产生和发展的。</li><li><strong>资本原始积累</strong>：以暴力手段是生产者和生产资料分离，资本迅速集中于少数人手中，资本主义得以迅速发展的历史过程。</li><li><strong>资本总公式和商品交换之间的矛盾</strong>：按照等价交换原则，交换不能创造新价值，而资本总公式表明资本在流通过程中创造了新价值，关键在于劳动力成为商品。</li><li><strong>剩余价值</strong>：剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值。</li><li><strong>绝对剩余价值</strong>：是指在必要的劳动时间不变的条件下，由于延长工作日的长度或提高劳动强度而生产的剩余价值。</li><li><strong>相对剩余价值</strong>：是指在工作日长度不变的条件下，通过缩短必要劳动时间而延长剩余劳动时间所生产的剩余价值。</li><li><strong>资本积累</strong>：把剩余价值转化为资本，或者说，剩余价值的资本化。</li><li><strong>劳动力成为商品的基本条件</strong>：劳动者在法律上是自由人，能把自己的劳动力当作自己的商品来支配，劳动者没有其他生产资料，没有生产资料来源，因而不得不一靠出卖劳动力为主。</li><li><strong>资本主义基本矛盾</strong>：生产社会化和生产资料资本主义私人占有之间的矛盾。</li><li><strong>资本主义经济危机的本质特征</strong>：生产过剩（一种相对过剩）。</li></ul><h2 id="资本主义发展和趋势">资本主义发展和趋势</h2><ul><li><strong>垄断</strong>：指少数资本主义大企业为了获得高额利润，通过相互协议或者联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制。垄断是从自由竞争中形成的，是作为自由竞争的对立面产生的，但是，垄断并不能消除竞争，反而使竞争变得更加复杂和剧烈。垄断没有消除产生竞争的经济条件；垄断过程需要通过竞争来维持；社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产全部包下来。</li><li><strong>经济全球化的表现</strong>：生产全球化、贸易全球化、金融全球化。</li><li><strong>动因</strong>：科学技术的进步和生产力的发展为经济全球化提供了坚实的物质基础和根本的推动力；跨国公司的发展为经济全球化提供了适宜的企业组织形式；各国经济体制的变革和国际经济组织的发展为经济全球化提供体制和组织保障。</li><li><strong>影响</strong>：1.积极作用：为发展中国家提供先进技术和管理经验，提供更多的就业机会，推动发展中国家的贸易发展，促进发展中国家跨国公司的发展。2.消极作用：发达国家和发展中国家在经济全球化过程中的地位和收益不平等，加剧了发展中国家的环境污染，一定程度上增加了经济风险。</li></ul><h2 id="社会主义从空想到科学">社会主义（从空想到科学）</h2><ul><li><strong>马克思剩余价值学说的意义</strong>：剩余价值学说深刻揭示了资本家剥削工人的秘密，揭示了无产阶级与资产阶级利益的根本对立，从而科学论证了无产阶级肩负的推翻资本主义旧世界建设社会主义新世界的历史使命，使人们找到了变革资本主义旧社会的力量和通向社会主义新社会的途径。</li><li><strong>唯物史观</strong>：深刻揭示了人类历史发展的一般规律，揭示了人民群众的历史主体作用，揭示了阶级斗争在阶级社会发展中的巨大作用，从而把人们对社会主义的追求建立在对社会发展客观规律科学认识的基础上，克服了空想社会主义者不懂得历史规律的根本缺陷。</li><li><strong>科学社会主义核心命题</strong>：资本主义必然灭亡，社会主义必然胜利。两个必然的根本依据是人类社会发展规律。两个绝不会是指：“无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的。”要把两个必然和两个绝不会联系起来全面把握。</li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> general course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>calculus</title>
      <link href="/2023/12/19/calculus/"/>
      <url>/2023/12/19/calculus/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实测部分浏览器可能无法识别Latex公式，建议使用GoogleChrome或移步知乎食用！</p></blockquote><blockquote><p>本文搬运自本人知乎，原文链接为:https://zhuanlan.zhihu.com/p/627529870</p></blockquote><h1 id="常数项级数">常数项级数</h1><h2id="从正项级数的收敛判定到任意项级数的收敛判定">从正项级数的收敛判定到任意项级数的收敛判定</h2><h3 id="正项级数的收敛判定8种方法">正项级数的收敛判定（8种方法）</h3><p>如下：</p><p>1.定义法；2.柯西收敛；3.前n项部分和有上界；4.比较判别法；5.比较判别法（极限版本）（+p级数=阶估法）；6.比值（达朗贝尔）判别法；7.积分判别法；8.柯西根值.</p><h3id="任意项级数的收敛判定6种方法">任意项级数的收敛判定（6种方法）</h3><p>如下：1.定义法；2.柯西收敛；3.绝对收敛；4.使用柯西根值或达朗贝尔判别不绝对收敛时发散;5.迪利克雷判别法和阿贝尔判别法；6.交错级数的莱布尼茨判别法.</p><blockquote><p>先看必要条件是否满足（通项趋于0），再看是否绝对收敛（正项级数），若不绝对收敛，再看是否发散（迪阿莱）.</p></blockquote><h3 id="正部级数负部级数">正部级数&amp;负部级数</h3><p>定义：</p><p><span class="math display">\[a_n = a_n^+ - a_n^- ,|a_n|=a_n^+ + a_n^-;\]</span></p><p><span class="math display">\[a_n^+ = \frac{a_n+|a_n|}{2},a_n^-= \frac{|a_n|-a_n}{2}.\]</span></p><h3 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h3><p>几个定理：</p><p><strong>TH1.</strong> 级数绝对收敛必然收敛.</p><p><strong>TH2.</strong> 级数<span class="math inline">\(\Sigma _{n=1} ^\infty a_n\)</span>绝对收敛的充要条件即为正部级数和负部级数均收敛.</p><p><strong>TH3.</strong> 绝对收敛级数可任意更序，和不变.</p><p><strong>TH4.</strong>（黎曼定理）对于条件收敛的级数，可更换其次序使其收敛于任意给定数或以任意形式发散.</p><h3 id="阿贝尔变换几何直观">阿贝尔变换（几何直观）</h3><p><span class="math display">\[\Sigma_{i=1}^n a_ib_i=a_nB_n -\Sigma_{i=1}^{n-1}(a_{i+1}-a_i)B_i\]</span></p><h3 id="迪利克雷判别法和阿贝尔判别法">迪利克雷判别法和阿贝尔判别法</h3><p>前提条件：</p><p><span class="math display">\[\Sigma u_n =\Sigma a_nb_n\]</span></p><p>迪：</p><p><span class="math display">\[\{a_n\} 单调，且lim_{n\rightarrow\infty} a_n=0\]</span></p><p><span class="math display">\[\{b_n\} 的前n项部分和序列有界\]</span></p><p>阿：</p><p><span class="math display">\[\{a_n\} 单调有界\]</span></p><p><span class="math display">\[\{b_n\} 收敛\]</span></p><h3 id="交错级数">交错级数</h3><p><span class="math display">\[\Sigma (-1)^{n+1} u_n , u_n&gt;0\]</span></p><h3 id="交错级数的莱布尼茨判别法">交错级数的莱布尼茨判别法</h3><p>若<span class="math inline">\(u_n\geq u_{n+1} , lim_{n\rightarrow\infty}u_n=0\)</span>,则收敛，其和<span class="math inline">\(S\lequ_1.\)</span></p><h2 id="几道例题">几道例题:</h2><blockquote><p><spanclass="math inline">\(\Sigma\frac{(-1)^n}{\sqrt{n}-(-1)^n}\)</span>(有理化，发散)</p></blockquote><blockquote><p><span class="math inline">\(\Sigma sinnx\)</span> (sin(x/2))</p></blockquote><h1 id="广义积分">广义积分</h1><h2 id="敛散性的判定">敛散性的判定</h2><p>1.柯西收敛；2.比较判别法（非负）&amp;极限形式；3.阶估法（非负）（两个重要的广义积分）；4.绝对收敛定理；5.迪利克雷判别法.</p><h2 id="迪利克雷判别法">迪利克雷判别法</h2><p><spanclass="math inline">\(判定\int_a^{+\infty}f(x)g(x)收敛：\)</span></p><p>条件：</p><p><spanclass="math inline">\(\int_a^xf(x)dx在[a，+\infty)上有界,g(x)在[a,+\infty)上单调且趋于零\)</span></p><p>证明：</p><p>使用积分第二中值定理.</p><h2 id="tips">TIPS</h2><p>1.当<spanclass="math inline">\(f(x)\)</span>非负且单调递减时，可以用使用积分判别法转化为判定相应级数的敛散性.</p><p>2.广义积分收敛时，被积函数未必趋于零.</p><p>(eg.<spanclass="math inline">\(\int_1^{+\infty}sin(x^2)dx\)</span>).</p><p>3.上下限之间只有一个奇点，多个奇点要将广义积分进行拆分.</p><h2 id="几道例题-1">几道例题</h2><blockquote><p><spanclass="math inline">\(\int_1^{+\infty}sin(x^2)\)</span>(换元)</p></blockquote><blockquote><p><spanclass="math inline">\(\int_0^{+\infty}|\frac{sinx}{x}|dx\)</span>(<spanclass="math inline">\(1.\geq\frac{sin^2x}{x};2.\int_{k\pi}^{(k+1)\pi}|\frac{sinx}{x}|dx\)</span>)</p></blockquote><h1 id="函数项级数">函数项级数</h1><h2 id="一些概念">一些概念</h2><p>一般项/通项 部分和函数 收敛点 发散点 收敛域 发散域 和函数</p><h2 id="一句话">一句话</h2><p>要讨论函数项级数的收敛、发散、绝对收敛、绝对发散，只需要将<spanclass="math inline">\(x\)</span>任意固定，再应用常数项级数的一切有关敛散性定理.</p><h2 id="幂级数">幂级数</h2><h3id="阿贝尔第一定理从收敛到绝对收敛">阿贝尔第一定理（从收敛到绝对收敛）</h3><p>1.如果幂级数<span class="math inline">\(\Sigmaa_nx^n\)</span>在点<spanclass="math inline">\(x=x_0(x_0\neq0)\)</span>收敛，则它在区间<spanclass="math inline">\(|x|&lt;|x_0|\)</span>中绝对收敛；</p><p>2.如果幂级数<span class="math inline">\(\Sigmaa_nx^n\)</span>在点<spanclass="math inline">\(x=x_1\)</span>发散，则在满足<spanclass="math inline">\(|x|&gt;|x_1|\)</span>的点上都发散.</p><h3 id="收敛半径的存在性">收敛半径的存在性</h3><p>如果幂级数具有非零的收敛点与发散点，则必存在一个确定的非负数，使得当<spanclass="math inline">\(|x|&lt;R\)</span>时，级数绝对收敛；而当<spanclass="math inline">\(|x|&gt;R\)</span>时级数发散.</p><h3 id="求收敛半径">求收敛半径</h3><p><span class="math display">\[lim_{n \rightarrow\infty}|\frac{a_n}{a_{n+1}}|\]</span></p><p><span class="math display">\[\lim_{n \rightarrow\infty }\frac{1}{|a_n|^{\frac{1}{n}}}\]</span></p><h3 id="tips-1">TIPS</h3><p>关于幂级数的很多结论都是针对标准形式的，因此会出现一些典型问题比如缺项，可换元解决，或直接依靠定义讨论.</p><h3 id="一道例题">一道例题</h3><blockquote><p>证明：若<span class="math inline">\(f\)</span>是<spanclass="math inline">\([a,+\infty)\)</span>上的单调函数，且<spanclass="math inline">\(\int_a^{+\infty}f(x)dx\)</span>收敛，则<spanclass="math inline">\(lim_{x\rightarrow +\infty}f(x)=0\)</span>，且<span class="math inline">\(f(x)=o(1/x),x\rightarrow+\infty.\)</span></p></blockquote><blockquote><p>思路：1.证有极限-&gt;证有界;2.证极限为0-&gt;反证;3.证高阶小量-&gt;积分中值定理&amp;夹逼.</p></blockquote><h2 id="一致收敛函数项级数的分析性质">一致收敛函数项级数的分析性质</h2><h3 id="一致收敛">一致收敛</h3><h4 id="直观">直观</h4><p>收敛速度可以总体控制.</p><h4 id="定义">定义</h4><p><span class="math inline">\(\{f_n(x)\}\rightrightarrows f(x) ,x\inI\iff\forall\epsilon&gt;0,\exists N&gt;0,n&gt;N,|f_n(x)-f(x)|&lt;\epsilon,x \in I .\)</span></p><p><span class="math inline">\(\{\Sigma u_n(x)\}\rightrightarrows S(x),x\in I.\)</span>$ &gt;0,N&gt;0, n&gt;N,|u_1(x)+..+u_n(x)-S(x)|&lt;,xI.$</p><p><span class="math inline">\(\iff\forall\epsilon &gt;0, \existsN&gt;0,n&gt;N,\forall p\in N,|u_{n+1}(x)+...+u_{n+p}(x)|&lt;\epsilon,x\in I\)</span></p><p><span class="math inline">\(\iff lim_{n\rightarrow\infty}\ sup_{x\inI}|S_n(x)-S(x)|=0.\)</span></p><blockquote><p>上确界和柯西准则在证明不一致收敛时比较好用.</p></blockquote><h4 id="判定">判定</h4><p>M判别法:</p><blockquote><p>数项级数一致收敛.</p></blockquote><p><span class="math display">\[对 \Sigma u_n(x),若：|u_n(x)|&lt;a_n,\forall x\in I  ; \Sigma a_n 收敛\]</span></p><p><span class="math display">\[则 \Sigma u_n 收敛且一致收敛.\]</span></p><blockquote><p>Pf.柯西收敛准则.</p></blockquote><p>迪利克雷判别法：</p><p>若：</p><p><span class="math display">\[1.对区间I上每一个固定的x,数列\{a_n(x)\}单调且一致趋于零;\]</span></p><p><span class="math display">\[2.函数项级数\Sigma b_i(x)的部分和数列\{B_n(x)\}在I上一致有界.\]</span></p><p>则：</p><p><span class="math display">\[\Sigma a_ib_i在I上一致收敛.\]</span></p><p>阿贝尔判别法:</p><p>若:</p><p><span class="math display">\[1.对区间I上每一个固定的x,数列\{a_n(x)\}单调且一致有界;\]</span></p><p><span class="math display">\[2.函数项级数\Sigma b_i(x)在I上一致收敛.\]</span></p><p>则:</p><p><span class="math display">\[\Sigma a_ib_i在I上一致收敛.\]</span></p><h3 id="关于连续性">关于连续性</h3><p><span class="math display">\[若u_n(x)(n=1,2,...)在[a,b]上连续；\Sigma u_n(x)\rightrightarrowsS(x),x\in [a,b].\]</span></p><p><span class="math display">\[则S(x)在[a,b]上连续.\]</span></p><blockquote><p>Pf.搭桥.<span class="math inline">\(S(x)-S_n(x)\)</span>,<spanclass="math inline">\(S_n(x)-S_n(x_0)\)</span>,<spanclass="math inline">\(S_n(x_0)-S(x_0)\)</span>.</p></blockquote><blockquote><p>实际上是两种极限次序的交换.</p></blockquote><h3 id="逐项求积分">逐项求积分</h3><p><span class="math display">\[若u_n(x)(n=1,2,...)在[a,b]上连续；\Sigma u_n(x)\rightrightarrowsS(x),x\in [a,b].\]</span></p><p><span class="math display">\[则S(x)在[a,b]上可积，并且可逐项求积分,\int_a^b\Sigmau_n(x)dx=\int_a^bS(x)dx=\Sigma\int_a^b u_n(x)dx.\]</span></p><blockquote><p>Pf.<span class="math inline">\(r_n(x)\rightrightarrows0\)</span>.</p></blockquote><h3 id="逐项求导">逐项求导</h3><p>若：</p><p><span class="math display">\[1.u_n(x)在[a,b]连续可导;\]</span></p><p><span class="math display">\[2.\Sigma u_n(x)\rightarrow S(x),x\in [a,b]；\]</span></p><p><span class="math display">\[3.\Sigma u_n^{&#39;}(x)\rightrightarrows U(x),x\in[a,b].\]</span></p><p>则:</p><p><span class="math display">\[S(x)在[a,b]上连续可导，并且可逐项求导，即S^{&#39;}(x)=U(x).\]</span></p><blockquote><p>注意，以上关于连续性、逐项积分、逐项求导的讨论都是在闭区间.</p></blockquote><h3 id="内闭一致收敛">内闭一致收敛</h3><p>若<span class="math inline">\(\Sigmau_n(x)\)</span>在开区间的任意一个闭子区间都一致收敛，则成为其在区间<spanclass="math inline">\(I\)</span>上内闭一致收敛.</p><blockquote><p>连续性和逐项求导可在内闭一致区间上进行推广.</p></blockquote><h2 id="幂级数的分析性质">幂级数的分析性质</h2><h3 id="阿贝尔第二定理">阿贝尔第二定理</h3><p>已知:</p><p><span class="math display">\[幂级数\Sigma a_n x^n的收敛半径为R&gt;0\]</span></p><p>有:</p><p><span class="math display">\[（1）幂级数在(-R,R)上内闭一致收敛\]</span></p><p><span class="math display">\[（2）若在右端点R出收敛，则对\forall0&lt;\delta&lt;2R,幂级数在[-R+\delta,R]上一致收敛\]</span></p><p><span class="math display">\[（3）左端点类似（2）\]</span></p><blockquote><p>Pf.（1）M判别法；（2）（3）阿贝尔.</p></blockquote><h3 id="幂级数的分析性质-1">幂级数的分析性质</h3><p>和函数在收敛域内连续、可逐项积分、可逐项求导.逐项求导或求积分后收敛半径不变但端点的收敛性未必.</p><p>推论：</p><ul><li>级数<spanclass="math inline">\(\Sigma_{n=1}^{\infty}na_nx^{n-1}\)</span>,<spanclass="math inline">\(\Sigma_{n=0}^{\infty}\frac{a_n}{n+1}x^{n+1}\)</span>,<spanclass="math inline">\(\Sigma_0^{\infty}a_nx^n\)</span>有相同的收敛半径.</li><li>幂级数<spanclass="math inline">\(\Sigma_nx^n\)</span>的收敛半径为<spanclass="math inline">\(R\)</span>，则在<spanclass="math inline">\((-R,R)\)</span>内该级数可逐项求导数任意次，逐项求积分任意次.</li></ul><h2 id="函数的幂级数展开">函数的幂级数展开</h2><h3 id="函数幂级数展开的存在唯一性">函数幂级数展开的存在唯一性</h3><p>设函数<span class="math inline">\(f\)</span>在点a的邻域<spanclass="math inline">\(U=U(a,R)\)</span>上任意阶可导，则：</p><ul><li><p><span class="math inline">\(f\)</span>在<spanclass="math inline">\(U\)</span>上可展成泰勒级数的充要条件是函数<spanclass="math inline">\(f\)</span>所展成的泰勒公式中的余项<spanclass="math inline">\(r_n(x)\)</span>在<spanclass="math inline">\(U\)</span>上处处收敛于<spanclass="math inline">\(0\)</span>.即：</p><p><span class="math display">\[f(x)=\Sigma_{k=0}^{\infty}\frac{f^{(k)}(a)}{k!}(x-a)^k\ifflim_{n\rightarrow\infty}r_n(x)=0,\forall x\in U.\]</span></p></li><li><p>若<span class="math inline">\(f\)</span>可在<spanclass="math inline">\(U\)</span>上展成幂级数，则这个幂级数唯一，就是<spanclass="math inline">\(f\)</span>在点<spanclass="math inline">\(a\)</span>的泰勒级数.</p></li></ul><h3 id="基本展开式">基本展开式</h3><ul><li><span class="math display">\[e^x=1+x+\frac{x^2}{2!}+...+\frac{x^n}{n!}+..., (-\infty &lt;x&lt;+\infty)\]</span></li><li><span class="math display">\[sinx=x-\frac{x^3}{3!}+...+(-1)^{m-1}\frac{x^{2m-1}}{(2m-1)!}+...,(-\infty&lt;x&lt; +\infty)\]</span></li><li><span class="math display">\[cosx=1-\frac{x}{2!}+...+(-1)^m\frac{x^{2m}}{(2m)!},(-\infty &lt;x&lt;+\infty)\]</span></li><li><span class="math display">\[(1+x)^\mu=1+\mux+\frac{\mu(\mu-1)}{2!}+...+\frac{\mu(\mu-1)...(\mu-n+1)}{n!}x^n+...,(-1&lt;x&lt;1,\forall\mu)\]</span></li></ul><blockquote><p>1/(1+x)和1/(1-x)展开式很常用</p></blockquote><ul><li><span class="math display">\[ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}+...+(-1)^{n-1}\frac{x^n}{n}+...,(-1&lt;x\leq1)\]</span></li></ul><blockquote><p>求一个函数的展开式的方法有二：一，利用定义直接求；二，利用求导求积分等运算和以上几个基本式子间接求出.</p></blockquote><h1 id="含参积分">含参积分</h1><h2 id="含参常义积分">含参常义积分</h2><h3 id="连续性">连续性</h3><p>设函数<span class="math inline">\(f\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,y\inI\}\)</span>上连续，则<spanclass="math inline">\(\phi(y)=\int_a^bf(x,y)dx\)</span>在<spanclass="math inline">\(I\)</span>上连续，特别的，对<spanclass="math inline">\(y_0\in I\)</span>，有<spanclass="math inline">\(lim_{y\rightarrowy_0}\int_a^bf(x,y)dx=\int_a^blim_{y\rightarrowy_0}f(x,y)dx\)</span>,即极限和积分的运算顺序可以交换.</p><blockquote><p>推论：设函数<span class="math inline">\(f(x,y)\)</span>在<spanclass="math inline">\(a(y)\leq b(y),y\in I\)</span>上连续，函数<spanclass="math inline">\(a(y),b(y)\)</span>在<spanclass="math inline">\(I\)</span>上连续，则含参变量<spanclass="math inline">\(y\)</span>的积分 $ (y)=_{a(y)}^{b(y)}f(x,y)dx$在<span class="math inline">\(I\)</span>上连续.</p></blockquote><h3 id="积分号下求导">积分号下求导</h3><p>设<span class="math inline">\(f\)</span>与<spanclass="math inline">\(\frac{\partial f}{\partial y}\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,y\inI\}\)</span>上连续，则<span class="math inline">\(\phi\)</span>在<spanclass="math inline">\(I\)</span>上可导，且有（莱布尼茨公式）：</p><p><span class="math display">\[\phi^{&#39;}(y)=\frac{d}{dy}\int_a^bf(x,y)dx=\int_a^b\frac{\partial}{\partial y}f(x,y)dx,\forall y\in I.\]</span></p><p>设二元函数<span class="math inline">\(f\)</span>与<spanclass="math inline">\(\frac{\partial f}{\partial y}\)</span>在<spanclass="math inline">\(D=\{(x,y):a\leq x\leq b,\alpha\leqy\leq\beta\}\)</span>上连续,函数<spanclass="math inline">\(a(y),b(y)\)</span>在<spanclass="math inline">\([\alpha,\beta]\)</span>上有连续导数，且<spanclass="math inline">\(a\leq a(y)\leq b,a\leq b(y)\leqb\)</span>,则函数</p><p><span class="math display">\[\phi(y)=\int_{a(y)}^{b(y)}f(x,y)dx\]</span></p><p>在</p><p><spanclass="math inline">\([\alpha,\beta]\)</span>上具有连续导数，且有</p><p><span class="math display">\[\phi^{&#39;}(y)=\int_{a(y)}^{b(y)}f_y(x,y)dx+f(b(y),y)b^{&#39;}(y)-f(a(y),y)a^{&#39;}(y),y\in[\alpha,\beta]\]</span></p><h3 id="积分换序">积分换序</h3><p>条件同连续性.</p><h2 id="含参广义积分">含参广义积分</h2><h3 id="一致收敛-1">一致收敛</h3><p><span class="math display">\[\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,s.t.当A&gt;A_0,\forall y\in I,|\int_A^{+\infty}f(x,y)dx|&lt;\epsilon\]</span></p><p><span class="math display">\[\iff lim_{A\rightarrow+\infty}sum_{y\in I}|\int^{+\infty}_Af(x,y)dx|=0\]</span></p><p><span class="math display">\[\iff\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,\forallA_2&gt;A_1&gt;A_0 有|\int^{A_2}_{A_1}f(x,y)dx|&lt;\epsilon,\forall y\inI\]</span></p><h3 id="m判别法">M判别法</h3><p>条件：</p><ul><li><span class="math display">\[\exists M(x),s.t. |f(x,y)|\leq M(x),\forall (x,y)\in D\]</span></li><li><span class="math display">\[\int _a^b M(x)dx 收敛\]</span></li></ul><p>结论：</p><ul><li><span class="math display">\[\int_a^bf(x,y)dx 在I上一致收敛.\]</span></li></ul><h3 id="分析性质">分析性质</h3><p>针对连续性、积分号下求导、积分顺序交换的分析，此处略过.</p><h2 id="gamma函数和-b函数"><spanclass="math inline">\(\Gamma\)</span>函数和 B函数</h2><p>了解定义域、递推关系、不同形式、两者之间的关系、余元公式.</p><h2 id="傅里叶级数">傅里叶级数</h2><p>求傅里叶级数</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
