<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>来时路</title>
      <link href="/2025/04/12/%E6%9D%A5%E6%97%B6%E8%B7%AF/"/>
      <url>/2025/04/12/%E6%9D%A5%E6%97%B6%E8%B7%AF/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="73de8fb5c4a86ab7a5c8d34038803647b2ddc2e319b08fb013b118ce3c3227d3">993001887e685ce116fe55cfc0af2e19756f54c96abd96c28d4c8d8127f626140f320add533a9326e0f1a291a9080b8a79ee565a9b778841674a1a616e7cc2dc901ef46fe499ea936ee62e03c22f61092057806acc6595648b2b4e95a1cfee9b7c2aa8fbdbd99d9d35d9ecedb0772de174db561c1c9826866c0d476466a0a38ea2f4d6b8b188bbc10a55f4475bae85291751447f967db893b67e25386378cc543a7160da7ac29ba984677466b4663a217833b37cd24e05de0b34f57cc92eb956adf8df6351e469aa39d21ed0bfc508ebbe8d7888031dc98dbc36a91c8c561b9cb8660e1ef7a6432e51b7e1510ae53aed3e22eb8cff7674bad635955436a20e063c6eb75f1346777eadbe890307b7b2e13143d4234bcce805d0195cef96a114eca56b99640339eddc05626137cdc157640db4e5eec3bd5471a8aa3aa2c71d75d60124d6659ab6eaf5b354a4a7b894df99fafa45f95ee90f0aae57ea44d241d8b1c68cd2b94eb76cb7c5bbb014d9c8ae3021c9a440aed06771c7c458a35b358b9c</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>remote-ssh-to-wsl</title>
      <link href="/2025/04/11/remote-ssh-to-wsl/"/>
      <url>/2025/04/11/remote-ssh-to-wsl/</url>
      
        <content type="html"><![CDATA[<blockquote><p>本文参考自知乎，原文链接为 <a href="https://zhuanlan.zhihu.com/p/357038111">https://zhuanlan.zhihu.com/p/357038111</a>.</p></blockquote><p>最近希望能通过VScode的Remote-SSH插件来远程访问位于寝室Windows主机上的WSL，但是考虑到处于校园网环境，Windows主机的IP地址是动态分发的且<s>一直开机并不现实</s>，因此可能每次使用远程访问时都要重复操作，为避免遗忘，遂记录于此.</p><ol><li>在WSL2下重装ssh</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo apt-get remove openssh-server<br>sudo apt-get install openssh-server<br></code></pre></td></tr></table></figure><ol start="2"><li>编辑sshd_config文件，修改几处配置</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/ssh/sshd_config<br><br>+++ Port 22<br>+++ PermitRootLogin <span class="hljs-built_in">yes</span><br>+++ PasswordAuthentication <span class="hljs-built_in">yes</span><br></code></pre></td></tr></table></figure><ol start="3"><li>编辑hosts.allow</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo vim /etc/hosts.allow<br><br>+++ sshd: ALL<br></code></pre></td></tr></table></figure><ol start="4"><li>重启ssh服务</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">sudo service ssh --full-restart<br><br>sudo systemctl <span class="hljs-built_in">enable</span> ssh <span class="hljs-comment">#设置开机自启</span><br></code></pre></td></tr></table></figure><ol start="5"><li>进行端口转发</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ifconfig <span class="hljs-comment">#在WSL，查看ip地址</span><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment"># in Win : 管理员cmd</span><br>netsh interface portproxy add v4tov4 listenaddress=0.0.0.0 listenport=22 connectaddress=xxx.xxx.xxx.xxx connectport=22<br><br>netsh interface portproxy show all <span class="hljs-comment">#查看已设置的转发</span><br>netsh interface portproxy delete v4tov4 listenaddress=0.0.0.0 listenport=22 <span class="hljs-comment">#删除某一转发</span><br>netsh interface portproxy reset <span class="hljs-comment">#重置所有转发</span><br></code></pre></td></tr></table></figure><ol start="6"><li>cmd下查询Windows的内网IP地址</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ipconfig<br></code></pre></td></tr></table></figure><ol start="7"><li>通过Remote-SSH进行连接</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">ssh root@xxx.xxx.xxx.xxx <span class="hljs-comment">#root可换成对应用户名</span><br></code></pre></td></tr></table></figure><blockquote><p>Windows防火墙设置默认会关闭22端口，需要开放防火墙设置：<br><code>Win+R</code>键入<code>control firewall.cpl</code>，新建入站规则即可.</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Happy-Birthday!</title>
      <link href="/2025/04/04/Happy-Birthday/"/>
      <url>/2025/04/04/Happy-Birthday/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="fd077626c511f2021322a8a252345141da3b66e8fb784fd7d370fb06405778fe">10d79030e8222445804370796b90fca18767b33315602ebd300fc1d1138e35f94ede3a9ed244a426d9c4569d24bcfff91e94964604e686740f072b2362c16be78001f0835ee9380875d5ce8630e9ab551ccbc9b0c77d776b6dab4aa2a1752250ade09552a42461621832003b7bb958caa34704c905db22c43e4968bcb0422f2adb13a74a91ea57d3eaf3513c6a17d006aca0c4a37e52aafad08a2d02783d0e583d8a8cc260bd34095e7a72f7709d08ba5187f297ca87198bfbedf97d9bbc5beb51e4e524831f4399d9f9825156031d3b3261686e2d3a7218bda8703c4ef05eac03328b05fa0995cc406e14cefe93ca230cd2085bf11051d1f4f9425aa4a63516ba6add3cd669427263ecd2f2b77a0a49b601c802badb00224bc37a08ca77ec6e8fb7adfd4e3a9bc844c0087736452abbae73ab5008b07d18b4a5762ef53c9bc04e2e63587f42926be928fcb01c14aba74debd55a503bf6c158387c1960dacf7da4d44424325162098677e89d3bec0525648c629494df74a34eed61e01f1aa1975f22245b617c2a0ed31a405ddb84905ed646802785429a658be011e77ae04a77836b6ae0cf3f17723f5372db4b3e0df0ff35325668f8e83ada4bc91c6981d5f8a7083722a606e999d8b158340ccf9089040f102225cf7dd8024cb61c4f4ae8547c1b188308314ead2c8c79bfcb21c8b86fef4d4337b525992b563a414797ad1fbab6138f7610f9e9b57964783311dbb8dfef14ae33e6111ffcc7aa45bef60f84ec84ff31ec7591fe49be730bf3480c61cafb602f9ad8a31ed16612ad62e9acfba8678cfff7a5d71d7f505932ae17e35f3532a503c35ec1906889f283b63a5f9295853f0474ef5dcd65f0b0ec11072438ea47c689419a2ae7080e5bb30d3c4ae3c269e16fbe256662cd085931a7f227d221e34ddcddcbc0ff55788c4b836374e8a57d66015ae7d8ba1758710c08a4f7ec9a143ea63486197fc8a5463a6bf4a816dd7d3ef7a580cc110eb9e575a83e679ef637427a1fa4aee392098425e2dcaa3ac76dc84109d677ceb00fe20a41593fb9c9f0f343225e7e37ef070d88223bd7616bdb7b23e4d9542cc76461cf16f818c492fcdd275f86d1eda429baf70aef7e2edd73db940a84411bc23201b048f86357f64d06150e8fddc35b5df808d879715d813d6f587e20b41da261e5def70cdd59a05ee7af4e934b73d875d2265c25508f915fdefdb607662786232590f85bd30528e5151d990c8f6cd72b4ddd838cd6d76c036de0a80b204f5182612981aa51b3197dcb31d247872ad0d200fe44e523f92d80a03c10f3733f231d362b615e9b76e49d8582a3c99d6e15367ecda96e5ddb6cb33def4e1b0ffd53afe7ec91497c8fd9609b6ae339e0ba01e4de96f1ec526c4d2dc881f003569239c09778a843ca1bc12c60009288cacf57a8e408d499a32dffaee9087a81275c8b323e082164cd98e39d8a9585b00d77926e7f5a46fb6864ab33c55252df2e68b7ce3a39fcf2222d</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Win安装“动手学深度学习”</title>
      <link href="/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/"/>
      <url>/2025/01/19/How-to-install-Dive-into-Deep-Learning-md/</url>
      
        <content type="html"><![CDATA[<p>课程网站上的<a href="https://zh.d2l.ai/chapter_installation/index.html">安装说明</a>已经很friendly了，但是并未列出Windows下的安装教程，谨在此记录我是如何在Win11下进行安装的.</p><h2 id="安装配置-Miniconda">安装配置 Miniconda</h2><p>根据自己使用的python版本，在<a href="https://repo.anaconda.com/miniconda/">miniconda</a>官网中选择对应的版本即可，如笔者使用的是<code>python 3.9</code>，则选择了<code>Miniconda3-py39_24.11.1-0-Windows-x86_64.exe</code>来下载并双击安装.</p><ul><li>建议勾选 Register Miniconda3 as my default Python 3.9…</li><li>不要忘记设置环境变量</li></ul><p>详细安装教程可参见<a href="https://www.bilibili.com/opus/509341163774622170">bilibili</a>.</p><h2 id="其余即可参照课程网站">其余即可参照课程网站</h2>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>生日快乐</title>
      <link href="/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/"/>
      <url>/2025/01/04/%E7%94%9F%E6%97%A5%E5%BF%AB%E4%B9%90/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="638e49320f10c1ed8040285ce3365b2946369a7fd25f252a8e50da10cbaba3cf">10d79030e8222445804370796b90fca1ff7af4042ff02b990a5afc3d744bcff9484cff467aa33966bd41980b234f2414332bab9dc0dc56ecb0ffaa1bb5498ee24832938f4f94d013a6427c25e6814358c1ef336fd545ab522dbef08600db31eaf4f1ac734b00561d8dff8b8503d447ecc5ce720c077349ea8db111ac59d68de6f2706da82d271b745d06ff617acd72b4b8778d254b5b397d78a346f87d07def81bd05f9f9f44c452e3f3edd09ddd2d9f4366e623bd9467e008c5b4b8fc7b2455d05fdd4dbf33a9e209c2e136c54583090fb84f37c980d84006f38085675023abe38e318dcffa62eca987e8ce1c1e6e0bb707f876cfe0c53853e553bcfaf271e3795116d2ce3f7317d98f4c6b87c262069d30114f79b2146f249c22e27590093f0d96d35527897a02faa1b481c3b0dbd667d8a69b3c5464bc727eef9847feb08a59727ccce9b99788c06002cf97086cc57f704e26306ea2022c7fe5e4ad273cb94676ab1d03a44e555687e93015ec5dbf31c0bb4bcd194fc422171e695aa1436131ed26555bc5471322b5a2dc74979e19592525441c53cecd9a0d88a583f8cbd046c76cbc186ac990f0290a816772eb0addcadf99fcdfe9dfcb863fcd3cb441cca6f22c126e809a3ee00bc270289e94008aa6ba0f6d82df7ead12f75fef825f4335e453e0bc04ded1f0c3877627d962a220cc1d287cdcd931a4d77dfa56041835850cdf354818219bb1088a49a5228d67116d468f8d50d37ab768a44923e756e551ec4ea90ef77fc60781ca171006c9ac009b557c6a7ceb028799e811e5268dcefcbd44a30cdc2fc2ffd5c41754a6add9c81af8554ede0d3037e41ed9f34425181cc696dd4d3fc0629deac8fd00c55170d8c05d339f52c04f7084930e3a4ed60a116b824ed139ddda77a092a28ee508ad406ff1d1234452e7baca8109ab965434e78a9dcaf11618df245d8413e56834f53ceb3e60438bf16402a7e78d320993eb35de9a4dbb6c091b2bffb91896889321312ceb2a2150b675ea1fe14f5083563ead57c6cec09cfdd26b6198e663d98867edd5972fd5c10fb4440cb75b508fa9c6af356239afe9152c2410fa269692935a3e65ea954f5b7cdbb4ad19ac350ab4c8b2ff99cbf3f86b6510b5afa31e3ac11e3874bd475d000f551a9d1ea7280888d2f4470297e728ccfeb429e9c50cc1fd52ec406f6d8b5dccc62eadf59c17463da433063fb3cca9cb6be509a1dd72f42a331fd4d094ad3b51f54bc140e1bbfefd4f2589839ce83820e4142910d7f40bdb3a5c49e746cbffb785e33632d773f6804bb7a943dcb2c231619ee1adf77b6a9cb6d7f0b89e18dc1095ba583d081b200e1203d78ff0ebdcff244b2166856a727af912413bd6f44ae5653ed1524473865ffb7242250e479164b4b0e68b61bbf6b8886ff1020d631d15b5de4036825f8447a15e0d8276e328a323032e7df485a28e218a8ebe2e5f56a3ea461cbbc4230b0654</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-xray">      <input class="hbe hbe-input-field hbe-input-field-xray" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-xray" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-xray">您好, 这里需要密码.</span>      </label>      <svg class="hbe hbe-graphic hbe-graphic-xray" width="300%" height="100%" viewBox="0 0 1200 60" preserveAspectRatio="none">        <path d="M0,56.5c0,0,298.666,0,399.333,0C448.336,56.5,513.994,46,597,46c77.327,0,135,10.5,200.999,10.5c95.996,0,402.001,0,402.001,0"></path>        <path d="M0,2.5c0,0,298.666,0,399.333,0C448.336,2.5,513.994,13,597,13c77.327,0,135-10.5,200.999-10.5c95.996,0,402.001,0,402.001,0"></path>      </svg>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CRYPTO</title>
      <link href="/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/"/>
      <url>/2024/11/06/%E5%AF%86%E7%A0%81%E5%AD%A6%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="消息认证">消息认证</h2><ul><li>消息认证的必要性</li><li>MAC<ul><li>定义</li><li>正确性与安全性要求</li><li>使用</li></ul></li><li>构造 secure MACs<ul><li>定长</li><li>CBC-MAC处理长消息</li></ul></li><li>AE<ul><li>定义</li><li>CCA安全</li><li>不可伪造加密</li><li>构造AE</li></ul></li></ul><h3 id="消息认证的必要性">消息认证的必要性</h3><p>安全的对话要确定消息发送方的身份和以及消息未被串改，仅加密在很多时候并不能确保这些.</p><h3 id="MAC">MAC</h3><p>给我们的消息打一个tag！</p><h4 id="定义">定义</h4><p>消息认证码，即 MAC 是一个 PPT 算法组成的三元组 $\Pi=(Gen,Mac,Vrfy)$:</p><ul><li>密钥生成算法: $k \leftarrow Gen(1^n) , |k| \geq n$.</li><li>标签生成算法：$t \leftarrow Mac_k(m)\ or\ t := Mac_k(m), m\in {0,1}^*$.</li><li>确定性的认证算法：$b := Vrfy_k(m,t) , b=1 \ iff.\ m\ is\ valid$.</li></ul><h4 id="正确性与安全性要求">正确性与安全性要求</h4><p><strong>正确性</strong>：正确生成的MAC要被认可，即<br>$$\forall n, k \leftarrow Gen(1^n), \forall m\in {0,1}^*, Vrfy_k(m,Mac_k(m))=1$$</p><p>当 $Mac$ 是确定性算法时，一种典型的认证方法是重新计算tag并进行比对.</p><p><strong>安全性</strong>通过消息认证试验 $Mac-forge_{\mathcal{A},\Pi}(n)$ 来定义：</p><ol><li>$k \leftarrow Gen(1^n)$ 对敌手保密.</li><li>给 $\mathcal{A}(1^n)$ 调用 $Mac_k(\cdot)$ 的能力，$\mathcal{A}$ 查询若干次，最终输出 $(m,t)$. 记 $\mathcal{Q}$ 为 $\mathcal{A}$ 所查询消息的集合.</li><li>$\mathcal{A}$ 成功也即 $Mac-forge_{\mathcal{A},\Pi}(n)=1$ 当且仅当 $Vrfy_k(m,t)=1 \wedge m \notin \mathcal{Q}$.</li></ol><p>一个 MAC 是 secure 当且仅当 对于任何一个PPT的敌手 $\mathcal{A}$ , 都存在可忽略的函数 $negl$ ，使得 $$Pr[Mac-forge_{\mathcal{A},\Pi}(n)=1]\leq negl(n).$$</p><p>secure 保证了一个敌手不可能为一个先前未认证的<strong>新消息</strong>生成一个合法的tag , 但是并未保证敌手不能为已经认证的消息生成一个<strong>新的合法 tag</strong>, 于是有了 strongly secure</p><p>消息认证试验 $Mac-sforge_{\mathcal{A},\Pi}(n)$ :</p><ol><li>$k \leftarrow Gen(1^n)$ 对敌手保密.</li><li>给 $\mathcal{A}(1^n)$ 调用 $Mac_k(\cdot)$ 的能力，$\mathcal{A}$ 查询若干次，最终输出 $(m,t)$. 记 $\mathcal{Q}$ 为 $\mathcal{A}$ 所查消息和对应tag对的集合.</li><li>$\mathcal{A}$ 成功也即 $Mac-sforge_{\mathcal{A},\Pi}(n)=1$ 当且仅当 $Vrfy_k(m,t)=1 \wedge (m,t) \notin \mathcal{Q}$.</li></ol><p>一个 MAC 是 strongly secure 当且仅当 对于任何一个PPT的敌手 $\mathcal{A}$ , 都存在可忽略的函数 $negl$ ，使得 $$Pr[Mac-sforge_{\mathcal{A},\Pi}(n)=1]\leq negl(n).$$</p><p>显然典型的使用确定性的 secure 的 MAC 天然就是 strongly secure 的.</p><h4 id="如何使用-MAC">如何使用 MAC</h4><p>What if Alice needs to send a message in Q, (i.e. was sent previously)?</p><ul><li>Directly applying the MAC would cause repeated messages to be rejected.</li><li>One can append a unique timestamp or nonce to each message.</li></ul><h3 id="构造-secure-的-MAC">构造 secure 的 MAC</h3><h4 id="定长-MAC">定长 MAC</h4><p>如果有函数 $l$ 使得对于任意 $k \leftarrow Gen(1^n)$, $Mac_k$ 仅对  $m\in {0,1}^{l(n)}$ 上的消息有定义.</p><p>使用PRF！</p><p>令 $F$ 是 PRF . 对长为 n 的消息定义一个定长的 MAC：</p><ul><li>Mac : 输入密钥 $k\in {0,1}^n$ 和消息 $m\in{0,1}^n$,输出标签 $t:=F_k(m)$.</li><li>Vrfy: 输入密钥 $k\in {0,1}^n$ 消息 $m\in {0,1}^n$ 和标签 $t\in{0,1}^n$,输出1当且仅当 $t=F_k(m)$.</li></ul><p>若 $F$ 是 PRF ， 上述构造就是一个对长度为n的消息的 secure fixed-length MAC.</p><h4 id="处理长消息（定长）">处理长消息（定长）</h4><p>basic CBC-MAC: $F$ 是一个 PRF ， 以及长度函数 $l$</p><ul><li>Mac : 输入 $k \in {0,1}^n, m\in {0,1}^{n\cdot l(n)}$<ul><li>将 $m$ 分成 $l(n)$ 个长度为 $n$ 的块,</li><li>$t_0:= 0^n$,对 $i$ 从 1 到 $l(n)$, $t_i := F_k(t_{i-1} \oplus m_i)$</li><li>输出 $t_l$</li></ul></li><li>Vrfy : 输入 $k\in {0,1}^n, m, t$,输出1当且仅当 $|m|=n\cdot l(n) \wedge t=Mac_k(m)$.</li></ul><p><img src="/image/crypto/basic-cbc.png" alt="basic-cbc mode"></p><p>仍然仅能处理定长的消息！！！</p><h3 id="AE">AE</h3><p>消息的安全性和真实性都要！</p><h4 id="定义-2">定义</h4><p>一个私钥加密方案是 AE 的如果其是 CCA-secure 并且 unforgeable.</p><h4 id="CCA安全">CCA安全</h4><p>CCA安全由CCA indistinguishability experiment $PrivK_{\mathcal{A},\Pi}^{cca}(n)$ 定义：</p><ol><li>$k\leftarrow Gen(1^n)$</li><li>给敌手调用 $Enc_k(\cdot),Dec_k(\cdot)$ 的权限，敌手输出 $m_0,m_1$.</li><li>加密 $c\leftarrow Enc_k(m_b),b\overset{$}{\leftarrow}{0,1}$,将 $c$ 发送给敌手.</li><li>敌手调用  $Enc_k(\cdot),Dec_k(\cdot)$ ，但不允许直接调用 $Dec_k©$ ，输出$b’$.</li><li>$PrivK_{\mathcal{A},\Pi}^{cca}(n)=1$ 当且仅当 $b=b’$.</li></ol><p>私钥加密方案 $\Pi$ 是 $CCA-secure$ 的当且仅当对于任意PPT的敌手均有 $$Pr[PrivK_{\mathcal{A},\Pi}^{cca}(n)=1]\leq \frac{1}{2} + negl(n).$$</p><p>可延展性（malleable) 在不知道 $m$ 的前提下构造其密文. CCA安全推出了不可延展性.</p><h4 id="不可伪造性">不可伪造性</h4><p>不可伪造加密试验 $Enc-Forge_{\mathcal{A},\Pi}(n)$:</p><ol><li>$k\leftarrow Gen(1^n)$</li><li>敌手有调用 $Enc_k(\cdot)$ 的权限， 最终输出一个密文.</li><li>$m:=Dec_k©$ ， $Enc-Forge_{\mathcal{A},\Pi}(n)=1$ 当且仅当 密文合法且 $m$ 没被查过.</li></ol><p>私钥加密方案 $\Pi$ 是 unforgeable 当且仅当对于任意PPT的敌手均有 $$Pr[Enc-Forge_{\mathcal{A},\Pi}(n)=1]\leq  negl(n).$$</p><h4 id="构造AE">构造AE</h4><p>加密后验证！</p><p><img src="/image/crypto/encrpt-then-authenticate.png" alt="encrpt-then-authenticate"></p><p>$\Pi_E$ 是CPA安全的，$\Pi_M$ 是strongly secure MAC,那么上述构造是AE.</p><h2 id="哈希函数及其应用">哈希函数及其应用</h2><ul><li>哈希函数<ul><li>加密哈希函数</li><li>定义域扩展</li><li>例子</li></ul></li><li>MAC 和 Hash<ul><li>使用哈希函数扩展 MAC 的定义域</li><li>使用哈希函数构造 MAC</li></ul></li><li>哈希函数的应用</li><li>针对哈希函数一般攻击</li></ul><h3 id="哈希函数">哈希函数</h3><p>将长串映射到短串！！！</p><h4 id="加密哈希函数">加密哈希函数</h4><p>能在加密应用中使用的符合密码学要求的哈希函数，一般满足如下要求：</p><ul><li>collision resistant: It is difficult to find two different messages $m$ and $m′$ such that $hash(m) = hash(m′)$.</li><li>“completely unpredictable” (a.k.a. <strong>random oracles</strong>): The hash function is indistinguishable from a random mapping.</li></ul><h5 id="抗碰撞哈希函数">抗碰撞哈希函数</h5><p>我们将键控哈希函数 $H$ 视为一个以密钥 $s$ 和字符串 $x$ 为输入的函数 $H^s(x)=H(s,x)$.</p><p>这儿的密钥 $s$ 通常并不是随机采样出来的，而是由密钥生成算法 $Gen$ 生成的.此外，密钥 $s$ 并不保密…</p><p>输出长度为 $l$ 的哈希函数是这么一对 PPT 的算法 (Gen,H), 满足:</p><ul><li>$s \leftarrow Gen(1^n)$</li><li>$H$ 以密钥 $s$ 和串 $x\in{0,1}^*$ 为输入，输出串 $H^s(x) \in {0,1}^{l(n)}$.</li></ul><p>如果 $H^s$ 仅对定长 $l’(n)&gt;l(n)$ 的输入有定义，我们就称之为定长哈希函数，也叫compression function.</p><h5 id="碰撞检测试验">碰撞检测试验</h5><p>The collision-finding experiment $Hash\text{-}coll_{\mathcal{A},\Pi}(n)$:</p><ol><li>$s \leftarrow Gen(1^n)$</li><li>给敌手 $s$, 敌手输出 $x,x’$</li><li>$Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1$ 当且仅当 $H^s(x)=H^s(x’)$</li></ol><p>一个哈希函数 $\Pi=(Gen,H)$ 是抗碰撞（collision resistant）的当且仅当对任意PPT的敌手 $\mathcal{A}$ ,都有$$Pr[Hash\text{-}coll_{\mathcal{A},\Pi}(n)=1]\leq negl(n).$$</p><p>我们有时候省略掉 $Gen$ ，直接称 $H$ 或 $H^s$ 为抗碰撞哈希函数.此外，在实践中，有很多非键控抗碰撞哈希函数.</p><p><strong>更弱的抗碰撞</strong></p><ul><li>2nd p.r. 给一个均匀随机的 $x$，找 $x’$ 使得 $H^s(x)=H^s(x’)$.</li><li>p.r. 给一个均匀随机的 $y$, 找 $x’$ 使得 $y=H^s(x’)$.</li></ul><p>$$ c.r. \Rightarrow 2nd\ p.r. \Rightarrow p.r.$$</p><h4 id="定义域扩展">定义域扩展</h4><p>使用定长的 c.r. 哈希来构造对任意长度的哈希.</p><p>Merkle-Damgard Transform:</p><ul><li>“Partition and Padding”.<ul><li><img src="/image/crypto/Partition_and_Padding.png" alt="Partition and Padding"></li></ul></li><li>“Chained-Compressing”.<ul><li><img src="/image/crypto/Chained-Compressing.png" alt="Chained-Compressing"></li></ul></li></ul><blockquote><p>If (Gen, h) is collision resistant, the (Gen, H) is also collision resistant.<br>Pf. 考虑 $|x|=|x’|$ 和 $|x|\neq|x’|$ 两种情况.</p></blockquote><h3 id="MAC-与-哈希">MAC 与 哈希</h3><h4 id="Hash-and-MAC">Hash and MAC</h4><p>至此，我们有对定长消息做认证的MAC，也有将任意长度的串映射到定长串的Hash，二者的结合注定发生奇妙的化学反应.</p><p>令 $\Pi=(Mac,Vrfy)$ 是对长度为 $l(n)$ 的消息的 MAC , $\Pi_H=(Gen_H,H)$ 是输出为定长 $l(n)$ 的哈希函数, 构造一个MAC $\Pi’=(Gen’,Mac’,Vrfy’)$ 适用于任意长度的消息：</p><ul><li>Gen’: 输入 $1^n$ ，均匀选择 $k\in{0,1}^n$ , 运行 $Gen_H(1^n)$ 得到 $s$ , 密钥 $k’:=&lt;k,s&gt;$.</li><li>Mac’: 输入密钥 $&lt;k,s&gt;$ , 和任意长度的消息 $m\in{0,1}^*$ , 输出 $t \leftarrow Mac_k(H^s(m))$.</li><li>Vrfy’: 输入密钥 $&lt;k,s&gt;$ , 消息 $m\in{0,1}^*$ , tag $t$ , 输出1当且仅当 $Vrfy_k(H^s(m),t)=1$.</li></ul><p>如果 $MAC$ 是secure的 , 且 $\Pi_H$ 是抗碰撞的， 那么上述构造是对任意长度的消息的一个secure的MAC.（Pf.两种情况分别规约到c.r. Hash和secure MAC上）</p><h4 id="HMAC">HMAC</h4><p><img src="/images/HMAC.png" alt="HMAC"></p><h3 id="针对哈希的一般攻击">针对哈希的一般攻击</h3><p>由鸽巢原理，找 $2^{l+1}$ 个值总能找到碰撞 $\Theta(2^l)$, 有没有可能少找一些期望有一定概率找到呢？</p><p>生日问题：</p><blockquote><p>If q people are in a room, what is the probability that two of them have the same birthday?</p></blockquote><p>若 $y_1,…,y_q$ 是从 ${1,…,N}$ 中均匀抽取的，当 $q=\Theta(N^{1/2})$ 时，有接近 1/2 的概率存在碰撞.</p><blockquote><p>The above imply that a hash function with n-bit output is limited to n/2 bits of security.</p></blockquote><h2 id="单向函数与硬核谓词-Hard-Core-Predicates">单向函数与硬核谓词(Hard-Core Predicates)</h2><ul><li>单向函数</li><li>OWF候选名单</li><li>硬核谓词<ul><li>任意OWF的硬核谓词</li></ul></li><li>使用OWF构造PRG</li></ul><h3 id="单向函数">单向函数</h3><p>什么是OWF？</p><ul><li>easy to compute</li><li>hard to invert</li></ul><p>我们给出OWF的<strong>形式化定义</strong>.一个函数 $f:{0,1}^* \rightarrow {0,1}^*$ 是 <strong>one-way</strong> 如果满足以下两个条件：</p><ol><li>Easy to compute : 存在PPT的算法 $M_f$ 来计算 f (多项式时间内可计算)</li><li>Hard to invert: $\forall PPT \mathcal{A} , Pr_{x\overset{$}{\leftarrow}{0,1}^n}[\mathcal{A}(1^n,f(x))\in f^{-1}(f(x))]\leq negl(n)$.</li></ol><p>注意，此处的 $x\overset{$}{\leftarrow}{0,1}^n$ 是均匀选取的，并且我们只要求给出原象，不求给出 $x$ 本身.</p><p>我们当然也有inverting experiment $Invert_{\mathcal{A},f}(n)$:</p><ol><li>均匀选取 $x\in{0,1}^n$ , 计算 $y:=f(x)$</li><li>敌手以 $y$ 为输入， 输出 $x’$</li><li>$Invert_{\mathcal{A},f}(n)=1/ iff./ f(x’)=y$</li></ol><p>Hard to invert: 对任意PPT的敌手 $\mathcal{A}$ , $Pr[Invert_{\mathcal{A},f}(n)=1]\leq negl(n)$.</p><h3 id="OWF的候选名单">OWF的候选名单</h3><p>事实上，我们并不知道是不是真的有OWF:(但是我们还是有些候选函数，至少我们至今没有发现PPT的算法来invert它们…</p><ul><li>整数分解</li><li>子集和问题</li><li>离散对数问题</li></ul><h3 id="硬核谓词-Hard-Core-Predicates">硬核谓词(Hard-Core Predicates)</h3><p>$f(x)$ 是OWF意味着我们无法从 $f(x)$ 中还原出 $x$, 但并不意味着 $f(x)$ 不会泄露 $x$ 的信息，就比如 $f(x_1||x_2)=x_1||g(x_2)$.</p><p>我们定义函数 $f$ (不一定是OWF) 的硬核谓词 $hc:{0,1}^*\rightarrow {0,1}$ 如果 $hc$ 可以在多项式时间内计算，并且对任意PPT的 $\mathcal{A}$ 有 $$Pr_{x\overset{$}{\leftarrow}{0,1}^n}[\mathcal{A}(1^n,f(x))=hc(x)]\leq 1/2 + negl(n)$$.</p><p>这儿的 $x\overset{$}{\leftarrow}{0,1}^n$ 依然是均匀选取的.另外，我们没要求函数 $f$ 一定是OWF.</p><h4 id="任意OWF的硬核谓词">任意OWF的硬核谓词</h4><p><strong>Goldreich-Levin Theorem</strong>: Assume one-way function (resp. permutation) exists. Then there exists a one-way function (resp. permutation) $g$ and a hard-core predicate $hc$ of $g$.</p><p><img src="/image/crypto/Goldreich-Levin-Theorem.png" alt="Goldreich-Levin Theorem"></p><p>这里的 $r$ 是均匀随机选取的.</p><h3 id="使用OWF构造PRG">使用OWF构造PRG</h3><p>令 $f$ 是一个one-way permutation，$hc$ 是 $f$ 的硬核谓词，那么 $G(s)=f(s)||hc(s)$ 是一个 PRG 扩展因子为 $l(n)=n+1$.</p><p>下面开始叠叠乐！</p><p>如果有一个 扩展因子为 $n+1$ 的PRG，那么对任意多项式 $poly$ ，存在PRG $\hat{G}$ 扩展因子为 $poly(n)$.</p><p><img src="/image/crypto/polyPRG.png" alt="polyPRG"></p><h2 id="数论与密码学困难度假设">数论与密码学困难度假设</h2><h3 id="基础知识">基础知识</h3><p>带余除法唯一表示：$$a \in \mathbb{Z} , b \in \mathbb{Z}<em>+ , \exists \ unique\ q,r \in \mathbb{Z}, s.t.\ a=qb+r,\ 0\leq r\leq b.$$<br><strong>最大公因数</strong> $$a,b\in \mathbb{Z}</em>+, \exists X,Y \in \mathbb{Z},\ s.t.\ Xa+Yb=gac(a,b).$$<br>此外，$gcd(a,b)$ 是满足上述方程的最小正整数.</p><blockquote><p>欧几里得算法与拓展欧几里得算法.</p></blockquote><p>对大于等于1的整数 $b,N$ , $b$ 在模 $N$ 意义上有逆元当且仅当 $gcd(b,N)=1$.</p><blockquote><p>拓展欧几里得算法.</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">exgcd</span><span class="hljs-params">(<span class="hljs-type">int</span> a, <span class="hljs-type">int</span> b, <span class="hljs-type">int</span>&amp; x, <span class="hljs-type">int</span>&amp; y)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (b == <span class="hljs-number">0</span>) &#123;<br>    x = <span class="hljs-number">1</span>, y = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-built_in">exgcd</span>(b, a % b, y, x);<br>  y -= a / b * x;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>群</strong>是一种代数结构，由一个集合 $\mathbb{G}$ 和定义在集合上的二元运算 $\circ$ 构成，满足:</p><ul><li>封闭性</li><li>结合律</li><li>有逆元</li><li>有单位元<br><img src="/image/crypto/group.png" alt="group"></li></ul><p>$N=\Pi_i p_i^{e_i} $ , 其中 $p_i$ 是不同的素数， $e_i\geq 1$, 那么有 $\phi(N)=\Pi_i p_i^{e_i-1}(p_i-1)$.</p><p>$g^0\overset{def}{=}1,g^{-m}\overset{def}{=}(g^{-1})^m$.</p><p>令 $\mathbb{G}$ 是有限群 $m=|\mathbb{G}|$ ,则 $\forall g \in \mathbb{G} ,g^m=1$.</p><p><strong>Fermat-Euler Theorem</strong> $\forall N&gt;1, a\in Z_N^* ,a^\phi(N)=1\ mod\ N.$</p><blockquote><p>Fermat-Euler Theorem 在计算模下求幂和非素性检测有用</p></blockquote><h3 id="中国剩余定理">中国剩余定理</h3><p>常用来解同余方程.</p><p><img src="/image/crypto/CRT.png" alt="CRT"></p><blockquote><p>from <a href="https://oi-wiki.org/math/number-theory/crt/#%E5%BC%95%E5%85%A5">OI-Wiki</a></p></blockquote><p>群论下的中国剩余定理：</p><p><img src="/image/crypto/gCRT.png" alt="gCRT"></p><p>求逆：</p><p><img src="/image/crypto/crt-eg3.png" alt="crt-eg3"></p><p><img src="/image/crypto/crt-eg3-.png" alt="crt-eg3—"></p><h3 id="Factoring-Assumption">Factoring Assumption</h3><p><strong>$GenModulus(1^n)$</strong>:</p><ul><li>输出 $(N,p,q)$</li><li>$N=pq$</li><li>除可忽略的概率 $negl(n)$ 外，$p,q$ 均为 $n-bit$ 素数.</li></ul><p><strong>The factoring experiment</strong> $Factor_{\mathcal{A},GenModulus}(n)$:</p><ol><li>$(N,p,q) \leftarrow GenModulus(1^n)$</li><li>给 $\mathcal{A}$ $N$ , 要其输出 $p’,q’$</li><li>$Factor_{\mathcal{A},GenModulus}(n)=1$ iff. $N=p’q’$.</li></ol><p><strong>Factoring is hard relative to GenModulus</strong> if for all PPT algorithms $\mathcal{A}$ there exists a negligible function $negl$ such that $$Pr[Factor_{\mathcal{A},GenModulus}(n)=1]\leq negl(n).$$</p><p><strong>Factoring Assumption</strong>就是假设存在这么一个<strong>GenModulus</strong>使factoring是hard的.</p><h3 id="RSA-problem">RSA problem</h3><p>$GenRSA(1^n)$ :</p><ul><li>输出 $(N,e,d)$</li><li>$N$ 是两个 $n-bit$ 素数的乘积</li><li>$gcd(e,\phi(N))=1, ed=1\ mod\ \phi(N)$</li></ul><p>The RSA experiment $RSA-inv_{\mathcal{A},GenRSA}(n)$:</p><ol><li>$(N,e,d)\leftarrow GenRSA(1^n)$</li><li>均匀选取 $y\in \mathbb{Z}_N^*$.</li><li>给 $\mathcal{A}$ $(N,e,y)$ , 输出 $x\in \mathbb{Z}_N^*$</li><li>$RSA-inv_{\mathcal{A},GenRSA}(n)=1$ iff. $x^e=y$.</li></ol><p><strong>The RSA problem is hard relative to GenRSA</strong> if for all PPT algorithms $\mathcal{A}$ there exists a negligible function $negl$ such that $$Pr[RSA-inv_{\mathcal{A},GenRSA}(n)=1]\leq negl(n).$$</p><p><strong>RSA Assumption</strong>就是假设存在这么一个<strong>GenRSA</strong>使RSA problem是hard的.</p><h3 id="循环群">循环群</h3><p><img src="/image/crypto/cyclic_group.png" alt="cyclic_group"></p><h3 id="离散对数问题">离散对数问题</h3><p>对于 $h\in \mathbb{G}$ , $\mathbb{G}$ 是一个循环群, 存在唯一的 $x\in Z_q, q=|\mathbb{G}|$, 使得 $g^x=h$, 我们称 $x$ 是 $h$ 的离散对数 w.r.t $g$ , 写作 $x=log_g\ h$.</p><p>离散对数问题就是求解一个在循环群上均匀抽取的元素的离散对数，可定义为以下试验.</p><p>The discrete-logarithm experiment $DLog_{\mathcal{A},\mathcal{G}}$:</p><ol><li>$(\mathbb{G},q,g)\leftarrow \mathcal{G}(1^n)$, 其中 $\mathbb{G}$ 是循环群, $q=|\mathbb{G}|,\overline{||q||=n}$, $g$ 是生成元.</li><li>$h \overset{$}{\leftarrow} \mathbb{G} $</li><li>给 $\mathcal{A}$ 输入 $\mathbb{G},q,g,h$ , 其输出 $x\in \mathbb{Z}_q$.</li><li>$DLog_{\mathcal{A},\mathcal{G}}=1$ iff. $g^x=h$.</li></ol><p>We say that **the discrete-logarithm problem is hard relative to $\mathcal{G}$ **if for all PPT algorithms $\mathcal{A}$ there exists a negligible function $negl$ such that $$ Pr[DLog_{\mathcal{A},\mathcal{G}}=1]\leq negl(n) .$$</p><p>离散对数假设就是假定存在这么一个 $\mathcal{G}$.</p><h3 id="D-H-Problem">D-H Problem</h3><p>The <strong>computational</strong> D-H (CDH) problem: Given $g$, $g^x$ and $g^y$, can you compute $g^{xy}$?</p><p>The <strong>decisional</strong> D-H (DDH) problem: Given $g$, $g^x$, $g^y$, and g^{xy}, can you differentiate $g^{xy}$ from a uniform random group element $g^z$?</p><p>The D-H assumptions are assumptions that there exists instances of CDH/DDH problem which are hard.</p><blockquote><p>Closed related to the discrete-logarithm problem, but <strong>not known</strong> to be equivalent.</p></blockquote><h2 id="密钥管理与公钥加密变革">密钥管理与公钥加密变革</h2><h3 id="KDC">KDC</h3><p>A secure key-distribution protocol using a KDC:</p><p><img src="/image/crypto/Needham-Schroeder.png" alt="Needham-Schroeder"></p><h3 id="D-H-key-exchange-protocol">D-H key-exchange protocol</h3><p>D-H key-exchange protocol 的构造如下，其中 $\mathbb{G}$ 是循环群, $q=|\mathbb{G}|,||q||=n$, $g$ 是生成元$:</p><p><img src="/image/crypto/D-H-exchange.png" alt="D-H-exchange"></p><p><strong>安全性</strong>：我们把脚本协议双方来往的所有信息记录下来丢给敌手，如果敌手在此加持下无法区分真正的密钥和一个随机抽取的假密钥，那么协议应该是安全的。具体的：</p><p><img src="/image/crypto/KE.png" alt="KE"></p><p>A key-exchange protocol $\Pi$ is secure in the presence of an eavesdropper if for all PPT adversaries $\mathcal{A}$ there is a negligible function $negl$ such that $$ Pr[KE^{eav}_{\mathcal{A},\Pi}(n) = 1] ≤ 1/2+ negl(n).$$</p><p><img src="/image/crypto/KEsecure.png" alt="KEsecure"></p><blockquote><p>我们在这儿使用了KE试验的变体，证明时将DDH问题规约到KE上来.</p></blockquote><h2 id="公钥加密">公钥加密</h2><h3 id="定义-3">定义</h3><p>公钥加密方案是一个PPT算法的三元组(Gen,Enc,Dec),其中Gen生成一对密钥(pk,sk),Enc使用公钥pk进行加密,Dec则使用私钥sk进行解密.具体的<strong>定义</strong>见下图：</p><p><img src="/image/crypto/public-key_encryption.png" alt="public-key_encryption"></p><h3 id="安全性">安全性</h3><h4 id="CPA">CPA</h4><p>在下图所定义的EAV试验中，敌手 $\mathcal{A}$ 是被给予了 $pk$ 的，以及试验中的加密采用了公钥加密方案，除此之外和私钥加密时定义的EAV试验是一样的。但是正由于敌手被给予了 $pk$ ，而加密方案又是公开的，因此敌手相当于得到了Enc的权限，从而一旦secure天然就有CPA-secure.</p><p><img src="/image/crypto/pubeav.png" alt="pubeav"></p><p>同样我们有根据试验所定义的<strong>安全性</strong>.</p><p><img src="/image/crypto/Pub-secure.png" alt="Pub-secure"></p><p>如果一个公钥加密方案是CPA-secure，它对多消息加密天然也是CPA-secure的.</p><p>此外，定长的CPA-secure加密可以推出任意长的CPA-secure加密(切成定长块，和多消息加密差不多了就).</p><h4 id="CCA">CCA</h4><p>私钥当然是不能给敌手的，因此敌手还是以神谕基的形式调用Dec.</p><p><img src="/image/crypto/CCA-secure.png" alt="CCA-secure"></p><p>我们当然也有基于试验的安全性定义.</p><p><img src="/image/crypto/CCA-secure-def.png" alt="CCA-secure-def"></p><p>如果一个公钥加密方案是CCA-secure，它对多消息加密天然也是CCA-secure的.但是我们无法将定长CCA安全方案推广到任意长了，因为敌手完全可以打乱顺序进行解密…</p><h3 id="杂交加密">杂交加密</h3><p><img src="/image/crypto/hybrid-encryption.png" alt="hybrid-encryption"></p><p>KEM: 一个黑盒，输入公钥，为私钥加密生成对应的私钥和私钥密文.</p><p>DEM: 也就是公钥加密.</p><blockquote><p>A key-encapsulation mechanism (KEM) is a public-key primitive that efficiently generates an encryption key for the private-key encryption k and its ciphertext c in a hybrid encryption scheme. Accordingly, the private-key encryption scheme is called a data-encapsulation mechanism (DEM) here.</p></blockquote><p><img src="/image/crypto/KEM-DEM.png" alt="KEM-DEM"></p><h3 id="CDH-DDH-Based-Encryption">CDH/DDH-Based Encryption</h3><p>The El Gamal encryption scheme is described in the following:</p><p><img src="/image/crypto/El-Gamal-encryption.png" alt="El-Gamal-encryption"></p><p>安全性：</p><p><img src="/image/crypto/El-Gamal-encryption-secure.png" alt="El-Gamal-encryption-secure"></p><blockquote><p>构造一个完全随机的 $&lt;g^y,g^z\cdot m$ 来证明.</p></blockquote><p>El Gamal encryption 不是CCA安全的！！！具有延展性($&lt;c_1,c_2&gt;,&lt;c_1^2,c_2^2&gt;$).</p><h3 id="RSA">RSA</h3><h4 id="Plain-RSA">Plain RSA</h4><p><img src="/image/crypto/RSA-key-generation.png" alt="RSA-key-generation"></p><p><img src="/image/crypto/plain-RSA-encryption-scheme.png" alt="plain-RSA-encryption-scheme"></p><p>plainRSA不是CPA安全的.事实上任何确定性的公钥加密算法都不会是CPA安全的！此外，我们无法通过RSA assumption来证明其安全性…</p><h4 id="Padded-RSA">Padded RSA</h4><p><img src="/image/crypto/Padded-RSA.png" alt="Padded-RSA"></p><p><img src="/image/crypto/PKCS.png" alt="PKCS"></p><h2 id="数字签名机制">数字签名机制</h2><p>TBD</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CRYPTO </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>成长的短视</title>
      <link href="/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/"/>
      <url>/2024/10/24/%E6%88%90%E9%95%BF%E7%9A%84%E7%9F%AD%E8%A7%86/</url>
      
        <content type="html"><![CDATA[<p>小百合系版&quot;有像我一样不会写代码的cser么?&quot;回复节选</p><ul><li>我们都是活生生的人, 从小就被不由自主地教导用最小的付出获得最大的得到, 经常会忘记我们究竟要的是什么. 我承认我完美主义, 但我想每个人心中都有那一份求知的渴望和对真理的向往, &quot;大学&quot;的灵魂也就在于超越世俗, 超越时代的纯真和理想 --我们不是要讨好企业的毕业生, 而是要寻找改变世界的力量. – jyy</li><li>教育除了知识的记忆之外, 更本质的是能力的训练, 即所谓的training. 而但凡training就必须克服一定的难度, 否则你就是在做重复劳动, 能力也不会有改变. 如果遇到难度就选择退缩, 或者让别人来替你克服本该由你自己克服的难度, 等于是自动放弃了获得training的机会, 而这其实是大学专业教育最宝贵的部分. – etone</li><li>这种&quot;只要不影响我现在survive, 就不要紧&quot;的想法其实非常的利己和短视: 你在专业上的技不如人, 迟早有一天会找上来, 会影响到你个人职业生涯的长远的发展; 更严重的是, 这些以得过且过的态度来对待自己专业的学生, 他们的survive其实是以透支南大教育的信誉为代价的 – 如果我们一定比例的毕业生都是这种情况, 那么过不了多久, 不但那些混到毕业的学生也没那么容易survive了, 而且那些真正自己刻苦努力的学生, 他们的前途也会受到影响. – etone</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>名师导学期中</title>
      <link href="/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/"/>
      <url>/2023/12/20/%E5%90%8D%E5%B8%88%E5%AF%BC%E5%AD%A6%E6%9C%9F%E4%B8%AD/</url>
      
        <content type="html"><![CDATA[<h1>关于高效寻找适用于锂-空气电池催化剂的思考</h1><h2 id="介绍研究背景和现状">介绍研究背景和现状</h2><h3 id="研究背景">研究背景</h3><p>煤、石油、天然气等化石能源的日益枯竭，以及化石燃料燃烧带来的诸多环境问题，迫使人们寻求、开发清洁高效的可再生能源和储能系统。锂-空气电池（$Li-O_2$电池）以金属锂作为负极，从空气中直接获取氧气进行正极反应而无需将氧气存储在电池内部，具有非常高的理论比能量(约$11140Wh·kg^{-1}$)，这一数值非常接近汽油的理论比能量（约$13kWh·kg^{-1}$）。这使得锂-空气电池在新能源汽车领域有着较好的应用前景，受到了人们的广泛关注。相关领域经过多年发展，针对锂-空气电池的研究逐渐深入，成果显著，锂-空气电池也是被视为极具应用前景的下一代储能系统之一，但锂-空气电池体系仍存在一些亟待解决的技术问题。</p><h3 id="研究现状">研究现状</h3><p>依据工作环境和介质条件的不同，当前被研究最多的锂空气电池主要是有机电解液、有机-水组合电解液以及全固态电解质三种类型。</p><p>有机体系锂-空气电池的结构相对简单，符合经典的摇椅式电池结构，能量密度最高、体系最为稳定。其选择溶解有钾盐的有机溶剂为电解液，如醚、烯酯等。放电时，氧气在正极被还原并与电解液里的$Li^+$结合，金属锂在负极被氧化生成 $Li^+$进入电解液。虽然正极的反应方式容易使人们联想到氢氧燃料电池，但与氢氧燃料电池不同的是，锂-空气电池放电会产生锂的绝缘难溶氧化物，可能会使空气通道被阻塞、电池极化增大从而导致放电提前终止，从而影响放电容量。另外，由于金属锂的活泼性，空气中的水、二氧化碳等诸多成分都会造成金属锂的腐蚀，影响电池寿命。事实上，已经有研究报道了水分子（相对湿度）对有机锂-空气电池的影响：水分子会使得放电容量有所增加，但会对电池的循环性能和倍率性能造成负面影响$^4$。除此之外，有机体系锂-空气电池还存在着充放电过程空气正极过电位过大、充放电效率低等问题，对催化剂的性能、催化剂的稳定性提出了较高的要求，这也是当前许多研究人员正在关注、研究的重要课题。</p><p>为解决有机体系中正极反应会生成绝缘难溶氧化物问题，周豪慎教授研究组首先提出有机-水组合电解液型锂-空气电池。在这种锂-空气电池里，$LiOH$水溶液和有机电解液分别与电池的正负极接触，二者用$LISICON$隔开。研究表明，该类型电池可连续放电$500h$以上，比容量高达$50000mAh·g^{-1}$。在后续研究中，研究人员针对$LISICON$在碱性环境不稳定等问题进行了改进，进一步提高了电池的稳定性与能量密度。另外，在组合电解液型电池的基础上，研究人员还提出了液流型锂-空气电池。有机-水组合电解液和液流型锂-空气电池都解决了有机电解液型电池中存在的正极产生绝缘氧化物影响电池性能的问题，更为接近燃料电池，同时使电池受空气中其他成分影响大幅减小，持续放电能力增强$^4$。但此类型电池对隔膜材料的稳定性和离子电导率提出了较高要求，仍存在较大过电位损失这一问题。</p><p>事实上，虽然锂-空气电池理论能量密度高，应用潜力巨大，但还无法真正实现商业化，仍有诸多问题亟待解决：</p><ul><li>正极充放电过程有较大的过电位</li><li>实际容量要比理论容量低</li><li>循环过程中的容量衰减较大</li></ul><h2 id="提出重要科学问题">提出重要科学问题</h2><p>当前的锂-空气电池的空气正极在充放电过程中均存在有较大的过电位问题，这使得空气正极被视作限制锂-空气电池发展的一大重要因素，寻找合适的催化剂可能有效缓解、甚至解决这一问题。事实上，为解决这一问题，早有国内外研究人员对不同相中的氧还原反应深入研究，试图找到廉价、高效、稳定的催化剂材料$^5$。既然寻找催化材料如此重要，我们是否有方法加速寻找适用于锂-空气电池的催化剂材料？</p><h2 id="对问题的分析和研究">对问题的分析和研究</h2><p>当前计算机技术飞速发展，机器学习已在诸多领域有了广泛应用，例如机器学习已成为高效预测蛋白质功能的有效手段，在酶功能预测领域有了广泛应用$^1$。而酶本身是一种高效的有机催化剂，是否也可以利用机器学习等计算机技术帮助我们高效设计、寻找高效稳定的催化剂材料来有效解决锂-氧气电池存在的过电位问题呢？本文余下内容旨在讨论机器学习等计算机技术协助寻找、开发合适的催化剂材料助力锂-空气电池发展的可能性与展望。</p><p>首先是利用机器学习来加速寻求高效稳定的催化剂材料的可能性。机器学习等数据科学能够为研究人员提供了快速灵活的预测框架，在材料研发等领域展现出极大的应用前景。</p><p>在电池领域，机器学习已有诸多应用。锂离子电池能量密度高，循环次数多，广泛应用于移动设备和电动汽车领域。但锂离子电池的寿命难以预测，使得对人们不得不花费大量的时间与成本做破坏性实验来得到某种电池的寿命数据。这就导致在用户的实际应用中，由于缺乏电池的剩余寿命数据，无法准确制定电源计划。另外，锂离子电池的剩余电量甚至也无法通过传统方法来精准预测。而随着人工智能技术的发展，研究人员发现可以利用深度学习等技术很好的解决这些问题。人们只需要提供电池使用一段时间的相关数据，就可利用机器学习技术，参照过去得到的数据信息，精准预测电池的剩余寿命和剩余电量$^2$。与我们论题更为相关的电池材料方面，机器学习也已经在发挥重要作用。各种材料具有复杂的不同的性质，当人们采用不同的材料组合时，这些材料的性质相互影响叠加在一起才能决定电池的实际性能。人工穷举所有的材料组合显然是个难以完成的任务，而机器学习技术可以利用计算机的计算、存储能力，通过学习过去已有的实验资料高效而准确的筛选材料组合，从而大幅提高研发效率$^2$。</p><p>在催化剂领域，机器学习也早已有了广泛的应用。除去上文提及的对酶的结构、功能的预测外，机器学习在无机催化领域也发挥着巨大的作用。温室效应的加剧是人们不得不面临的一个问题便是对$CO_2$的处理。二氧化碳的电还原便是实现二氧化碳回收的重要方法之一。和锂-空气电池类似，此技术需要寻找高性能的电催化剂。近些年，诸多研究者利用大数据来辅助新型催化剂的开发，提高了开发效率，降低了开发成本，加速了二氧化碳电还原技术的发展$^2$。此外，机器学习在搜寻新型双钙钛矿氧化物光催化剂领域也起到了重要的加速作用$^3$。</p><p>锂-空气电池的空气正极通常包括防水层、集流体、催化层等部分$^4$。多数情况，开发可有效降低锂-空气电池过电位的催化材料可以视为开发合适的电池材料的一个子任务。由上述介绍，我们知道机器学习已经在催化化学领域和电池材料领域有了广泛而重要的应用，利用机器学习等技术来加速研发适用于锂-空气电池的高效、稳定催化材料显然也是可能的。</p><h2 id="结果讨论与展望">结果讨论与展望</h2><p>正如上文所述，利用机器学习技术加速开发合适的正极催化材料来有效缓解、解决锂-空气电池充放电过程中的较大过电位问题是可能的。机器学习等方法相当依赖训练数据，为了得到更好的预测结果，除了需要选择、开发更合适的算法之外，还需要建立、完善相应的数据库，已加强训练效果。此外，选择、开发合适的算法涉及到学科交叉，这意味着数据科学研究者和自然科学家之间需要进行充分的对接。最后，机器学习方法不应与理论分析分离。由于机器学习归根结底是依靠训练数据进行猜测，在未训练到的方面是不可靠的，纵使在已经得到充分训练的领域，在对其结果进行应用前也应对进行相应理论分析和实验研究，方能放心使用。</p><p>综上所述，相信借助机器学习技术的辅助能使锂-空气电池技术加速发展，从而推动能源技术发展，进而助力人类社会可持续发展。</p><h2 id="参考文献">参考文献</h2><ol><li>池燕飞, 李春, 冯旭东. 机器学习在蛋白质功能预测领域的研究进展[J]. 生物工程学报, 2023, 39(6): 2141-2157.</li><li>许建兵, 李翰实, 谭济民, 等. 机器学习在固体氧化物燃料电池, 锂电池, CO2 电还原催化剂中的研究进展[J]. 硅酸盐学报, 2022, 50(11).</li><li>万新阳, 章烨辉, 陆帅华, 等. 机器学习加速搜寻新型双钙钛矿氧化物光催化剂[J]. 物理学报, 2022.</li><li>童圣富, 何平, 张雪苹, 等. 基于有机和组合电解液的锂空气电池研究进展[J]. 电化学, 2015, 21(3): 234.</li><li>王迪, 乔羽, 邓瀚, 等. 锂-空气电池研究进展与表征方法[J]. 催化学报, 2019, 40(s1): 217.</li></ol>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> general course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Review for Principles of Marxism</title>
      <link href="/2023/12/19/Review-for-Principles-of-Marxism/"/>
      <url>/2023/12/19/Review-for-Principles-of-Marxism/</url>
      
        <content type="html"><![CDATA[<h1>马原复习</h1><blockquote><p>搬运自本人大一下马原复习文档</p></blockquote><h2 id="马克思主义">马克思主义</h2><ul><li><strong>马克思主义</strong>：由马克思和恩格斯创立，并为后继者所不断发展的科学理论体系，是关于科学社会以及人类思维发展的一般规律的学说，是关于社会主义必将代替资本主义最终实现共产主义的学说，是关于无产阶级解放、全人类解放和每个人自由而全面发展的学说，是无产阶级政党和社会主义国家的指导思想，是指引人民创造美好生活的行动指南。</li><li><strong>马克思主义的基本组成部分</strong>：马克思主义哲学、马克思主义政治经济学、科学社会主义。</li><li><strong>创立</strong>：三大先进思潮是德国古典哲学、英国古典政治经济学、英法空想社会主义。</li><li><strong>特征</strong>：科学性、人民性、实践性、发展性。</li></ul><h2 id="物质">物质</h2><ul><li><strong>物质</strong>：是标志客观实在的哲学范畴，这种客观实在是人通过感觉感知的，不依赖我们的感觉而存在，为我们的感觉所复写、摄影、反映。</li><li><strong>哲学基本问题</strong>：一、存在和思维、物质和意识谁为本源的问题，即何者为第一性的问题（产生了唯物和唯心）；二、存在和思维、物质和意识是否具有同一性的问题，即思维能否正确反映存在，人能否认识和正确认知世界的问题（产生了可知论和不可知论）。</li><li><strong>马克思理论意义</strong>：坚持唯物主义一元论（非唯心一元or二元论），坚持能动的反映论和可知论，批判不可知论，体现了唯物论和辩证论的统一，克服形而上学唯物主义的缺陷，体现唯物主义自然观和历史观的统一，为彻底的唯物主义奠定了理论基础。</li><li><strong>物质和意识的相互作用</strong>：1.意识是人脑的机能和属性，是客观世界的主观映像，物质对意识的决定作用表现在意识的本质和起源上：意识在内容上是客观的，在形式上是主观的，体现了主观与客观形式的统一。2.物质决定意识，意识对物质具有反作用，这种反作用是意识的能动作用，表现在：第一，意识具有目的性和计划性；第二，意识具有创造性；第三，意识可以指导实践改造客观世界；第四，意识可以调控人的行为和生理活动。</li><li><strong>意识与人工智能</strong>：人工智能是人的意识能动性的一种特殊表现，是人的本质力量的对象化和现实化。人工智能不能超越人类。第一，人类意识是知情意的统一体，而人工智能只是对人类的理性智能的模拟和扩展，不具备情感、信念、意志等人类意识形态。第二，社会性是人类意识所固有的本质属性，而人工智能不可能真正具备人类的社会属性。第三，人类的自然语言是思维的物质外壳和意识的现实形式，而人工智能难以完全具备理解自然语言真实意义的能力。</li></ul><h2 id="实践和认识">实践和认识</h2><ul><li><strong>科学实践观的意义</strong>：1.克服了旧唯物主义的根本缺陷，为辩证唯物主义奠定了科学的理论基础；2.建立了科学的、能动的、革命的反映论，实现了人类认识史上的变革；3.在人类思想史上第一次揭示了社会生活的实践本质，为创建科学的历史观奠定了理论基础；4.为人类能动的认识和改造世界提供了基本的思想方法和工作方法。</li><li><strong>实践对认识的决定作用</strong>：实践是认识的来源，是认识发展的动力，是认识的目的，是检验认识真理性的唯一标准。</li><li><strong>实践的本质</strong>：是人类能动的改造世界的社会性的物质活动，具有客观实在性、自觉能动性和社会历史性三个基本特征。</li><li><strong>实践的结构</strong>：实践主体、实践客体、实践中介。</li><li><strong>实践的过程</strong>：实践目的的确定、主体通过中介或手段作用于客体、实践结果的检验和评价。</li><li><strong>认识的本质</strong>：主体在实践基础上对客体的能动反映，这是辩证唯物主义认识论对认识本质的科学回答。唯心主义认识路线否认认识是人脑对客观世界的反映，认为认识先于人的实践经验。旧唯物主义认识论以感性直观为基础，把人的认识看成消极的、被动的反映和接受外界对象，是直观的、消极被动的反映论。</li><li><strong>真理</strong>：是标志主观和客观相符合的哲学范畴，是对客观事物及其规律的正确反映。</li><li><strong>谬误</strong>：所谓谬误，是同客观事物及其发展规律相违背的认识，是对客观世界及其发展规律的歪曲反映。</li><li><strong>价值</strong>：价值是指在实践基础上形成的主体和客体之间的意义关系，是客体对个人、群体乃至整个社会的生活和活动所具有的积极意义。</li><li><strong>真理与谬误的关系</strong>：第一，二者相互对立；第二，二者的对立是相对的，它们在一定条件下能够相互转化；第三，真理和谬误的对立统一关系表明，真理总是同谬误相比较而存在、相斗争而发展的。实践是检验真理的唯一标准。</li></ul><h2 id="人类社会的发展规律">人类社会的发展规律</h2><ul><li><strong>社会存在</strong>：社会存在是指社会物质生活条件，是社会生活的物质方面，主要包括自然地理环境、人口因素和物质生产方式。</li><li><strong>唯物史观和唯心史观</strong>：马克思主义产生之前，唯心史观占据统治地位。</li><li><strong>社会意识</strong>：是社会存在的反映，是社会生活的精神方面，社会意识是人们进行社会物质交往的产物。</li><li><strong>社会存在和社会意识的辩证关系</strong>：1.社会存在决定社会意识。社会意识是对社会存在的反映，并反作用于社会存在，社会存在的变化发展决定社会意识的变化发展；2.社会存在是社会意识的内容的客观来源，社会意识是社会物质生活过程及其条件的主观反映；3.社会意识具有相对独立性，社会意识有时会落后于社会存在，有时会先于社会存在而变化发展；4.社会意识对社会发展具有能动的反作用，落后的社会意识对社会的发展起到阻碍作用，先进的社会意识可以正确预见社会发展方向和趋势，对社会的发展起到积极的推动作用。</li><li><strong>生产力</strong>：生产力是人类在生产实践中形成的改造和影响自然以使其适合社会需要的物质力量。</li><li><strong>基本要素</strong>：劳动资料、劳动对象、劳动者</li><li><strong>生产关系</strong>：人们在物质生产过程中形成的不以人的意志为转移的经济关系。</li><li><strong>生产力和生产关系的相互作用</strong>：生产力和生产关系是社会生产不可或缺的两个方面。第一，生产力决定生产关系。第二，生产关系对生产力具有能动的反作用。生产关系和生产力的相互作用是一个过程，表现为二者的矛盾作用。二者的矛盾运动规律的原理有重要的理论和现实意义：1.否定了单纯以道德为评判历史功过的是非标准的思想体系；2.是马克思主义政党指定路线方针和政策的重要依据。</li><li><strong>经济基础</strong>：是指由社会一定发展阶段的生产力所决定的生产关系的总和。</li><li><strong>上层建筑</strong>：建立在一定经济基础上的意识形态以及与之相适应的制度、组织和设施。</li><li><strong>阶级</strong>：在历史上一定的社会生产经济体系中所处地位不同的集团。</li><li><strong>人类社会的基本矛盾</strong>：生产力和生产关系、经济基础和上层建筑之间的矛盾。</li><li><strong>经济基础与上层建筑的关系</strong>：相互影响，相互作用。经济基础决定上层建筑；上层建筑对经济基础具有反作用；经济基础与上层建筑的相互作用构成二者的矛盾运动；经济基础和上层建筑之间的内在联系构成了上层建筑一定要适应经济基础状况的规律。</li><li><strong>社会形态的内涵</strong>：社会形态是关于社会运动的具体形式、发展阶段和不同质态的范畴，是同生产力发展一定阶段相适应的经济基础与上层建筑的统一体。社会形态包括社会的经济形态、政治形态和意识形态，是三者具体的历史的统一。</li><li><strong>社会基本矛盾</strong>：1.生产力是社会基本矛盾运动中最基本的动力因素，是人类社会发展和进步的最终决定力量。2.生产力是社会进步的根本内容，是衡量社会进步的根本尺度。3.社会基本矛盾特别是生产力和生产关系的矛盾，决定着社会中其他矛盾的存在和发展。</li><li><strong>主要矛盾和基本矛盾</strong>：社会基本矛盾和社会主要矛盾。 二者不是同一概念，也不是同一层次。 社会基本矛盾是其他一切社会矛盾的根源，规定和制约着社会主要矛盾的存在和发展；社会主要矛盾是社会基本矛盾的具体体现。</li><li><strong>科学技术在社会发展中的作用</strong>：1.科技革命是推动经济和社会发展的强大杠杆：对生产关系产生了深刻影响，对生产方式产生了巨大影响，促进了思维方式的改变；2.科学技术能够通过促进经济和社会发展造福于人类。</li><li><strong>阶级斗争</strong>：是社会基本矛盾在阶级社会的直接体现，是阶级社会发展的直接动力。</li></ul><h2 id="资本主义">资本主义</h2><ul><li><strong>劳动二重性</strong>：1.具体劳动：生产一定使用价值的具体形式的劳动；2.抽象劳动：人的脑力和体力耗费。3.二者在时间和空间上统一，是统一劳动过程不可分割的两个方面；另一方面，反映劳动的不同属性（具体to自然 抽象to社会）。</li><li><strong>商品二因素</strong>：使用价值和价值。对立统一：对立表现在二者相互排斥不可兼得，统一表现在作为商品必须同时具有使用价值和价值两个因素。</li><li><strong>商品经济</strong>：不是从来就有的，而是在一定历史条件下，作为自然经济的对立物而产生和发展的。</li><li><strong>资本原始积累</strong>：以暴力手段是生产者和生产资料分离，资本迅速集中于少数人手中，资本主义得以迅速发展的历史过程。</li><li><strong>资本总公式和商品交换之间的矛盾</strong>：按照等价交换原则，交换不能创造新价值，而资本总公式表明资本在流通过程中创造了新价值，关键在于劳动力成为商品。</li><li><strong>剩余价值</strong>：剩余价值是雇佣工人所创造的并被资本家无偿占有的超过劳动力价值的那部分价值。</li><li><strong>绝对剩余价值</strong>：是指在必要的劳动时间不变的条件下，由于延长工作日的长度或提高劳动强度而生产的剩余价值。</li><li><strong>相对剩余价值</strong>：是指在工作日长度不变的条件下，通过缩短必要劳动时间而延长剩余劳动时间所生产的剩余价值。</li><li><strong>资本积累</strong>：把剩余价值转化为资本，或者说，剩余价值的资本化。</li><li><strong>劳动力成为商品的基本条件</strong>：劳动者在法律上是自由人，能把自己的劳动力当作自己的商品来支配，劳动者没有其他生产资料，没有生产资料来源，因而不得不一靠出卖劳动力为主。</li><li><strong>资本主义基本矛盾</strong>：生产社会化和生产资料资本主义私人占有之间的矛盾。</li><li><strong>资本主义经济危机的本质特征</strong>：生产过剩（一种相对过剩）。</li></ul><h2 id="资本主义发展和趋势">资本主义发展和趋势</h2><ul><li><strong>垄断</strong>：指少数资本主义大企业为了获得高额利润，通过相互协议或者联合，对一个或几个部门商品的生产、销售和价格进行操纵和控制。垄断是从自由竞争中形成的，是作为自由竞争的对立面产生的，但是，垄断并不能消除竞争，反而使竞争变得更加复杂和剧烈。垄断没有消除产生竞争的经济条件；垄断过程需要通过竞争来维持；社会生产是复杂多样的，任何垄断组织都不可能把包罗万象的社会生产全部包下来。</li><li><strong>经济全球化的表现</strong>：生产全球化、贸易全球化、金融全球化。</li><li><strong>动因</strong>：科学技术的进步和生产力的发展为经济全球化提供了坚实的物质基础和根本的推动力；跨国公司的发展为经济全球化提供了适宜的企业组织形式；各国经济体制的变革和国际经济组织的发展为经济全球化提供体制和组织保障。</li><li><strong>影响</strong>：1.积极作用：为发展中国家提供先进技术和管理经验，提供更多的就业机会，推动发展中国家的贸易发展，促进发展中国家跨国公司的发展。2.消极作用：发达国家和发展中国家在经济全球化过程中的地位和收益不平等，加剧了发展中国家的环境污染，一定程度上增加了经济风险。</li></ul><h2 id="社会主义（从空想到科学）">社会主义（从空想到科学）</h2><ul><li><strong>马克思剩余价值学说的意义</strong>：剩余价值学说深刻揭示了资本家剥削工人的秘密，揭示了无产阶级与资产阶级利益的根本对立，从而科学论证了无产阶级肩负的推翻资本主义旧世界建设社会主义新世界的历史使命，使人们找到了变革资本主义旧社会的力量和通向社会主义新社会的途径。</li><li><strong>唯物史观</strong>：深刻揭示了人类历史发展的一般规律，揭示了人民群众的历史主体作用，揭示了阶级斗争在阶级社会发展中的巨大作用，从而把人们对社会主义的追求建立在对社会发展客观规律科学认识的基础上，克服了空想社会主义者不懂得历史规律的根本缺陷。</li><li><strong>科学社会主义核心命题</strong>：资本主义必然灭亡，社会主义必然胜利。 两个必然的根本依据是人类社会发展规律。 两个绝不会是指：“无论哪一个社会形态，在它所能容纳的全部生产力发挥出来以前，是决不会灭亡的；而新的更高的生产关系，在它的物质存在条件在旧社会的胎胞里成熟以前，是决不会出现的。”要把两个必然和两个绝不会联系起来全面把握。</li></ul>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> general course </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>calculus</title>
      <link href="/2023/12/19/calculus/"/>
      <url>/2023/12/19/calculus/</url>
      
        <content type="html"><![CDATA[<blockquote><p>实测部分浏览器可能无法识别Latex公式，建议使用Google Chrome或移步知乎食用！</p></blockquote><blockquote><p>本文搬运自本人知乎，原文链接为:  <a href="https://zhuanlan.zhihu.com/p/627529870">https://zhuanlan.zhihu.com/p/627529870</a></p></blockquote><h1>常数项级数</h1><h2 id="从正项级数的收敛判定到任意项级数的收敛判定">从正项级数的收敛判定到任意项级数的收敛判定</h2><h3 id="正项级数的收敛判定（8种方法）">正项级数的收敛判定（8种方法）</h3><p>如下：</p><p>1.定义法；2.柯西收敛；3.前n项部分和有上界；4.比较判别法；5.比较判别法（极限版本）（+p级数=阶估法）；6.比值（达朗贝尔）判别法；7.积分判别法；8.柯西根值.</p><h3 id="任意项级数的收敛判定（6种方法）">任意项级数的收敛判定（6种方法）</h3><p>如下：1.定义法；2.柯西收敛；3.绝对收敛；4.使用柯西根值或达朗贝尔判别不绝对收敛时发散;5.迪利克雷判别法和阿贝尔判别法；6.交错级数的莱布尼茨判别法.</p><blockquote><p>先看必要条件是否满足（通项趋于0），再看是否绝对收敛（正项级数），若不绝对收敛，再看是否发散（迪阿莱）.</p></blockquote><h3 id="正部级数-负部级数">正部级数&amp;负部级数</h3><p>定义：</p><p>$$<br>a_n = a_n^+ - a_n^- ,|a_n|=a_n^+ + a_n^-;<br>$$</p><p>$$<br>a_n^+ = \frac{a_n+|a_n|}{2},a_n^-= \frac{|a_n|-a_n}{2}.<br>$$</p><h3 id="绝对收敛与条件收敛">绝对收敛与条件收敛</h3><p>几个定理：</p><p><strong>TH1.</strong> 级数绝对收敛必然收敛.</p><p><strong>TH2.</strong> 级数$\Sigma _{n=1} ^ \infty a_n$绝对收敛的充要条件即为正部级数和负部级数均收敛.</p><p><strong>TH3.</strong> 绝对收敛级数可任意更序，和不变.</p><p><strong>TH4.</strong>  （黎曼定理）对于条件收敛的级数，可更换其次序使其收敛于任意给定数或以任意形式发散.</p><h3 id="阿贝尔变换（几何直观）">阿贝尔变换（几何直观）</h3><p>$$<br>\Sigma_{i=1}^n a_ib_i=a_nB_n -\Sigma_{i=1}^{n-1}(a_{i+1}-a_i)B_i<br>$$</p><h3 id="迪利克雷判别法和阿贝尔判别法">迪利克雷判别法和阿贝尔判别法</h3><p>前提条件：</p><p>$$<br>\Sigma u_n =\Sigma a_nb_n<br>$$</p><p>迪：</p><p>$$<br>{a_n} 单调，且lim_{n\rightarrow\infty} a_n=0<br>$$</p><p>$$<br>{b_n} 的前n项部分和序列有界<br>$$</p><p>阿：</p><p>$$<br>{a_n} 单调有界<br>$$</p><p>$$<br>{b_n} 收敛<br>$$</p><h3 id="交错级数">交错级数</h3><p>$$<br>\Sigma (-1)^{n+1} u_n , u_n&gt;0<br>$$</p><h3 id="交错级数的莱布尼茨判别法">交错级数的莱布尼茨判别法</h3><p>若$u_n\geq u_{n+1} , lim_{n\rightarrow \infty}u_n=0$,则收敛，其和$S\leq u_1.$</p><h2 id="几道例题">几道例题:</h2><blockquote><p>$\Sigma\frac{(-1)^n}{\sqrt{n}-(-1)^n}$  (有理化，发散)</p></blockquote><blockquote><p>$\Sigma sinnx$ (sin(x/2))</p></blockquote><h1>广义积分</h1><h2 id="敛散性的判定">敛散性的判定</h2><p>1.柯西收敛；2.比较判别法（非负）&amp;极限形式；3.阶估法（非负）（两个重要的广义积分）；4.绝对收敛定理；5.迪利克雷判别法.</p><h2 id="迪利克雷判别法">迪利克雷判别法</h2><p>$判定\int_a^{+\infty}f(x)g(x)收敛：$</p><p>条件：</p><p>$\int_a^xf(x)dx在[a，+\infty)上有界,g(x)在[a,+\infty)上单调且趋于零$</p><p>证明：</p><p>使用积分第二中值定理.</p><h2 id="TIPS">TIPS</h2><p>1.当$f(x)$非负且单调递减时，可以用使用积分判别法转化为判定相应级数的敛散性.</p><p>2.广义积分收敛时，被积函数未必趋于零.</p><p>(eg.$\int_1^{+\infty}sin(x^2)dx$).</p><p>3.上下限之间只有一个奇点，多个奇点要将广义积分进行拆分.</p><h2 id="几道例题-2">几道例题</h2><blockquote><p>$\int_1^{+\infty}sin(x^2)$(换元)</p></blockquote><blockquote><p>$\int_0^{+\infty}|\frac{sinx}{x}|dx$($1.\geq\frac{sin^2x}{x};2.\int_{k\pi}^{(k+1)\pi}|\frac{sinx}{x}|dx$)</p></blockquote><h1>函数项级数</h1><h2 id="一些概念">一些概念</h2><p>一般项/通项 部分和函数 收敛点 发散点 收敛域 发散域 和函数</p><h2 id="一句话">一句话</h2><p>要讨论函数项级数的收敛、发散、绝对收敛、绝对发散，只需要将$x$任意固定，再应用常数项级数的一切有关敛散性定理.</p><h2 id="幂级数">幂级数</h2><h3 id="阿贝尔第一定理（从收敛到绝对收敛）">阿贝尔第一定理（从收敛到绝对收敛）</h3><p>1.如果幂级数$\Sigma a_nx^n$在点$x=x_0(x_0\neq0)$收敛，则它在区间$|x|&lt;|x_0|$中绝对收敛；</p><p>2.如果幂级数$\Sigma a_nx^n$在点$x=x_1$发散，则在满足$|x|&gt;|x_1|$的点上都发散.</p><h3 id="收敛半径的存在性">收敛半径的存在性</h3><p>如果幂级数具有非零的收敛点与发散点，则必存在一个确定的非负数，使得当$|x|&lt;R$时，级数绝对收敛；而当$|x|&gt;R$时级数发散.</p><h3 id="求收敛半径">求收敛半径</h3><p>$$<br>lim_{n \rightarrow\infty}|\frac{a_n}{a_{n+1}}|<br>$$</p><p>$$<br>\lim_{n \rightarrow\infty }\frac{1}{|a_n|^{\frac{1}{n}}}<br>$$</p><h3 id="TIPS-2">TIPS</h3><p>关于幂级数的很多结论都是针对标准形式的，因此会出现一些典型问题比如缺项，可换元解决，或直接依靠定义讨论.</p><h3 id="一道例题">一道例题</h3><blockquote><p>证明：若$f$是$[a,+\infty)$上的单调函数，且$\int_a^{+\infty}f(x)dx$收敛，则$lim_{x\rightarrow +\infty }f(x)=0$，且$f(x)=o(1/x),x\rightarrow +\infty.$</p></blockquote><blockquote><p>思路：1.证有极限-&gt;证有界;2.证极限为0-&gt;反证;3.证高阶小量-&gt;积分中值定理&amp;夹逼.</p></blockquote><h2 id="一致收敛函数项级数的分析性质">一致收敛函数项级数的分析性质</h2><h3 id="一致收敛">一致收敛</h3><h4 id="直观">直观</h4><p>收敛速度可以总体控制.</p><h4 id="定义">定义</h4><p>${f_n(x)}\rightrightarrows f(x) ,x\in I\iff\forall\epsilon&gt;0,\exists N&gt;0, n&gt;N,|f_n(x)-f(x)|&lt;\epsilon,x \in I .$</p><p>${\Sigma u_n(x)}\rightrightarrows S(x) ,x\in I.$$ \iff \forall \epsilon&gt;0,\exists N&gt;0, n&gt;N,|u_1(x)+…+u_n(x)-S(x)|&lt;\epsilon,x\in I .$</p><p>$\iff\forall\epsilon &gt;0, \exists N&gt;0,n&gt;N,\forall p\in N,|u_{n+1}(x)+…+u_{n+p}(x)|&lt;\epsilon ,x\in I$</p><p>$\iff lim_{n\rightarrow\infty}\ sup_{x\in I}|S_n(x)-S(x)|=0.$</p><blockquote><p>上确界和柯西准则在证明不一致收敛时比较好用.</p></blockquote><h4 id="判定">判定</h4><p>M判别法:</p><blockquote><p>数项级数一致收敛.</p></blockquote><p>$$<br>对 \Sigma u_n(x),若：|u_n(x)|&lt;a_n,\forall x\in I  ; \Sigma a_n 收敛<br>$$</p><p>$$<br>则 \Sigma u_n 收敛且一致收敛.<br>$$</p><blockquote><p>Pf.柯西收敛准则.</p></blockquote><p>迪利克雷判别法：</p><p>若：</p><p>$$<br>1.对区间I上每一个固定的x,数列{a_n(x)}单调且一致趋于零;<br>$$</p><p>$$<br>2.函数项级数\Sigma b_i(x)的部分和数列{B_n(x)}在I上一致有界.<br>$$</p><p>则：</p><p>$$<br>\Sigma a_ib_i在I上一致收敛.<br>$$</p><p>阿贝尔判别法:</p><p>若:</p><p>$$<br>1.对区间I上每一个固定的x,数列{a_n(x)}单调且一致有界;<br>$$</p><p>$$<br>2.函数项级数\Sigma b_i(x)在I上一致收敛.<br>$$</p><p>则:</p><p>$$<br>\Sigma a_ib_i在I上一致收敛.<br>$$</p><h3 id="关于连续性">关于连续性</h3><p>$$<br>若u_n(x)(n=1,2,…)在[a,b]上连续；\Sigma u_n(x)\rightrightarrows S(x),x\in [a,b].<br>$$</p><p>$$<br>则S(x)在[a,b]上连续.<br>$$</p><blockquote><p>Pf.搭桥.$S(x)-S_n(x)$,$S_n(x)-S_n(x_0)$,$S_n(x_0)-S(x_0)$.</p></blockquote><blockquote><p>实际上是两种极限次序的交换.</p></blockquote><h3 id="逐项求积分">逐项求积分</h3><p>$$<br>若u_n(x)(n=1,2,…)在[a,b]上连续；\Sigma u_n(x)\rightrightarrows S(x),x\in [a,b].<br>$$</p><p>$$<br>则S(x)在[a,b]上可积，并且可逐项求积分,\int_a^b\Sigma u_n(x)dx=\int_a^bS(x)dx=\Sigma\int_a^b u_n(x)dx.<br>$$</p><blockquote><p>Pf.$r_n(x)\rightrightarrows0$.</p></blockquote><h3 id="逐项求导">逐项求导</h3><p>若：</p><p>$$<br>1.u_n(x)在[a,b]连续可导;<br>$$</p><p>$$<br>2.\Sigma u_n(x)\rightarrow S(x),x\in [a,b]；<br>$$</p><p>$$<br>3.\Sigma u_n^{'}(x)\rightrightarrows U(x),x\in[a,b].<br>$$</p><p>则:</p><p>$$<br>S(x)在[a,b]上连续可导，并且可逐项求导，即S^{'}(x)=U(x).<br>$$</p><blockquote><p>注意，以上关于连续性、逐项积分、逐项求导的讨论都是在闭区间.</p></blockquote><h3 id="内闭一致收敛">内闭一致收敛</h3><p>若$\Sigma u_n(x)$在开区间的任意一个闭子区间都一致收敛，则成为其在区间$I$上内闭一致收敛.</p><blockquote><p>连续性和逐项求导可在内闭一致区间上进行推广.</p></blockquote><h2 id="幂级数的分析性质">幂级数的分析性质</h2><h3 id="阿贝尔第二定理">阿贝尔第二定理</h3><p>已知:</p><p>$$<br>幂级数\Sigma a_n x^n的收敛半径为R&gt;0<br>$$</p><p>有:</p><p>$$<br>（1）幂级数在(-R,R)上内闭一致收敛<br>$$</p><p>$$<br>（2）若在右端点R出收敛，则对\forall0&lt;\delta&lt;2R,幂级数在[-R+\delta,R]上一致收敛<br>$$</p><p>$$<br>（3）左端点类似（2）<br>$$</p><blockquote><p>Pf.（1）M判别法；（2）（3）阿贝尔.</p></blockquote><h3 id="幂级数的分析性质-2">幂级数的分析性质</h3><p>和函数在收敛域内连续、可逐项积分、可逐项求导.逐项求导或求积分后收敛半径不变但端点的收敛性未必.</p><p>推论：</p><ul><li>级数$\Sigma_{n=1}^{\infty}na_nx^{n-1}$,$\Sigma_{n=0}^{\infty}\frac{a_n}{n+1}x^{n+1}$,$\Sigma_0^{\infty}a_nx^n$有相同的收敛半径.</li><li>幂级数$\Sigma_nx^n$的收敛半径为$R$，则在$(-R,R)$内该级数可逐项求导数任意次，逐项求积分任意次.</li></ul><h2 id="函数的幂级数展开">函数的幂级数展开</h2><h3 id="函数幂级数展开的存在唯一性">函数幂级数展开的存在唯一性</h3><p>设函数$f$在点a的邻域$U=U(a,R)$上任意阶可导，则：</p><ul><li><p>$f$在$U$上可展成泰勒级数的充要条件是函数$f$所展成的泰勒公式中的余项$r_n(x)$在$U$上处处收敛于$0$.即：</p><p>$$<br>f(x)=\Sigma_{k=0}^{\infty}\frac{f^{(k)}(a)}{k!}(x-a)^k\iff lim_{n\rightarrow\infty}r_n(x)=0,\forall x\in U.<br>$$</p></li><li><p>若$f$可在$U$上展成幂级数，则这个幂级数唯一，就是$f$在点$a$的泰勒级数.</p></li></ul><h3 id="基本展开式">基本展开式</h3><ul><li>$$<br>e^x=1+x+\frac{x^2}{2!}+…+\frac{x^n}{n!}+…, (-\infty &lt;x&lt; +\infty)<br>$$</li><li>$$<br>sinx=x-\frac{x^3}{3!}+…+(-1)^{m-1}\frac{x^{2m-1}}{(2m-1)!}+…,(-\infty &lt;x&lt; +\infty)<br>$$</li><li>$$<br>cosx=1-\frac{x}{2!}+…+(-1)^m\frac{x^{2m}}{(2m)!},(-\infty &lt;x&lt; +\infty)<br>$$</li><li>$$<br>(1+x)^\mu=1+\mu x+\frac{\mu(\mu-1)}{2!}+…+\frac{\mu(\mu-1)…(\mu-n+1)}{n!}x^n+…,(-1&lt;x&lt;1,\forall\mu)<br>$$</li></ul><blockquote><p>1/(1+x)和1/(1-x)展开式很常用</p></blockquote><ul><li>$$<br>ln(1+x)=x-\frac{x^2}{2}+\frac{x^3}{3}+…+(-1)^{n-1}\frac{x^n}{n}+…,(-1&lt;x\leq1)<br>$$</li></ul><blockquote><p>求一个函数的展开式的方法有二：一，利用定义直接求；二，利用求导求积分等运算和以上几个基本式子间接求出.</p></blockquote><h1>含参积分</h1><h2 id="含参常义积分">含参常义积分</h2><h3 id="连续性">连续性</h3><p>设函数$f$在$D={(x,y):a\leq x\leq b,y\in I}$上连续，则$\phi(y)=\int_a^bf(x,y)dx$在$I$上连续，特别的，对$y_0\in I$，有$lim_{y\rightarrow y_0}\int_a^bf(x,y)dx=\int_a^blim_{y\rightarrow y_0}f(x,y)dx$,即极限和积分的运算顺序可以交换.</p><blockquote><p>推论：设函数$f(x,y)$在$a(y)\leq b(y),y\in I$上连续，函数$a(y),b(y)$在$I$上连续，则含参变量$y$的积分  $ \phi(y)=\int_{a(y)}^{b(y)}f(x,y)dx$ 在$I$上连续.</p></blockquote><h3 id="积分号下求导">积分号下求导</h3><p>设$f$与$\frac{\partial f}{\partial y}$在$D={(x,y):a\leq x\leq b,y\in I}$上连续，则$\phi$在$I$上可导，且有（莱布尼茨公式）：</p><p>$$<br>\phi^{'}(y)=\frac{d}{dy}\int_a^bf(x,y)dx=\int_a^b\frac{\partial }{\partial y}f(x,y)dx,\forall y\in I.<br>$$</p><p>设二元函数$f$与$\frac{\partial f}{\partial y}$在$D={(x,y):a\leq x\leq b,\alpha\leq y\leq\beta}$上连续,函数$a(y),b(y)$在$[\alpha,\beta]$上有连续导数，且$a\leq a(y)\leq b,a\leq b(y)\leq b$,则函数</p><p>$$<br>\phi(y)=\int_{a(y)}^{b(y)}f(x,y)dx<br>$$</p><p>在</p><p>$[\alpha,\beta]$上具有连续导数，且有</p><p>$$<br>\phi^{‘}(y)=\int_{a(y)}^{b(y)}f_y(x,y)dx+f(b(y),y)b^{’}(y)-f(a(y),y)a^{'}(y),y\in [\alpha,\beta]<br>$$</p><h3 id="积分换序">积分换序</h3><p>条件同连续性.</p><h2 id="含参广义积分">含参广义积分</h2><h3 id="一致收敛-2">一致收敛</h3><p>$$<br>\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,s.t. 当A&gt;A_0,\forall y\in I,|\int_A^{+\infty}f(x,y)dx|&lt;\epsilon<br>$$</p><p>$$<br>\iff lim_{A\rightarrow+\infty}sum_{y\in I}|\int^{+\infty}_Af(x,y)dx|=0<br>$$</p><p>$$<br>\iff\forall\epsilon&gt;0,\exists A_0=A_0(\epsilon)\geq a,\forall A_2&gt;A_1&gt;A_0 有|\int^{A_2}_{A_1}f(x,y)dx|&lt;\epsilon,\forall y\in I<br>$$</p><h3 id="M判别法">M判别法</h3><p>条件：</p><ul><li>$$<br>\exists M(x),s.t. |f(x,y)|\leq M(x),\forall (x,y)\in D<br>$$</li><li>$$<br>\int _a^b M(x)dx 收敛<br>$$</li></ul><p>结论：</p><ul><li>$$<br>\int_a^bf(x,y)dx 在I上一致收敛.<br>$$</li></ul><h3 id="分析性质">分析性质</h3><p>针对连续性、积分号下求导、积分顺序交换的分析，此处略过.</p><h2 id="Gamma-函数和-B函数">$\Gamma$函数和 B函数</h2><p>了解定义域、递推关系、不同形式、两者之间的关系、余元公式.</p><h2 id="傅里叶级数">傅里叶级数</h2><p>求傅里叶级数</p>]]></content>
      
      
      <categories>
          
          <category> notes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> math </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
